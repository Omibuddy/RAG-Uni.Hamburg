[
  {
    "page_content": "Prof. Dr. Janick Edinger Distributed Systems and Middleware 06 â€“ Replication and Consensus",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 1,
      "chunk_id": "p1c1",
      "title": "Prof. Dr. Janick Edinger Distributed Systems and Middleware 06 â€“ Replication and Consensus",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Agenda â–ªReplication â–ªConsensus DSM06Replication and Consensus",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 2,
      "chunk_id": "p2c1",
      "title": "Agenda â–ªReplication â–ªConsensus DSM06Replication and Consensus",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Replication â–ªKeeping a copy of the same data on multiple nodes â–ªDatabases, filesystems, caches, â€¦ â–ªA node that has a copy of the data is called replica â–ªIf some replicas are faulty, others are still accessible â–ªIdea: Spread load across many replicas â–ªEasy if data does not change: just copy it â–ªWe will focus on data changes â–ªCompare to RAID (Redundant Array of Independent Disks): DSM06Replication",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 3,
      "chunk_id": "p3c1",
      "title": "Replication â–ªKeeping a copy of the same data on multiple nodes â–ªDatabases, filesystems, caches, â€¦ â–ªA",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "focus on data changes â–ªCompare to RAID (Redundant Array of Independent Disks): DSM06Replication and Consensus",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 3,
      "chunk_id": "p3c2",
      "title": "Replication â–ªKeeping a copy of the same data on multiple nodes â–ªDatabases, filesystems, caches, â€¦ â–ªA",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Replication â–ªKeeping a copy of the same data on multiple nodes â–ªDatabases, filesystems, caches, â€¦ â–ªA node that has a copy of the data is called replica â–ªIf some replicas are faulty, others are still accessible â–ªIdea: Spread load across many replicas â–ªEasy if data does not change: just copy it â–ªWe will focus on data changes â–ªCompare to RAID (Redundant Array of Independent Disks): replication within",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 4,
      "chunk_id": "p4c1",
      "title": "Replication â–ªKeeping a copy of the same data on multiple nodes â–ªDatabases, filesystems, caches, â€¦ â–ªA",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "focus on data changes â–ªCompare to RAID (Redundant Array of Independent Disks): replication within a single computer â–ªRAID has a single controller; in distributed system, each node acts independently â–ªReplicas can be distributed around the world, near users DSM06Replication and Consensus",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 4,
      "chunk_id": "p4c2",
      "title": "Replication â–ªKeeping a copy of the same data on multiple nodes â–ªDatabases, filesystems, caches, â€¦ â–ªA",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Why Replication? 1) Performance enhancement â–ªDistributed systems have to scale in numbers and geographical scope â–ªMultiple servers with replicated data giving diverse processes access to data â–ªAccess time may be much shorter 2) Faulttolerant service â–ªGuarantees correct behavior in spite of certain faults â–ªIf f of f+1 servers crash then 1 remains to supply the service â–ªIf f of 2f+1 servers have",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 5,
      "chunk_id": "p5c1",
      "title": "Why Replication? 1) Performance enhancement â–ªDistributed systems have to scale in numbers and geogra",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "faults â–ªIf f of f+1 servers crash then 1 remains to supply the service â–ªIf f of 2f+1 servers have byzantine faults then the system can supply a correct service DSM06Replication and Consensus",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 5,
      "chunk_id": "p5c2",
      "title": "Why Replication? 1) Performance enhancement â–ªDistributed systems have to scale in numbers and geogra",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Why Replication? 3) Increased Availability â–ª= Proportion of time for which a service is accessible â–ªDespite of server failures and disconnected operations â–ªIf each of n servers has an independent probability p of of failing DSM06Replication and Consensus",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 6,
      "chunk_id": "p6c1",
      "title": "Why Replication? 3) Increased Availability â–ª= Proportion of time for which a service is accessible â–ª",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Why Replication? 3) Increased Availability â–ª= Proportion of time for which a service is accessible â–ªDespite of server failures and disconnected operations â–ªIf each of n servers has an independent probability p of of failing â–ªavailability = 1 â€“ probability(all servers failed) = 1 â€“ pn â–ª1 â€“ 0.052 = 1 â€“ 0.0025 = 99,75% (for p = 0.05 and n = 2) â–ª1 â€“ 0.053 = 1 â€“ 0.000125 = 99,9875% (for p = 0.05 and n",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 7,
      "chunk_id": "p7c1",
      "title": "Why Replication? 3) Increased Availability â–ª= Proportion of time for which a service is accessible â–ª",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "â€“ 0.0025 = 99,75% (for p = 0.05 and n = 2) â–ª1 â€“ 0.053 = 1 â€“ 0.000125 = 99,9875% (for p = 0.05 and n = 3) â–ªfor p = 0.01: DSM06Replication and Consensus replicas n P( â‰¥ 1 faulty) P(â‰¥ ğ’+ğŸ ğŸ) faulty P(all n faulty) 0.01 0.01 0.01 0.03 3 Ã— 104 106 0.049 1 Ã— 105 1010 0.63 6 Ã— 1074 10200",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 7,
      "chunk_id": "p7c2",
      "title": "Why Replication? 3) Increased Availability â–ª= Proportion of time for which a service is accessible â–ª",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Requirements for Replicated Data Replication transparency â–ªClients see logical objects (not several physical copies) â–ªThey access one logical item and receive a single result Consistency â–ªAll replicas should have â€œthe sameâ€ state â–ªE.g",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 8,
      "chunk_id": "p8c1",
      "title": "Requirements for Replicated Data Replication transparency â–ªClients see logical objects (not several ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". when a user of a calendar disconnects, the local copy may be inconsistent with the others and will need to be reconciled when they connect again â–ªConnected clients using different copies should get consistent results â–ªThese issues are addressed in every distributed database DSM06Replication and Consensus",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 8,
      "chunk_id": "p8c2",
      "title": "Requirements for Replicated Data Replication transparency â–ªClients see logical objects (not several ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Implementing Replication â–ªA collection of Replicat Managers (RMs) provides a service to clients",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 9,
      "chunk_id": "p9c1",
      "title": "Implementing Replication â–ªA collection of Replicat Managers (RMs) provides a service to clients. â–ªCl",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªClients see a service that gives them access to logical objects, which are in fact replicated at the RMs â–ªClients request operations: â–ªThose without updates are called readonly requests â–ªThe others are called update requests (they may include reads) â–ªClients requests are handled by front ends â–ªA front end (FE) makes replication transparent DSM06Replication and Consensus",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 9,
      "chunk_id": "p9c2",
      "title": "Implementing Replication â–ªA collection of Replicat Managers (RMs) provides a service to clients. â–ªCl",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Requests Processing: 5 Phases DSM06Replication and Consensus 1) Issue request â–ªThe FE either â–ªSends the request to a single RM that passes it on to the others â–ªMulticasts the request to all of the RMs 2) Coordination â–ªThe RMs decide whether to apply the request 3) Execution â–ªRMs execute the request 4) Agreement â–ªRMs reach consensus on the effect of the request 5) Response â–ªOne or more RMs respond",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 10,
      "chunk_id": "p10c1",
      "title": "Requests Processing: 5 Phases DSM06Replication and Consensus 1) Issue request â–ªThe FE either â–ªSends ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "4) Agreement â–ªRMs reach consensus on the effect of the request 5) Response â–ªOne or more RMs respond to the FE, e.g",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 10,
      "chunk_id": "p10c2",
      "title": "Requests Processing: 5 Phases DSM06Replication and Consensus 1) Issue request â–ªThe FE either â–ªSends ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªFor high availability give first response to client. â–ªTo tolerate byzantine faults: Take a vote",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 10,
      "chunk_id": "p10c3",
      "title": "Requests Processing: 5 Phases DSM06Replication and Consensus 1) Issue request â–ªThe FE either â–ªSends ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Passive (Primary/Backup) Replication â–ªThere is at any time a single primary RM and one or more secondary (backup, slave) RMs â–ªFEs communicate with the primary â–ªPrimary executes the operation and sends copies of the updated data to the result to backups â–ªIf the primary fails, one of the backups is promoted to act as the primary DSM06Replication and Consensus",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 11,
      "chunk_id": "p11c1",
      "title": "Passive (Primary/Backup) Replication â–ªThere is at any time a single primary RM and one or more secon",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Passive (Primary/Backup) Replication â–ªRequest: FE issues request with unique identifier to the primary RM â–ªCoordination: Primary takes requests in FIFO order, if request already executed â€“ resend the response â–ªExecution: Primary executes the request and saves the response â–ªAgreement: If request is an update, primary sends update with identifier to all backups â–ªResponse: Primary responds to FE",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 12,
      "chunk_id": "p12c1",
      "title": "Passive (Primary/Backup) Replication â–ªRequest: FE issues request with unique identifier to the prima",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "is an update, primary sends update with identifier to all backups â–ªResponse: Primary responds to FE DSM06Replication and Consensus If the primary fails, one of the backups is promoted to act as the primary",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 12,
      "chunk_id": "p12c2",
      "title": "Passive (Primary/Backup) Replication â–ªRequest: FE issues request with unique identifier to the prima",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Active Replication â–ªThe RMs are state machines all playing the same role and organized as a group â–ªAll start in the same state and perform the same operations in the same order so that their state remains identical â–ªUnderlying multicast is totally ordered and reliable â–ªIf an RM crashes it has no effect on performance of the service because the others continue as normal â–ªIt can tolerate byzantine",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 13,
      "chunk_id": "p13c1",
      "title": "Active Replication â–ªThe RMs are state machines all playing the same role and organized as a group â–ªA",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "on performance of the service because the others continue as normal â–ªIt can tolerate byzantine failures because the FE can collect and compare the replies it receives DSM06Replication and Consensus",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 13,
      "chunk_id": "p13c2",
      "title": "Active Replication â–ªThe RMs are state machines all playing the same role and organized as a group â–ªA",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Active Replication â–ªRequest: FE multicast request with unique identifier to a group of RMs â–ªCoordination: The communication system delivers the request to every correct replica manager in the same (total) order â–ªExecution: Every RM executes the request â€“ correct RMs process request identically â–ªAgreement: No agreement is needed, because of the multicast delivery semantics â–ªResponse: Each RM sends",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 14,
      "chunk_id": "p14c1",
      "title": "Active Replication â–ªRequest: FE multicast request with unique identifier to a group of RMs â–ªCoordina",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "No agreement is needed, because of the multicast delivery semantics â–ªResponse: Each RM sends its response to the FE",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 14,
      "chunk_id": "p14c2",
      "title": "Active Replication â–ªRequest: FE multicast request with unique identifier to a group of RMs â–ªCoordina",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". The number of replies that the FE collects depends upon the failure assumption and on the multicast algorithm. DSM06Replication and Consensus",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 14,
      "chunk_id": "p14c3",
      "title": "Active Replication â–ªRequest: FE multicast request with unique identifier to a group of RMs â–ªCoordina",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Retrying state updates DSM06Replication and Consensus DB Client 2,106",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 15,
      "chunk_id": "p15c1",
      "title": "Retrying state updates DSM06Replication and Consensus DB Client 2,106",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Retrying state updates DSM06Replication and Consensus DB Client 2,106 2,107 Deduplicating requests requires that the database tracks which requests it has already seen (in stable storage)",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 16,
      "chunk_id": "p16c1",
      "title": "Retrying state updates DSM06Replication and Consensus DB Client 2,106 2,107 Deduplicating requests r",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Idempotence A function f is idempotent if f(x) = f(f(x)). â–ªNot idempotent: f(likeCount) = likeCount +1 â–ªIdempotent: f(likeSet) = likeSet â‹ƒ{userID} Idempotent requests can be retried without deduplication. DSM06Replication and Consensus",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 17,
      "chunk_id": "p17c1",
      "title": "Idempotence A function f is idempotent if f(x) = f(f(x)). â–ªNot idempotent: f(likeCount) = likeCount ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Idempotence A function f is idempotent if f(x) = f(f(x)). â–ªNot idempotent: f(likeCount) = likeCount +1 â–ªIdempotent: f(likeSet) = likeSet â‹ƒ{userID} Idempotent requests can be retried without deduplication",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 18,
      "chunk_id": "p18c1",
      "title": "Idempotence A function f is idempotent if f(x) = f(f(x)). â–ªNot idempotent: f(likeCount) = likeCount ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Choice of retry semantics: â–ªAtmostonce: â–ªsend request, donâ€™t retry, update may not happen â–ªAtleastonce: â–ªretry request until acknowledged, may repeat update â–ªExactlyonce: â–ªretry + idempotence or deduplication DSM06Replication and Consensus",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 18,
      "chunk_id": "p18c2",
      "title": "Idempotence A function f is idempotent if f(x) = f(f(x)). â–ªNot idempotent: f(likeCount) = likeCount ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Adding and then removing DSM06Replication and Consensus DB Client 1 f(likes) = likes â‹ƒ{userID} g(likes) = likes \\ {userID} Client 2",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 19,
      "chunk_id": "p19c1",
      "title": "Adding and then removing DSM06Replication and Consensus DB Client 1 f(likes) = likes â‹ƒ{userID} g(lik",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Adding and then removing DSM06Replication and Consensus DB Client 1 f(likes) = likes â‹ƒ{userID} g(likes) = likes \\ {userID} Idempotent? f(f(x)) = f(x) but f(g(f(x)) â‰  g(f(x)) Client 2",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 20,
      "chunk_id": "p20c1",
      "title": "Adding and then removing DSM06Replication and Consensus DB Client 1 f(likes) = likes â‹ƒ{userID} g(lik",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Adding and then removing DSM06Replication and Consensus A Client B",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 21,
      "chunk_id": "p21c1",
      "title": "Adding and then removing DSM06Replication and Consensus A Client B",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Adding and then removing DSM06Replication and Consensus A Client B A Client B Final state (x âˆ‰ A, x âˆˆ B) is the same in both cases. However, what did the user want?",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 22,
      "chunk_id": "p22c1",
      "title": "Adding and then removing DSM06Replication and Consensus A Client B A Client B Final state (x âˆ‰ A, x ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Timestamps and tombstones DSM06Replication and Consensus A Client B {x â†¦ (t1 , true)} {x â†¦ (t1, true)} {x â†¦ (t2, false)} remove(x) does not actually remove x. It labels x with false to indicate it is invisible (a tombstone)",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 23,
      "chunk_id": "p23c1",
      "title": "Timestamps and tombstones DSM06Replication and Consensus A Client B {x â†¦ (t1 , true)} {x â†¦ (t1, true",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Reconciling Replicas DSM06Replication and Consensus A B {x â†¦ (t1 , true)} {x â†¦ (t2 , false)} {x â†¦ (t2 , false)} Replicas periodically communicate among themselves to check for any inconsistencies. Propagate the record with the latest timestamp, discard the records with earlier timestamps (for a given key). {x â†¦ (t2 , false)} t1 < t2 reconcile state (antientropy)",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 24,
      "chunk_id": "p24c1",
      "title": "Reconciling Replicas DSM06Replication and Consensus A B {x â†¦ (t1 , true)} {x â†¦ (t2 , false)} {x â†¦ (t",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Concurrent writes by different clients DSM06Replication and Consensus A Client B Client t1 t2 Two common approaches: â–ªLast writer wins (LLW): â–ªUse timestamps with total order (e.g. Lamport clock). Keep v2 and discard v1 if t2 > t1. â–ªData loss!",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 25,
      "chunk_id": "p25c1",
      "title": "Concurrent writes by different clients DSM06Replication and Consensus A Client B Client t1 t2 Two co",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Concurrent writes by different clients DSM06Replication and Consensus A Client B Client t1 t2 Two common approaches: â–ªLast writer wins (LLW): â–ªUse timestamps with total order (e.g. Lamport clock). Keep v2 and discard v1 if t2 > t1. â–ªData loss! â–ªMultivalue register: â–ªUse timestamps with partial order (e.g. vector clock). â–ªv2 replaces v1 if t2 > t1. â–ªPreserves both {v1, v2} if t2 || t1",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 26,
      "chunk_id": "p26c1",
      "title": "Concurrent writes by different clients DSM06Replication and Consensus A Client B Client t1 t2 Two co",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Readafterwrite consistency DSM06Replication and Consensus A Client B t1 â–ªThe client updates a value in A and B, however, the update to A fails.",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 27,
      "chunk_id": "p27c1",
      "title": "Readafterwrite consistency DSM06Replication and Consensus A Client B t1 â–ªThe client updates a value ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Readafterwrite consistency DSM06Replication and Consensus A Client B t1 â–ªThe client updates a value in A and B, however, the update to A fails. â–ªThe client reads from A and B but this time the read from B fails. â–ªThe client cannot see its own update. â–ªRequires writing to/reading from both replicas â–ªnot faulttolerant â–ªCannot write/read if one replica is unavailable",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 28,
      "chunk_id": "p28c1",
      "title": "Readafterwrite consistency DSM06Replication and Consensus A Client B t1 â–ªThe client updates a value ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Quroum (2 out of 3) DSM06Replication and Consensus A Client B t1 C â–ªWrite succeeds on B and C",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 29,
      "chunk_id": "p29c1",
      "title": "Quroum (2 out of 3) DSM06Replication and Consensus A Client B t1 C â–ªWrite succeeds on B and C",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Quroum (2 out of 3) DSM06Replication and Consensus A Client B t1 C â–ªWrite succeeds on B and C â–ªRead succeeds on A and B",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 30,
      "chunk_id": "p30c1",
      "title": "Quroum (2 out of 3) DSM06Replication and Consensus A Client B t1 C â–ªWrite succeeds on B and C â–ªRead ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Quroum (2 out of 3) DSM06Replication and Consensus A Client B t1 C â–ªWrite succeeds on B and C â–ªRead succeeds on A and B â–ªChoose between (t0 , v0) and (t1 , v1) based on timestamp",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 31,
      "chunk_id": "p31c1",
      "title": "Quroum (2 out of 3) DSM06Replication and Consensus A Client B t1 C â–ªWrite succeeds on B and C â–ªRead ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Read and write quorums DSM06Replication and Consensus â–ªIn a system with n replicas: â–ªIf a write is acknowledged by w replicas (write quorum) â–ªand we subsequently read from r replicas (read quorum) â–ªand r + w > n, â–ªâ€¦ then the read will see the previously written value (or a value that subsequently overwrote it) â–ªRead quroum and write quorum share â‰¥ 1 replica.",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 32,
      "chunk_id": "p32c1",
      "title": "Read and write quorums DSM06Replication and Consensus â–ªIn a system with n replicas: â–ªIf a write is a",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Read and write quorums DSM06Replication and Consensus â–ªIn a system with n replicas: â–ªIf a write is acknowledged by w replicas (write quorum) â–ªand we subsequently read from r replicas (read quorum) â–ªand r + w > n, â–ªâ€¦ then the read will see the previously written value (or a value that subsequently overwrote it) â–ªRead quroum and write quorum share â‰¥ 1 replica. A B C D E read quorum write quorum",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 33,
      "chunk_id": "p33c1",
      "title": "Read and write quorums DSM06Replication and Consensus â–ªIn a system with n replicas: â–ªIf a write is a",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Read and write quorums DSM06Replication and Consensus â–ªIn a system with n replicas: â–ªIf a write is acknowledged by w replicas (write quorum) â–ªand we subsequently read from r replicas (read quorum) â–ªand r + w > n, â–ªâ€¦ then the read will see the previously written value (or a value that subsequently overwrote it) â–ªRead quroum and write quorum share â‰¥ 1 replica",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 34,
      "chunk_id": "p34c1",
      "title": "Read and write quorums DSM06Replication and Consensus â–ªIn a system with n replicas: â–ªIf a write is a",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªTypical: r = w = ğ’+ğŸ ğŸfor n = 3, 5, 7, â€¦. (majority) â–ªReads can tolerate nr unavailable replicas, writes nw A B C D E read quorum write quorum",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 34,
      "chunk_id": "p34c2",
      "title": "Read and write quorums DSM06Replication and Consensus â–ªIn a system with n replicas: â–ªIf a write is a",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Read repair DSM06Replication and Consensus A Client B t1 C â–ªUpdate (t1 , v1) is more recent than (t0 , v0) since t0 < t1.",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 35,
      "chunk_id": "p35c1",
      "title": "Read repair DSM06Replication and Consensus A Client B t1 C â–ªUpdate (t1 , v1) is more recent than (t0",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Read repair DSM06Replication and Consensus A Client B t1 C â–ªUpdate (t1 , v1) is more recent than (t0 , v0) since t0 < t1. â–ªClient helps to propagate (t1 , v1) to other replicas.",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 36,
      "chunk_id": "p36c1",
      "title": "Read repair DSM06Replication and Consensus A Client B t1 C â–ªUpdate (t1 , v1) is more recent than (t0",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "State Machine Replication DSM06Replication and Consensus â–ªSo far we have used besteffort broadcast for replication",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 37,
      "chunk_id": "p37c1",
      "title": "State Machine Replication DSM06Replication and Consensus â–ªSo far we have used besteffort broadcast f",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªWhat about stronger broadcast models? â–ªTotal order broadcast: every node delivers the same message in the same order â–ªState machine replication (SRM): â–ªTotal order broadcast every update to all replicas â–ªReplica delivers update message: apply it to own state â–ªApplying an update is deterministic â–ªReplica is a state machine: starts in fixed initial state, goes through same sequence of state",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 37,
      "chunk_id": "p37c2",
      "title": "State Machine Replication DSM06Replication and Consensus â–ªSo far we have used besteffort broadcast f",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "â–ªReplica is a state machine: starts in fixed initial state, goes through same sequence of state transitions in the same order â‡’ all replicas end up in the same state",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 37,
      "chunk_id": "p37c3",
      "title": "State Machine Replication DSM06Replication and Consensus â–ªSo far we have used besteffort broadcast f",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "State Machine Replication Algorithm DSM06Replication and Consensus â–ªClosely related ideas: â–ªSerializable transactions (execute in delivery order) â–ªBlockchains, distributed ledgers, smart contracts â–ªLimitations; â–ªCannot update state immediately, has to wait for delivery through broadcast â–ªNeeds faulttolerant total order broadcast on request to perform update u do send u via total order broadcast",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 38,
      "chunk_id": "p38c1",
      "title": "State Machine Replication Algorithm DSM06Replication and Consensus â–ªClosely related ideas: â–ªSerializ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "total order broadcast on request to perform update u do send u via total order broadcast end on on delivering u through total order broadcast do update state using arbitrary deterministic logic end on",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 38,
      "chunk_id": "p38c2",
      "title": "State Machine Replication Algorithm DSM06Replication and Consensus â–ªClosely related ideas: â–ªSerializ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Database Leader Replica DSM06Replication and Consensus Client 1 L F Client 2 T1 T2 â–ªLeader database replica L ensures total order broadcast â–ªFollower F applies transaction log in commit order",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 39,
      "chunk_id": "p39c1",
      "title": "Database Leader Replica DSM06Replication and Consensus Client 1 L F Client 2 T1 T2 â–ªLeader database ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Replication using causal (and weaker) broadcast DSM06Replication and Consensus â–ªState machine replication uses total order broadcast. â–ªCan we use weaker forms of broadcast too? â–ªIf replica state updates are commutative, replicas can process updates in differents orders and still end up in the same state",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 40,
      "chunk_id": "p40c1",
      "title": "Replication using causal (and weaker) broadcast DSM06Replication and Consensus â–ªState machine replic",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªUpdate f and g are commutative if f(g(x)) = g(f(x)) broadcast assumptions about state update function total order deterministic (SMR) causal Deterministic, concurrent updates commute reliable Deterministic, all updates commute besteffort Deterministic, commutative, idempotent, tolerates message loss",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 40,
      "chunk_id": "p40c2",
      "title": "Replication using causal (and weaker) broadcast DSM06Replication and Consensus â–ªState machine replic",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Agenda â–ªReplication â–ªConsensus DSM06Replication and Consensus",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 41,
      "chunk_id": "p41c1",
      "title": "Agenda â–ªReplication â–ªConsensus DSM06Replication and Consensus",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Properties of Consensus Algorithms DSM06Replication and Consensus â–ªTermination: â–ªEach correct process eventually decides on a value â–ªAgreement: â–ªAll correct processes decide on the same value â–ªValidity/Integrity: â–ªThe agreedupon value must be one of the proposed values",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 42,
      "chunk_id": "p42c1",
      "title": "Properties of Consensus Algorithms DSM06Replication and Consensus â–ªTermination: â–ªEach correct proces",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Faulttolerant Total Order Broadcast DSM06Replication and Consensus â–ªTotal order broadcast is very useful for state machine replication. â–ªCan implement total order broadcast by sending all messages via a single leader",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 43,
      "chunk_id": "p43c1",
      "title": "Faulttolerant Total Order Broadcast DSM06Replication and Consensus â–ªTotal order broadcast is very us",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªCan implement total order broadcast by sending all messages via a single leader. â–ªProblem: What if leader crashes/becomes unavailable? â–ªManual failover: a human operator chooses a new leader, and reconfigures each node to use new leader â–ªUsed in many databases! Fine for planned maintenance. â–ªUnplanned outage? Humans are slow, may take a long time until system recovers. .",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 43,
      "chunk_id": "p43c2",
      "title": "Faulttolerant Total Order Broadcast DSM06Replication and Consensus â–ªTotal order broadcast is very us",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªUnplanned outage? Humans are slow, may take a long time until system recovers. . . â–ªCan we automatically choose a new leader?",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 43,
      "chunk_id": "p43c3",
      "title": "Faulttolerant Total Order Broadcast DSM06Replication and Consensus â–ªTotal order broadcast is very us",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Consensus and Total Order Broadcast DSM06Replication and Consensus â–ªTraditional formulation of consensus: several nodes want to come to agreement about a single value â–ªIn context of total order broadcast: This value is the next message to deliver â–ªOnce one node decides on a certain message order, all nodes will decide the same order â–ªConsensus and total order broadcast are formally equivalent",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 44,
      "chunk_id": "p44c1",
      "title": "Consensus and Total Order Broadcast DSM06Replication and Consensus â–ªTraditional formulation of conse",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "all nodes will decide the same order â–ªConsensus and total order broadcast are formally equivalent â–ªCommon consensus algorithms: â–ªPaxos: singlevalue consensus â–ªMultiPaxos: generalisation to total order broadcast (more efficient for multiple rounds) â–ªRaft: Total order broadcast by default",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 44,
      "chunk_id": "p44c2",
      "title": "Consensus and Total Order Broadcast DSM06Replication and Consensus â–ªTraditional formulation of conse",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Consensus System Model DSM06Replication and Consensus â–ªPaxos, Raft, and other assume a partially synchronous, crashrecovery system model",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 45,
      "chunk_id": "p45c1",
      "title": "Consensus System Model DSM06Replication and Consensus â–ªPaxos, Raft, and other assume a partially syn",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªWhy not asynchronous? â–ªFLP (Fischer, Lynch, Paterson) result: There is no deterministic consensus algorithm that is guaranteed to terminate in an asynchronous crashstop system model â–ªPaxos, Raft, and others use clocks only for timeouts/failure detection to ensure progress. Safety (correctness) does not depend on timing.",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 45,
      "chunk_id": "p45c2",
      "title": "Consensus System Model DSM06Replication and Consensus â–ªPaxos, Raft, and other assume a partially syn",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "System model: Node Behaviour DSM06Replication and Consensus Each node executes a specified algorithm, assuming one of the following: â–ªCrashstop (failstop): â–ªA node is faulty if it crashes (at any moment). â–ªAfter crashing, it stops executing forever. â–ªCrashrecovery (failrecovery): â–ªA node may crash at any moment, losing its inmemory state. It may resume executing sometime later",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 46,
      "chunk_id": "p46c1",
      "title": "System model: Node Behaviour DSM06Replication and Consensus Each node executes a specified algorithm",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". It may resume executing sometime later. â–ªData stored on disk survives the crash. â–ªByzantine (failarbitrary): â–ªA node is faulty if it deviates from the algorithm. â–ªFaulty nodes may do anything, including crashing or malicious behaviour. A node that is not faulty is called \"correct\"",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 46,
      "chunk_id": "p46c2",
      "title": "System model: Node Behaviour DSM06Replication and Consensus Each node executes a specified algorithm",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "System model: Synchrony (Timing) Assumptions DSM06Replication and Consensus Assume one of the following for network and nodes: â–ªSynchronous: â–ªMessage latency no greater than a known upper bound. â–ªNodes execute algorithm at a known speed. â–ªPartially synchronous: â–ªThe system is asynchronous for some finite (but unknown) periods of time, synchronous otherwise",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 47,
      "chunk_id": "p47c1",
      "title": "System model: Synchrony (Timing) Assumptions DSM06Replication and Consensus Assume one of the follow",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªAsynchronous: â–ªMessages can be delayed arbitrarily. â–ªNodes can pause execution arbitrarily. â–ªNo timing guarantees at all.",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 47,
      "chunk_id": "p47c2",
      "title": "System model: Synchrony (Timing) Assumptions DSM06Replication and Consensus Assume one of the follow",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Homework: DSM06Replication and Consensus",
    "metadata": {
      "source": "Lecture_06.pdf",
      "page": 48,
      "chunk_id": "p48c1",
      "title": "Homework: DSM06Replication and Consensus",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Prof. Dr. Janick Edinger Distributed Systems and Middleware 07 â€“ Consistency",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 1,
      "chunk_id": "p1c1",
      "title": "Prof. Dr. Janick Edinger Distributed Systems and Middleware 07 â€“ Consistency",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Agenda â–ªTwoPhase Commit â–ªConsistency Models DSM07Consistency",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 2,
      "chunk_id": "p2c1",
      "title": "Agenda â–ªTwoPhase Commit â–ªConsistency Models DSM07Consistency",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Requirements for Replicated Data Replication transparency â–ªClients see logical objects (not several physical copies) â–ªThey access one logical item and receive a single result Consistency â–ªAll replicas should have â€œthe sameâ€ state â–ªE.g",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 3,
      "chunk_id": "p3c1",
      "title": "Requirements for Replicated Data Replication transparency â–ªClients see logical objects (not several ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". when a user of a calendar disconnects, the local copy may be inconsistent with the others and will need to be reconciled when they connect again â–ªConnected clients using different copies should get consistent results â–ªThese issues are addressed in every distributed database DSM07Consistency",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 3,
      "chunk_id": "p3c2",
      "title": "Requirements for Replicated Data Replication transparency â–ªClients see logical objects (not several ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Requirements for Replicated Data Replication transparency â–ªClients see logical objects (not several physical copies) â–ªThey access one logical item and receive a single result Consistency â–ªAll replicas should have â€œthe sameâ€ state â–ªE.g",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 4,
      "chunk_id": "p4c1",
      "title": "Requirements for Replicated Data Replication transparency â–ªClients see logical objects (not several ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". when a user of a calendar disconnects, the local copy may be inconsistent with the others and will need to be reconciled when they connect again â–ªConnected clients using different copies should get consistent results â–ªThese issues are addressed in every distributed database DSM07Consistency",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 4,
      "chunk_id": "p4c2",
      "title": "Requirements for Replicated Data Replication transparency â–ªClients see logical objects (not several ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Twophase commit (2PC) DSM07Consistency State machine for coordinator State machine for participant The client who initiated the computation acts as coordinator; processes required to commit are the participants. â–ªPhase 1a: Coordinator sends VOTEREQUEST to participants (also called a prewrite) â–ªPhase 1b: When participant receives VOTEREQUEST it returns either VOTECOMMIT or VOTEABORT to coordinator",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 5,
      "chunk_id": "p5c1",
      "title": "Twophase commit (2PC) DSM07Consistency State machine for coordinator State machine for participant T",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". If it sends VOTEABORT, it aborts its local computation â–ªPhase 2a: Coordinator collects all votes; if all are VOTECOMMIT, it sends GLOBALCOMMIT to all participants, otherwise it sends GLOBALABORT â–ªPhase 2b: Each participant waits for GLOBALCOMMIT or GLOBALABORT and handles accordingly.",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 5,
      "chunk_id": "p5c2",
      "title": "Twophase commit (2PC) DSM07Consistency State machine for coordinator State machine for participant T",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Twophase commit (2PC) DSM07Consistency The client who initiated the computation acts as coordinator; processes required to commit are the participants. â–ªPhase 1a: Coordinator sends VOTEREQUEST to participants (also called a prewrite) â–ªPhase 1b: When participant receives VOTEREQUEST it returns either VOTECOMMIT or VOTEABORT to coordinator",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 6,
      "chunk_id": "p6c1",
      "title": "Twophase commit (2PC) DSM07Consistency The client who initiated the computation acts as coordinator;",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". If it sends VOTEABORT, it aborts its local computation â–ªPhase 2a: Coordinator collects all votes; if all are VOTECOMMIT, it sends GLOBALCOMMIT to all participants, otherwise it sends GLOBALABORT â–ªPhase 2b: Each participant waits for GLOBALCOMMIT or GLOBALABORT and handles accordingly.",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 6,
      "chunk_id": "p6c2",
      "title": "Twophase commit (2PC) DSM07Consistency The client who initiated the computation acts as coordinator;",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Consistency â€¦means many different things in different contexts: â–ªACID: a transaction transforms the database from one \"consistent\" state to another â–ªReadafterwrite consistency: A client should see its own write in the next read â–ªReplication: replica should be \"consistent\" with other replicas â–ª\"consistent\" = in the same state? (when exactly?) â–ª\"consistent\" = read operations return same result? â†’We",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 7,
      "chunk_id": "p7c1",
      "title": "Consistency â€¦means many different things in different contexts: â–ªACID: a transaction transforms the ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "= in the same state? (when exactly?) â–ª\"consistent\" = read operations return same result? â†’We need to choose a consistency model DSM07Consistency",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 7,
      "chunk_id": "p7c2",
      "title": "Consistency â€¦means many different things in different contexts: â–ªACID: a transaction transforms the ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Datacentric consistency models Read and write operations â–ªWi(x)a: Process Pi writes value a to x â–ªRi(x)b: Process Pi reads value b from x â–ªAll data items initially have value NIL â–ªExample DSM07Consistency P1 writes a to x. Then P2 reads x which not updated yet. Thus, it it still NIL. In the second read, x is updated and P2 reads a. *If obvious, the index is ommited. *",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 8,
      "chunk_id": "p8c1",
      "title": "Datacentric consistency models Read and write operations â–ªWi(x)a: Process Pi writes value a to x â–ªRi",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Definition: The result of any execution is the same as if the operations of all processes were executed in some sequential order, and the operations of each individual process appear in this sequence in the order specified by its program",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 9,
      "chunk_id": "p9c1",
      "title": "Definition: The result of any execution is the same as if the operations of all processes were execu",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â†’all processes see the same interleaving of operations Sequential Consistency DSM07Consistency A sequentially consistent data store A data store that is not sequentially consistent",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 9,
      "chunk_id": "p9c2",
      "title": "Definition: The result of any execution is the same as if the operations of all processes were execu",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Three concurrent processes (initial values: 0) Possible execution sequences (not exhaustive) Sequential Consistency DSM07Consistency Signature: print output from P1, P2, and P3 concatenated in this order",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 10,
      "chunk_id": "p10c1",
      "title": "Three concurrent processes (initial values: 0) Possible execution sequences (not exhaustive) Sequent",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Sequential Consistency â€“ Another Example DSM07Consistency â–ªIs it okay that P1 reads a? â–ªIs it okay that P2 reads b? â–ªIs it okay that P1 reads a and P2 reads b?",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 11,
      "chunk_id": "p11c1",
      "title": "Sequential Consistency â€“ Another Example DSM07Consistency â–ªIs it okay that P1 reads a? â–ªIs it okay t",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Sequential Consistency â€“ Another Example DSM07Consistency â–ªIs it okay that P1 reads a? â–ªYes â–ªIs it okay that P2 reads b? â–ªYes â–ªIs it okay that P1 reads a and P2 reads b? â–ªNo!",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 12,
      "chunk_id": "p12c1",
      "title": "Sequential Consistency â€“ Another Example DSM07Consistency â–ªIs it okay that P1 reads a? â–ªYes â–ªIs it o",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Why? â–ªFor P1 to read a, W1(x)a must have happened after W2(x)b. â–ªFor P2 to read b, W2(y)b must have happened after W1(y)a. Sequential Consistency â€“ Another Example DSM07Consistency â–ªIs it okay that P1 reads a? â–ªYes â–ªIs it okay that P2 reads b? â–ªYes â–ªIs it okay that P1 reads a and P2 reads b? â–ªNo!",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 13,
      "chunk_id": "p13c1",
      "title": "Why? â–ªFor P1 to read a, W1(x)a must have happened after W2(x)b. â–ªFor P2 to read b, W2(y)b must have ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "â–ªMultiple interleavings of statements are possible. â–ªA program needs to accept all valid combinations and work correctly for each of them. â–ªSequential consistency is not compositional Sequential Consistency DSM07Consistency",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 14,
      "chunk_id": "p14c1",
      "title": "â–ªMultiple interleavings of statements are possible. â–ªA program needs to accept all valid combination",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "â–ªMultiple interleavings of statements are possible. â–ªA program needs to accept all valid combinations and work correctly for each of them",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 15,
      "chunk_id": "p15c1",
      "title": "â–ªMultiple interleavings of statements are possible. â–ªA program needs to accept all valid combination",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªA program needs to accept all valid combinations and work correctly for each of them. â–ªSequential consistency is not compositional â–ªWhat we want: All operations behave as if executed on a single copy of the data (even if there are in fact multiple replicas) â–ªEach operation should appear to take effect instantaneously at some moment between its start and completion",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 15,
      "chunk_id": "p15c2",
      "title": "â–ªMultiple interleavings of statements are possible. â–ªA program needs to accept all valid combination",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â†’Linearizability (aka atomic, strong, immediate, or external consistency) Sequential Consistency DSM07Consistency",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 15,
      "chunk_id": "p15c3",
      "title": "â–ªMultiple interleavings of statements are possible. â–ªA program needs to accept all valid combination",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Linearizability â–ªIs the system linearizable? â–ªDoes the system appear like there is only a single copy of the data? No! â–ªIs this, in general, an acceptable user experience? â–ªIn which case, this would have been acceptable? DSM07Consistency",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 16,
      "chunk_id": "p16c1",
      "title": "Linearizability â–ªIs the system linearizable? â–ªDoes the system appear like there is only a single cop",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Linearizability read(x) â‡’ v and write(x,1) correspond to Ri(x)v and Wi(x)a DSM07Consistency â–ªIs the system linearizable?",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 17,
      "chunk_id": "p17c1",
      "title": "Linearizability read(x) â‡’ v and write(x,1) correspond to Ri(x)v and Wi(x)a DSM07Consistency â–ªIs the ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Linearizability read(x) â‡’ v and write(x,1) correspond to Ri(x)v and Wi(x)a DSM07Consistency â–ªIs the system linearizable? â–ªFirst read happens before write. Returns 0. Fine. â–ªLast read happens after the write. Returns 1. Fine. â–ªBut what about the other reads?",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 18,
      "chunk_id": "p18c1",
      "title": "Linearizability read(x) â‡’ v and write(x,1) correspond to Ri(x)v and Wi(x)a DSM07Consistency â–ªIs the ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Linearizability â–ªIn a linearizable system we imagine that there must be some point in time (between the start and end of the write operation) at which the value of x atomically flips from 0 to 1. DSM07Consistency",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 19,
      "chunk_id": "p19c1",
      "title": "Linearizability â–ªIn a linearizable system we imagine that there must be some point in time (between ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Background: CompareandSwap (CAS) DSM07Consistency â–ªcas(x, vold, vnew) â‡’ r means the client requested an atomic compareandswap operation. â–ªIf the current value of the register/data x equals vold, it should be atomically set vnew. The operation then returns ok. â–ªOtherwise the operation leaves the register/data unchanged and returns error.",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 20,
      "chunk_id": "p20c1",
      "title": "Background: CompareandSwap (CAS) DSM07Consistency â–ªcas(x, vold, vnew) â‡’ r means the client requested",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Linearizability DSM07Consistency To check whether operations are linearizable, we visualize when these operations take effect. If these effects monotonically increase in time, the operations are linearizable.",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 21,
      "chunk_id": "p21c1",
      "title": "Linearizability DSM07Consistency To check whether operations are linearizable, we visualize when the",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Implementing Linearizability (1/2) DSM07Consistency 1. Lock Mechanisms: To ensure operations are atomic, lock mechanisms can be used to centrally control access to a resource or data point. For example, distributed locking systems ensure that only one operation can be performed on a data point at any given time. 2",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 22,
      "chunk_id": "p22c1",
      "title": "Implementing Linearizability (1/2) DSM07Consistency 1. Lock Mechanisms: To ensure operations are ato",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". 2. Consensus Protocols: Protocols like Paxos or Raft ensure that a group of nodes agrees on the next state of a system before it is committed. This helps maintain a consistent view of the operation order across all nodes. 3. Quorum Reads and Writes: Operations are considered complete only after being confirmed by a majority (quorum) of nodes in the system",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 22,
      "chunk_id": "p22c2",
      "title": "Implementing Linearizability (1/2) DSM07Consistency 1. Lock Mechanisms: To ensure operations are ato",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". This ensures that read operations will encounter at least one node with the latest data after a write operation.",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 22,
      "chunk_id": "p22c3",
      "title": "Implementing Linearizability (1/2) DSM07Consistency 1. Lock Mechanisms: To ensure operations are ato",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Implementing Linearizability (2/2) DSM07Consistency 4. Atomic Broadcasts: These techniques ensure that all nodes receive and execute operations in the same consistent order, maintaining synchronized views across the system. 5. Transactional Mechanisms: Many systems use transactional storage and mechanisms, e.g., TwoPhase Commit (2PC), to treat sequences of operations as indivisible, atomic units",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 23,
      "chunk_id": "p23c1",
      "title": "Implementing Linearizability (2/2) DSM07Consistency 4. Atomic Broadcasts: These techniques ensure th",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". 6. Timestamp Ordering: Systems use timestamps to assign each operation a unique global timestamp, which dictates the order in which updates are applied across different nodes.",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 23,
      "chunk_id": "p23c2",
      "title": "Implementing Linearizability (2/2) DSM07Consistency 4. Atomic Broadcasts: These techniques ensure th",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Causal Consistency DSM07Consistency Definition: Writes that are potentially causally related must be seen by all processes in the same order. Concurrent writes may be seen in a different order on different machines. Is the sequence on the left â€¦ â–ªâ€¦ sequentially â€¦ â–ªâ€¦ causally â€¦ â€¦ consistent?",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 24,
      "chunk_id": "p24c1",
      "title": "Causal Consistency DSM07Consistency Definition: Writes that are potentially causally related must be",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Causal Consistency DSM07Consistency Definition: Writes that are potentially causally related must be seen by all processes in the same order. Concurrent writes may be seen in a different order on different machines.",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 25,
      "chunk_id": "p25c1",
      "title": "Causal Consistency DSM07Consistency Definition: Writes that are potentially causally related must be",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Causal Consistency DSM07Consistency Definition: Writes that are potentially causally related must be seen by all processes in the same order. Concurrent writes may be seen in a different order on different machines. A violation of a causallyconsistent store A correct sequence of events in a causallyconsistent store",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 26,
      "chunk_id": "p26c1",
      "title": "Causal Consistency DSM07Consistency Definition: Writes that are potentially causally related must be",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Causal ConsistencyExercise DSM07Consistency What will be the results of R3(x) and R4(y)?",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 27,
      "chunk_id": "p27c1",
      "title": "Causal ConsistencyExercise DSM07Consistency What will be the results of R3(x) and R4(y)?",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Causal ConsistencyExercise DSM07Consistency What will be the results of R3(x) and R4(y)? R3(x) â€“ a, because: W1(x)a â†’ R2(x)a â†’ W2(y)b â†’ R3(y)b â†’ R3(x)?",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 28,
      "chunk_id": "p28c1",
      "title": "Causal ConsistencyExercise DSM07Consistency What will be the results of R3(x) and R4(y)? R3(x) â€“ a, ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Causal ConsistencyExercise DSM07Consistency What will be the results of R3(x) and R4(y)? R3(x) â€“ a, because: W1(x)a â†’ R2(x)a â†’ W2(y)b â†’ R3(y)b â†’ R3(x)? R4(y) â€“ NIL or b, because there is no causal relationship between W2(y)b and R4(y)",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 29,
      "chunk_id": "p29c1",
      "title": "Causal ConsistencyExercise DSM07Consistency What will be the results of R3(x) and R4(y)? R3(x) â€“ a, ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Eventual Consistency â–ªLinearizability advantages: â–ªMakes a distributed system behave as if it were nondistributed â–ªSimple for applications to use â–ªDownsides: â–ªPerformance cost: lots of messages and waiting for responses â–ªScalability limits: leader can be a bottleneck â–ªAvailability problems: if you can't contact a quorum of nodes, you can't process any operations â–ªEventual consistency: a weaker",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 30,
      "chunk_id": "p30c1",
      "title": "Eventual Consistency â–ªLinearizability advantages: â–ªMakes a distributed system behave as if it were n",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "can't contact a quorum of nodes, you can't process any operations â–ªEventual consistency: a weaker model than linearizability",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 30,
      "chunk_id": "p30c2",
      "title": "Eventual Consistency â–ªLinearizability advantages: â–ªMakes a distributed system behave as if it were n",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". DSM07Consistency",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 30,
      "chunk_id": "p30c3",
      "title": "Eventual Consistency â–ªLinearizability advantages: â–ªMakes a distributed system behave as if it were n",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Eventual Consistency â–ªWeakest form of consistency â–ªAll replicas converge toward identical copies, given the absence of writewrite conflicts. â–ªRequirement: Updates guaranteed to propagate to all replicas. â–ªWriteWrite Conflicts: Resolvable, especially with a small group of processes performing updates",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 31,
      "chunk_id": "p31c1",
      "title": "Eventual Consistency â–ªWeakest form of consistency â–ªAll replicas converge toward identical copies, gi",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªWriteWrite Conflicts: Resolvable, especially with a small group of processes performing updates. â–ªConflict Resolution: In conflicts, one write operation is globally declared as the \"winner,\" overwriting conflicting operations, manual resolution (merge, conflicting copies) â–ªImplementation Cost: Eventual consistency is often cheap to implement in practice. DSM07Consistency",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 31,
      "chunk_id": "p31c2",
      "title": "Eventual Consistency â–ªWeakest form of consistency â–ªAll replicas converge toward identical copies, gi",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Consisteny Models DSM07Consistency Consistency Model Guarantee Strict Consistency Every read operation returns the most recent write based on a global timeline. Requires total global knowledge. Linearizability Operations appear instantaneously and globally in the order they were executed. Each operation seems to occur at a single point in time",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 32,
      "chunk_id": "p32c1",
      "title": "Consisteny Models DSM07Consistency Consistency Model Guarantee Strict Consistency Every read operati",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Each operation seems to occur at a single point in time. Sequential Consistency Operations appear in a single, consistent order that is the same for all processes, but not necessarily in realtime order. Causal Consistency Causally related operations appear in the correct order. Unrelated operations may appear in any order",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 32,
      "chunk_id": "p32c2",
      "title": "Consisteny Models DSM07Consistency Consistency Model Guarantee Strict Consistency Every read operati",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Unrelated operations may appear in any order. Eventual Consistency Guarantees that all copies will converge to the same value eventually if no new updates are made allowing temporary inconsistencies. Weak Consistency Provides no guarantees on the order or visibility of operations often prioritizing responsiveness and availability.",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 32,
      "chunk_id": "p32c3",
      "title": "Consisteny Models DSM07Consistency Consistency Model Guarantee Strict Consistency Every read operati",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "The CAP theorem Any networked system providing shared data can provide only two of the following three properties: â–ªConsistency, by which a shared and replicated data item appears as a single, uptodate copy â–ªAvailability, by which updates will always be eventually executed â–ªPartitioning: Tolerant to the partitioning of a process group. DSM07Consistency",
    "metadata": {
      "source": "Lecture_07.pdf",
      "page": 33,
      "chunk_id": "p33c1",
      "title": "The CAP theorem Any networked system providing shared data can provide only two of the following thr",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Prof. Dr. Janick Edinger Distributed Systems and Middleware 03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 1,
      "chunk_id": "p1c1",
      "title": "Prof. Dr. Janick Edinger Distributed Systems and Middleware 03 â€“ P2P & Naming",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Naming â€¢ A name in a distributed system is a string of bits or characters that is used to refer to an entity. â€¢ Addresses are a special kind of names and refer to an access point of an entity. â€¢ Access points are used to contact entities â€¢ Identifiers are special types of addresses: 1. An identifier refers to at most one entity 2. Each entity is referred to by at most one identifier 3",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 2,
      "chunk_id": "p2c1",
      "title": "Naming â€¢ A name in a distributed system is a string of bits or characters that is used to refer to a",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Each entity is referred to by at most one identifier 3. An identifier always refers to the same entity DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 2,
      "chunk_id": "p2c2",
      "title": "Naming â€¢ A name in a distributed system is a string of bits or characters that is used to refer to a",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "PeertoPeer Systems peer Etymology: Middle English, from Middle French per, from per, adjective, equal, from Latin par 1 : one that is of equal standing with another : EQUAL; especially : one belonging to the same societal group especially based on age, grade, or status DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 3,
      "chunk_id": "p3c1",
      "title": "PeertoPeer Systems peer Etymology: Middle English, from Middle French per, from per, adjective, equa",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Definitions Various definitions, for example: PeertoPeer is a class of applications that takes advantage of resources [...] available at the edges of the Internet. ... peertopeer nodes must operate outside the DNS and have [...] autonomy from central servers. Clay Shirky DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 4,
      "chunk_id": "p4c1",
      "title": "Definitions Various definitions, for example: PeertoPeer is a class of applications that takes advan",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Definitions Another one: Peertopeer systems are distributed systems consisting of interconnected nodes able to selforganize into network topologies with the purpose of sharing resources [â€¦], capable of adapting to failures and accommodating transient populations of nodes while maintaining acceptable connectivity and performance, without requiring the intermediation or support of a global",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 5,
      "chunk_id": "p5c1",
      "title": "Definitions Another one: Peertopeer systems are distributed systems consisting of interconnected nod",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "connectivity and performance, without requiring the intermediation or support of a global centralized server or authority",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 5,
      "chunk_id": "p5c2",
      "title": "Definitions Another one: Peertopeer systems are distributed systems consisting of interconnected nod",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". AndroutsellisTheotokis and Spinellis DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 5,
      "chunk_id": "p5c3",
      "title": "Definitions Another one: Peertopeer systems are distributed systems consisting of interconnected nod",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "An Ancient Example: The Usenet â€¢ Exchange of messages in newsgroups â€¢ Synchronization between hosts â€¢ Periodically using socalled newsfeeds â€¢ News server are organized in an overlay network â€¢ Forwarding of messages to all interested neighbours â€¢ Prevention of forwarding loops: messages contain a history of visited news servers â€¢ The Usenet is an early (and current) example of a P2P system DSM03 â€“",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 6,
      "chunk_id": "p6c1",
      "title": "An Ancient Example: The Usenet â€¢ Exchange of messages in newsgroups â€¢ Synchronization between hosts ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "of visited news servers â€¢ The Usenet is an early (and current) example of a P2P system DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 6,
      "chunk_id": "p6c2",
      "title": "An Ancient Example: The Usenet â€¢ Exchange of messages in newsgroups â€¢ Synchronization between hosts ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "An Ancient Example: The Usenet â€¢ Exchange of messages in newsgroups â€¢ Synchronization between hosts â€¢ Periodically using socalled newsfeeds â€¢ News server are organized in an overlay network â€¢ Forwarding of messages to all interested neighbours â€¢ Prevention of forwarding loops: messages contain a history of visited news servers â€¢ The Usenet is an early (and current) example of a P2P system DSM03 â€“",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 7,
      "chunk_id": "p7c1",
      "title": "An Ancient Example: The Usenet â€¢ Exchange of messages in newsgroups â€¢ Synchronization between hosts ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "of visited news servers â€¢ The Usenet is an early (and current) example of a P2P system DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 7,
      "chunk_id": "p7c2",
      "title": "An Ancient Example: The Usenet â€¢ Exchange of messages in newsgroups â€¢ Synchronization between hosts ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Application Classes using P2P â€¢ Communication and collaboration between users â€¢ Goal: Applications that enable direct communication between peers â€¢ For example, chat systems based on Jabber, VoIP systems like Skype â€¢ Distributed Computing â€¢ Goal: Sharing of processing power between peers â€¢ Example: Seti@home, genome@home â€¢ Internet Service Support â€¢ Goal: Support of Internet services based on P2P",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 8,
      "chunk_id": "p8c1",
      "title": "Application Classes using P2P â€¢ Communication and collaboration between users â€¢ Goal: Applications t",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Seti@home, genome@home â€¢ Internet Service Support â€¢ Goal: Support of Internet services based on P2P â€¢ Example: P2P multicast systems DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 8,
      "chunk_id": "p8c2",
      "title": "Application Classes using P2P â€¢ Communication and collaboration between users â€¢ Goal: Applications t",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Application Classes using P2P â€¢ Database systems â€¢ Goal: couple multiple independent databases â€¢ Examples: database replication, distributed query processing, e.g., Bayou â€¢ Content Distribution â€¢ Goal: make content available to users â€¢ Examples: file sharing (Gnutella, Kazaa, etc.), distributed content storage and lookup (Chord, CAN, etc.) â€¢ Main focus of this chapter DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 9,
      "chunk_id": "p9c1",
      "title": "Application Classes using P2P â€¢ Database systems â€¢ Goal: couple multiple independent databases â€¢ Exa",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Discussion â€¢ Why not use servers? â€¢ Communication: SMTP, Videoconference Systems â€¢ Computation: Elastic Cloud Computing â€¢ Databases: pick one out of thousand â€¢ Content distribution: iTunes/AppStore sells everything... â€¢ Is there a benefit in using P2P technology? DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 10,
      "chunk_id": "p10c1",
      "title": "Discussion â€¢ Why not use servers? â€¢ Communication: SMTP, Videoconference Systems â€¢ Computation: Elas",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Organizing Servers on the Internet â€¢ The Internet assume(s|d) computers to â€¢ Be 24/7 online â€¢ Have a fixed IP address â€¢ Thus, they can be managed in registers, such as DNS â€¢ However, this is no longer true â€¢ Mobility: computers roam through different networks â€¢ IPAddress shortage: multiplex IP Adresses (NAT) â€¢ Security: block distinct services DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 11,
      "chunk_id": "p11c1",
      "title": "Organizing Servers on the Internet â€¢ The Internet assume(s|d) computers to â€¢ Be 24/7 online â€¢ Have a",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Main objective of P2P Systems â€¢ Provide an overlay network on top of the Internet â€¢ Overlay: nodes are processes that are connected to each other using the underlying network â€¢ Overlay addresses and management services are provided â€¢ Aim at integration of nodes that join sporadically DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 12,
      "chunk_id": "p12c1",
      "title": "Main objective of P2P Systems â€¢ Provide an overlay network on top of the Internet â€¢ Overlay: nodes a",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Overlay Networks DSM03 â€“ P2P & Naming Overlay Underlay",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 13,
      "chunk_id": "p13c1",
      "title": "Overlay Networks DSM03 â€“ P2P & Naming Overlay Underlay",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Overlay Networks DSM03 â€“ P2P & Naming Overlay Underlay",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 14,
      "chunk_id": "p14c1",
      "title": "Overlay Networks DSM03 â€“ P2P & Naming Overlay Underlay",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Overlay Networks DSM03 â€“ P2P & Naming Overlay Underlay",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 15,
      "chunk_id": "p15c1",
      "title": "Overlay Networks DSM03 â€“ P2P & Naming Overlay Underlay",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Functionality of P2P System â€¢ Join the network â€¢ Connecting nodes need to know at least one other node of the network â€¢ Exchange neighbor information â€¢ Often contains an Overlay address and an Underlay address â€¢ Route messages to a target / neighbor â€¢ Repair for disconnecting nodes â€¢ Disconnect gracefully from network DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 16,
      "chunk_id": "p16c1",
      "title": "Functionality of P2P System â€¢ Join the network â€¢ Connecting nodes need to know at least one other no",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Functionality of P2P Content Distribution Systems DSM03 â€“ P2P & Naming Minimal functionality required â€¢ Insert new content â€¢ Locate (search for) content â€¢ Retrieve content Optional functionality (often harder to achieve) â€¢ Deletion: remove an object (and its copies!) â€¢ Update: apply changes to an existing object â€¢ Expiration: remove objects after a specified time â€¢ Versioning: â€¢ each object is",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 17,
      "chunk_id": "p17c1",
      "title": "Functionality of P2P Content Distribution Systems DSM03 â€“ P2P & Naming Minimal functionality require",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "existing object â€¢ Expiration: remove objects after a specified time â€¢ Versioning: â€¢ each object is readonly (new versions) â€¢ Replace all existing copies",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 17,
      "chunk_id": "p17c2",
      "title": "Functionality of P2P Content Distribution Systems DSM03 â€“ P2P & Naming Minimal functionality require",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Architectural properties: Degree of Centralization â€¢ Centralization in this context: â†’Are there any centralized components necessary to run a given system? â€¢ Various degrees of centralization can be found in systems â€¢ Purely decentralized architectures â€¢ Partially centralized architectures â€¢ Hybrid decentralized architectures DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 18,
      "chunk_id": "p18c1",
      "title": "Architectural properties: Degree of Centralization â€¢ Centralization in this context: â†’Are there any ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Purely Decentralized Architectures â€¢ All nodes perform the same task â€¢ May hinder scalability â€¢ All nodes are in the role of SERVer and cliENT (SERVENT) â€¢ Example: Gnutella 0.4, Chord DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 19,
      "chunk_id": "p19c1",
      "title": "Purely Decentralized Architectures â€¢ All nodes perform the same task â€¢ May hinder scalability â€¢ All ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Partially Centralized Architectures â€¢ Similar to purely decentralized â€¢ However, some nodes are more important â€¢ Notion of socalled supernodes (or superpeers) â€¢ Supernodes: â€¢ Often act as local index â€¢ Provide information about the content stored at local peers â€¢ Are dynamically elected â€¢ Do not constitute a single point of failure DSM03 â€“ P2P & Naming â€normalâ€œ peers supernodes",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 20,
      "chunk_id": "p20c1",
      "title": "Partially Centralized Architectures â€¢ Similar to purely decentralized â€¢ However, some nodes are more",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Hybrid Decentralized Architectures â€¢ Centralized servers exist for some tasks, e.g. â€¢ Maintain user data (access control) â€¢ Maintain directories of metadata about available files â€¢ Exchange of data directly between peers â€¢ Sometimes called â€peerthroughpeerâ€œ or â€broker mediatedâ€œ systems â€¢ Central components constitute single points of failure! DSM03 â€“ P2P & Naming Download of content Server lookup",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 21,
      "chunk_id": "p21c1",
      "title": "Hybrid Decentralized Architectures â€¢ Centralized servers exist for some tasks, e.g. â€¢ Maintain user ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Network Structure â€¢ Overlay network: â€¢ network which is built â€œon topâ€ of another network â€¢ Overlay networks may be created and maintained as: â€¢ Unstructured overlay networks â€¢ Structured overlay networks DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 22,
      "chunk_id": "p22c1",
      "title": "Network Structure â€¢ Overlay network: â€¢ network which is built â€œon topâ€ of another network â€¢ Overlay ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Unstructured Overlays â€¢ Creation of overlay: nondeterministic as nodes and content are added/removed â€¢ Search methods (examples): â€¢ Brute force: query flooding (breadth/depthfirst) â†’High message overhead â€¢ Random walk â†’May not find all items that match â€¢ Usually cope very well with transient node populations â€¢ Insertion and removal of peers is easy â€¢ Examples: Gnutella, Kazaa, FreeHaven DSM03 â€“",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 23,
      "chunk_id": "p23c1",
      "title": "Unstructured Overlays â€¢ Creation of overlay: nondeterministic as nodes and content are added/removed",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "populations â€¢ Insertion and removal of peers is easy â€¢ Examples: Gnutella, Kazaa, FreeHaven DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 23,
      "chunk_id": "p23c2",
      "title": "Unstructured Overlays â€¢ Creation of overlay: nondeterministic as nodes and content are added/removed",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Structured Overlays â€¢ Content placed at precisely specified locations â€¢ Insertion and removal of peers is more complex â€¢ Structure is tightly controlled â†’must be maintained â€¢ Files may have to be migrated on insertion/removal of peers â€¢ Search methods depend on structure (examples): â€¢ Binary search along a ring, e.g., Chord â€¢ Alphanumeric search over multiple rings, e.g., SkipNet, SkABNet â€¢",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 24,
      "chunk_id": "p24c1",
      "title": "Structured Overlays â€¢ Content placed at precisely specified locations â€¢ Insertion and removal of pee",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "along a ring, e.g., Chord â€¢ Alphanumeric search over multiple rings, e.g., SkipNet, SkABNet â€¢ Routing between regions in a Cartesian space, e.g., CAN (Content addressable network) DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 24,
      "chunk_id": "p24c2",
      "title": "Structured Overlays â€¢ Content placed at precisely specified locations â€¢ Insertion and removal of pee",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Agenda â–ªUnstructured Overlays: Gnutella â–ªStructured Overlays: Chord DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 25,
      "chunk_id": "p25c1",
      "title": "Agenda â–ªUnstructured Overlays: Gnutella â–ªStructured Overlays: Chord DSM03 â€“ P2P & Naming",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Unstructured Example: Gnutella â€¢ Application: file sharing â€“ mainly MP3s... but â€¢ Objective: distributed search! â€¢ Gnutella is a protocol â€“ not a product/implementation â€¢ Dates back to March 2000 by Frankel/Pepper â€¢ Initial version stopped â€¢ Open Source â€conqueredâ€œ the development process DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 26,
      "chunk_id": "p26c1",
      "title": "Unstructured Example: Gnutella â€¢ Application: file sharing â€“ mainly MP3s... but â€¢ Objective: distrib",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Gnutella System Model â€¢ P2P â€¢ No explicit client/server roles â€¢ Purely decentralized coordination model â€¢ Unstructured overlay â€¢ Gnutella nodes form a network on top of the Internet (overlay) â€¢ Servents first have to discover a servent part of the Gnutella network (not part of the protocol!) â€¢ Basic operations in the Gnutella network: â€¢ Discovery of further nodes â€¢ Queries DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 27,
      "chunk_id": "p27c1",
      "title": "Gnutella System Model â€¢ P2P â€¢ No explicit client/server roles â€¢ Purely decentralized coordination mo",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Gnutella Protocol: Descriptors â€¢ Ping: discover other hosts; Servents respond with 1 or more Pongs â€¢ Pong: response to Ping; includes address and #files shared â€¢ Query: issued to search the network â€¢ QueryHit: if query is matched in the local data set, servents issue QueryHitmessages with â€enough information to acquire the dataâ€œ â†’Data access is not part of the protocol! â€¢ Push: servents behind",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 28,
      "chunk_id": "p28c1",
      "title": "Gnutella Protocol: Descriptors â€¢ Ping: discover other hosts; Servents respond with 1 or more Pongs â€¢",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "information to acquire the dataâ€œ â†’Data access is not part of the protocol! â€¢ Push: servents behind firewalls likely restrict access to their Gnutella port â†’the requesting servant issues a Push in order to get the Query result send",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 28,
      "chunk_id": "p28c2",
      "title": "Gnutella Protocol: Descriptors â€¢ Ping: discover other hosts; Servents respond with 1 or more Pongs â€¢",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". (cf. active vs. passive FTP) DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 28,
      "chunk_id": "p28c3",
      "title": "Gnutella Protocol: Descriptors â€¢ Ping: discover other hosts; Servents respond with 1 or more Pongs â€¢",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Descriptor Routing â€¢ Descriptors are associated with a TTL (typically: 7) â€¢ Servents send Ping descriptors to others to discover new hosts â€¢ Each servent receiving a Ping â€¢ forwards Ping to servents it knows â€“ as long as TTL > 0 and not to the neighbour issuing the Ping â€¢ returns one or more Pong DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 29,
      "chunk_id": "p29c1",
      "title": "Descriptor Routing â€¢ Descriptors are associated with a TTL (typically: 7) â€¢ Servents send Ping descr",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Descriptor Routing â€¢ Pong returns information about node â€¢ Port and IPAddress â€¢ Number of files shared â€¢ Number of KB shared â€¢ Routed along the Path of corresponding Ping (reverse path) â€¢ Query â€¢ Minimum speed (kb/sec) â€¢ Search criteria â€“ free! not limited to files â€¢ Routing â€“ similar to Pings DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 30,
      "chunk_id": "p30c1",
      "title": "Descriptor Routing â€¢ Pong returns information about node â€¢ Port and IPAddress â€¢ Number of files shar",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Descriptor Routing â€¢ QueryHit â€¢ Response to Query â€¢ Information about the query result and how to access it (IPAddr, Port#, ...) â€¢ Routing â€“ like Pongs â€¢ Push â€¢ Sent along the QueryHit path â€¢ Contains serventâ€™s address (IP, Port) where files should be â€pushed toâ€œ DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 31,
      "chunk_id": "p31c1",
      "title": "Descriptor Routing â€¢ QueryHit â€¢ Response to Query â€¢ Information about the query result and how to ac",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Issues Not Solved by the Protocol â€¢ Discovery of Gnutella network â€¢ How to find the first node to discover the network? 1. manually configure (the old days... Rumours, IRC) 2. host caches â€“ many enter the network at the same place â†’ performance? â€¢ Accessing result â€¢ File sharing: use http DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 32,
      "chunk_id": "p32c1",
      "title": "Issues Not Solved by the Protocol â€¢ Discovery of Gnutella network â€¢ How to find the first node to di",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Performance Issues â€¢ Gnutella protocol is based on flooding â€¢ Gnutella network topology does not reflect â€¢ structure of content providers wrt. content â€¢ structure of content providers wrt. to bandwidth â€¢ Ideally: â€¢ Nodes with high bandwidth/high data volume in the â€centerâ€œ â€¢ But: â€¢ Clients tend to access the network from the same entry points (host caches) DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 33,
      "chunk_id": "p33c1",
      "title": "Performance Issues â€¢ Gnutella protocol is based on flooding â€¢ Gnutella network topology does not ref",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Some Numbers I Percentage of messages (4.9 Millions of messages over 48h): â€¢ Query: 54.80% â€¢ Pong: 26.90% â€¢ Ping: 14.80% â€¢ QueryHit: 2.80% â€¢ Push: 0.70% DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 34,
      "chunk_id": "p34c1",
      "title": "Some Numbers I Percentage of messages (4.9 Millions of messages over 48h): â€¢ Query: 54.80% â€¢ Pong: 2",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Some Numbers II DSM03 â€“ P2P & Naming Average bandwidth usage (kBit/s) per node for Search (S) and Discovery (D) depending on TTL (number of nodes) and frequency: Rate ~500 nodes (TTL=2) ~4000 nodes (TTL=3) ~8000 nodes (TTL=4) 1/h S: 0.04 D: 0.08 S: 0.61 D: 1.10 S: 2.10 D: 3.20 1/min S: 2.50 D: 4.80 S: 36.80 D: 68.20 S: 127.00 D: 194.90 1/s S: 151.00 D: 288.00 S: 2,211.00 D: 4,099.40 S: 7,617.30 D:",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 35,
      "chunk_id": "p35c1",
      "title": "Some Numbers II DSM03 â€“ P2P & Naming Average bandwidth usage (kBit/s) per node for Search (S) and Di",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "36.80 D: 68.20 S: 127.00 D: 194.90 1/s S: 151.00 D: 288.00 S: 2,211.00 D: 4,099.40 S: 7,617.30 D: 11,694.50 Note: default TTL=7! Only costs for Gnutella protocol; not file transfer",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 35,
      "chunk_id": "p35c2",
      "title": "Some Numbers II DSM03 â€“ P2P & Naming Average bandwidth usage (kBit/s) per node for Search (S) and Di",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Freeriding Gnutella â€¢ P2P File sharing based on contribution of all peers â€¢ But: â€¢ 70 % of all users do not share files! â€¢ 50 % of all requests are answered by 1% of hosts â€¢ Freeriders are equally distributed DSM03 â€“ P2P & Naming â€¢ Solutions? â€¢ Caching of files â†’implicit replication â€¢ Incentives: upload/download ratio (in a P2P system?)",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 36,
      "chunk_id": "p36c1",
      "title": "Freeriding Gnutella â€¢ P2P File sharing based on contribution of all peers â€¢ But: â€¢ 70 % of all users",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Gnutella Summary â€¢ Decentralized coordination model â€¢ Unstructured overlay â€¢ Not limited to file transfer â€¢ Flooding based discovery/search imposes scalability problems â€¢ Freeriders dominate â€¢ Organization of network does not reflect sharing/downloading DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 37,
      "chunk_id": "p37c1",
      "title": "Gnutella Summary â€¢ Decentralized coordination model â€¢ Unstructured overlay â€¢ Not limited to file tra",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Peer to Peer Lookup Services â€¢ Gnutellaâ€˜s discovery/search creates heavy load â€¢ General problem: efficient lookup of host which stores a data item â€¢ Dynamics of network changes â€¢ Hosts enter/leave systems â€¢ Decentralized control avoids single points of failures â€¢ Chord â€¢ Protocol for efficient lookup in dynamic peer2peer systems DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 38,
      "chunk_id": "p38c1",
      "title": "Peer to Peer Lookup Services â€¢ Gnutellaâ€˜s discovery/search creates heavy load â€¢ General problem: eff",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Agenda â–ªUnstructured Overlays: Gnutella â–ªStructured Overlays: Chord DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 39,
      "chunk_id": "p39c1",
      "title": "Agenda â–ªUnstructured Overlays: Gnutella â–ªStructured Overlays: Chord DSM03 â€“ P2P & Naming",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Chord Basics â€¢ Basic notations: â€¢ k: key â€¢ n: node from n1...nN â€¢ lookup(k) â†’n : map key to node responsible â€¢ Every node can associate data with a key â€¢ Problems: â€¢ Assignment of keys to nodes â€¢ Distributed knowledge: do all nodes need to know all mappings? DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 40,
      "chunk_id": "p40c1",
      "title": "Chord Basics â€¢ Basic notations: â€¢ k: key â€¢ n: node from n1...nN â€¢ lookup(k) â†’n : map key to node res",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Chord Organisation â€¢ Each key is assigned an id of length m bits â†’hash function â€¢ Hash function ensures equal distribution of keys among N nodes â€¢ Chord ring build from identifier circle modulo 2m: 0..2m1 â€¢ Nodes are integrated into Chord ring by hashing the host IP Address â€¢ Node with nearest id to key (clockwise) maintains it DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 41,
      "chunk_id": "p41c1",
      "title": "Chord Organisation â€¢ Each key is assigned an id of length m bits â†’hash function â€¢ Hash function ensu",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Chord Ring DSM03 â€“ P2P & Naming 10 nodes storing 5 keys Next node clockwise to 10 is 14 N1 N56 N51 N48 N42 N38 N32 N21 N14 N8 K10 K30 K38 K54 K24",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 42,
      "chunk_id": "p42c1",
      "title": "Chord Ring DSM03 â€“ P2P & Naming 10 nodes storing 5 keys Next node clockwise to 10 is 14 N1 N56 N51 N",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Simple Key Location â€¢ Minimal state information on nodes: each node â€knowsâ€œ its direct successor â€¢ Query for identifier ID forwarded until two nodes straddle ID â€¢ Second of these two nodes maintains the information of the ID DSM03 â€“ P2P & Naming n.find_successor(id): //executed on node n if (n < id) && (id <= successor) //(n, successor] straddle id return successor //clockwise node responsible",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 43,
      "chunk_id": "p43c1",
      "title": "Simple Key Location â€¢ Minimal state information on nodes: each node â€knowsâ€œ its direct successor â€¢ Q",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "id) && (id <= successor) //(n, successor] straddle id return successor //clockwise node responsible else return successor.find_successor(id) //go ahead...",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 43,
      "chunk_id": "p43c2",
      "title": "Simple Key Location â€¢ Minimal state information on nodes: each node â€knowsâ€œ its direct successor â€¢ Q",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Simple Key Location â€¢ Minimal state information on nodes: each node â€knowsâ€œ its direct successor â€¢ Query for identifier ID forwarded until two nodes straddle ID â€¢ Second of these two nodes maintains the information of the ID DSM03 â€“ P2P & Naming n.find_successor(id): //executed on node n if (n < id) && (id <= successor) //(n, successor] straddle id return successor //clockwise node responsible",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 44,
      "chunk_id": "p44c1",
      "title": "Simple Key Location â€¢ Minimal state information on nodes: each node â€knowsâ€œ its direct successor â€¢ Q",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "id) && (id <= successor) //(n, successor] straddle id return successor //clockwise node responsible else return successor.find_successor(id) //go ahead...",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 44,
      "chunk_id": "p44c2",
      "title": "Simple Key Location â€¢ Minimal state information on nodes: each node â€knowsâ€œ its direct successor â€¢ Q",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Simple Key Location â€¢ Minimal state information on nodes: each node â€knowsâ€œ its direct successor â€¢ Query for identifier ID forwarded until two nodes straddle ID â€¢ Second of these two nodes maintains the information of the ID DSM03 â€“ P2P & Naming n.find_successor(id): //executed on node n if id âˆˆ (n, successor] //(n, successor] straddle id return successor //clockwise node responsible else return",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 45,
      "chunk_id": "p45c1",
      "title": "Simple Key Location â€¢ Minimal state information on nodes: each node â€knowsâ€œ its direct successor â€¢ Q",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "successor] //(n, successor] straddle id return successor //clockwise node responsible else return successor.find_successor(id) //go ahead...",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 45,
      "chunk_id": "p45c2",
      "title": "Simple Key Location â€¢ Minimal state information on nodes: each node â€knowsâ€œ its direct successor â€¢ Q",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Chord Ring DSM03 â€“ P2P & Naming (n < id) && (id <= successor) K46",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 46,
      "chunk_id": "p46c1",
      "title": "Chord Ring DSM03 â€“ P2P & Naming (n < id) && (id <= successor) K46",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Chord Ring DSM03 â€“ P2P & Naming (n < id) && (id <= successor) K58 (successor < n) && (n <= id) K46",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 47,
      "chunk_id": "p47c1",
      "title": "Chord Ring DSM03 â€“ P2P & Naming (n < id) && (id <= successor) K58 (successor < n) && (n <= id) K46",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Chord Ring DSM03 â€“ P2P & Naming (n < id) && (id <= successor) K58 (successor < n) && (n <= id) K46 K4 (successor < n) && (id <= successor)",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 48,
      "chunk_id": "p48c1",
      "title": "Chord Ring DSM03 â€“ P2P & Naming (n < id) && (id <= successor) K58 (successor < n) && (n <= id) K46 K",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Simple Key Location â€¢ Minimal state information on nodes: each node â€knowsâ€œ its direct successor â€¢ Query for identifier ID forwarded until two nodes straddle ID â€¢ Second of these two nodes maintains the information of the ID DSM03 â€“ P2P & Naming n.find_successor(id): //executed on node n (n < id) && (id <= successor) || (successor < n) && (n <= id) || (successor < n) && (id <= successor) return",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 49,
      "chunk_id": "p49c1",
      "title": "Simple Key Location â€¢ Minimal state information on nodes: each node â€knowsâ€œ its direct successor â€¢ Q",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "&& (id <= successor) || (successor < n) && (n <= id) || (successor < n) && (id <= successor) return successor //clockwise node responsible else return successor.find_successor(id) //go ahead...",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 49,
      "chunk_id": "p49c2",
      "title": "Simple Key Location â€¢ Minimal state information on nodes: each node â€knowsâ€œ its direct successor â€¢ Q",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Chord Ring DSM03 â€“ P2P & Naming Search for K38 starting on node N8 N1 N56 N51 N48 N42 N38 N32 N21 N14 N8 K10 K30 K38 K54 K24 32 < 38 <= 38 â†’ Node 38 is responsible",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 50,
      "chunk_id": "p50c1",
      "title": "Chord Ring DSM03 â€“ P2P & Naming Search for K38 starting on node N8 N1 N56 N51 N48 N42 N38 N32 N21 N1",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Scalable Key Location â€¢ Simple variant: â€¢ has linear search effort O(N) â€¢ Minimal state â€“ only successor O(1) â€¢ Improvement: â€¢ Increase local state DSM03 â€“ P2P & Naming â€¢ Question: â€¢ Search effort when all N nodes are stored at each node? â€¢ Effort when nodes enter/leave network? â€¢ Simple variant â€¢ Variant with N nodes stored locally â€¢ Any compromise? â†’Finger table",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 51,
      "chunk_id": "p51c1",
      "title": "Scalable Key Location â€¢ Simple variant: â€¢ has linear search effort O(N) â€¢ Minimal state â€“ only succe",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Finger Table â€¢ Key length m bits â€¢ Each node maintains a finger table of length m â€¢ ith entry in finger table of node n: â€¢ first node s that succeeds n by (at least) 2i1 on the ring â€¢ s is ith finger of n â€¢ successor of n: 1st finger of n DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 52,
      "chunk_id": "p52c1",
      "title": "Finger Table â€¢ Key length m bits â€¢ Each node maintains a finger table of length m â€¢ ith entry in fin",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Finger TableExample DSM03 â€“ P2P & Naming N1 N56 N51 N48 N42 N38 N32 N21 N8 +1 +2 +4 +8 +16 N14 Finger Table of N8 start node N8 + 1 = N9 N14 N8 + 2 = N10 N14 N8 + 4 = N12 N14 N8 + 8 = N16 N21 N8 + 16 = N24 N32 6 N8 + 32 = N40 N42",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 53,
      "chunk_id": "p53c1",
      "title": "Finger TableExample DSM03 â€“ P2P & Naming N1 N56 N51 N48 N42 N38 N32 N21 N8 +1 +2 +4 +8 +16 N14 Finge",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Improved Search DSM03 â€“ P2P & Naming n.find_successor(id): //executed on node n if id âˆˆ (n, successor] //(n, successor] straddle id return successor //clockwise node responsible else return successor.find_successor(id) //go ahead...",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 54,
      "chunk_id": "p54c1",
      "title": "Improved Search DSM03 â€“ P2P & Naming n.find_successor(id): //executed on node n if id âˆˆ (n, successo",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Improved Search DSM03 â€“ P2P & Naming n.find_successor(id): //executed on node n if id âˆˆ (n, successor] //(n, successor] straddle id return successor //clockwise node responsible else return find_predecessor(id).find_successor(id)",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 55,
      "chunk_id": "p55c1",
      "title": "Improved Search DSM03 â€“ P2P & Naming n.find_successor(id): //executed on node n if id âˆˆ (n, successo",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Improved Search DSM03 â€“ P2P & Naming n.find_successor(id): //executed on node n if id âˆˆ (n, successor] //(n, successor] straddle id return successor //clockwise node responsible else return find_predecessor(id).find_successor(id) n.find_predecessor(id): for i = m downto 1 if finger[i] âˆˆ (n, id) return finger[i] return n",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 56,
      "chunk_id": "p56c1",
      "title": "Improved Search DSM03 â€“ P2P & Naming n.find_successor(id): //executed on node n if id âˆˆ (n, successo",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Finger TableExample DSM03 â€“ P2P & Naming N1 N56 N51 N48 N42 N38 N32 N21 N8 Finger Table of N8 K54 N14 start node N8 + 1 = N9 N14 N8 + 2 = N10 N14 N8 + 4 = N12 N14 N8 + 8 = N16 N21 N8 + 16 = N24 N32 6 N8 + 32 = N40 N42",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 57,
      "chunk_id": "p57c1",
      "title": "Finger TableExample DSM03 â€“ P2P & Naming N1 N56 N51 N48 N42 N38 N32 N21 N8 Finger Table of N8 K54 N1",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Search costs â€¢ Finger table â€¢ (n+2i1) mod 2m; 1<=i<=m â€¢ Each node has next half of the chord ring in finger table â€¢ Higher density of nodes with â€nearerâ€œ ids â€¢ Search â€¢ Each step cuts down search interval by half â†’Search costs? DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 58,
      "chunk_id": "p58c1",
      "title": "Search costs â€¢ Finger table â€¢ (n+2i1) mod 2m; 1<=i<=m â€¢ Each node has next half of the chord ring in",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Node Joins â€¢ Nodes may join (and leave) the Chord ring at any time â€¢ Each node additionally maintains predecessor node â€¢ Task to be done for node join: 1. Initialize predecessor and finger table of new node 2. Update fingers and predecessors of existing nodes 3. Transferring of keys necessary DSM03 â€“ P2P & Naming n.join(nâ€™): n.init_finger_table(nâ€˜) update_others()",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 59,
      "chunk_id": "p59c1",
      "title": "Node Joins â€¢ Nodes may join (and leave) the Chord ring at any time â€¢ Each node additionally maintain",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Initializing Fingers and Predecessor DSM03 â€“ P2P & Naming n.init_finger_table(nâ€™): finger[1].node = nâ€™.find_successor(finger[1].start) successor = finger[1].node predecessor = successor.predecessor successor.predecessor = n predecessor.successor = n for i = 1 to m1 if( finger[i+1].start Ïµ [n, finger[i].node) ) finger[i+1].node = finger[i].node else finger[i+1].node =",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 60,
      "chunk_id": "p60c1",
      "title": "Initializing Fingers and Predecessor DSM03 â€“ P2P & Naming n.init_finger_table(nâ€™): finger[1].node = ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "finger[i+1].start Ïµ [n, finger[i].node) ) finger[i+1].node = finger[i].node else finger[i+1].node = nâ€™.find_successor(finger[i+1].start) start node N8 + 1 = N9 N14 N8 + 2 = N10 N14 N8 + 4 = N12 N14 N8 + 8 = N16 N21 N8 + 16 = N24 N32 6 N8 + 32 = N40 N42 â€startâ€œ can be easily computed",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 60,
      "chunk_id": "p60c2",
      "title": "Initializing Fingers and Predecessor DSM03 â€“ P2P & Naming n.init_finger_table(nâ€™): finger[1].node = ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Updating Fingers of Existing Nodes I â€¢ New node n may replace finger table entry on other node(s) â€¢ NaÃ¯ve approach: announce n to all nodes â†’O(N) â€¢ More efficient: â€¢ Node n must be the ith finger of node p, if â€¢ p precedes n by at least 2i1 and â€¢ the ith finger of p succeeds n DSM03 â€“ P2P & Naming start node N421 = N41 N38 N422 = N40 N38 N424 = N38 N38 N428 = N34 N32 N4216 = N26 N21 N4232 = N10 N8",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 61,
      "chunk_id": "p61c1",
      "title": "Updating Fingers of Existing Nodes I â€¢ New node n may replace finger table entry on other node(s) â€¢ ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "node N421 = N41 N38 N422 = N40 N38 N424 = N38 N38 N428 = N34 N32 N4216 = N26 N21 N4232 = N10 N8 â€reversedâ€œ finger table to better understand which node to update",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 61,
      "chunk_id": "p61c2",
      "title": "Updating Fingers of Existing Nodes I â€¢ New node n may replace finger table entry on other node(s) â€¢ ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Updating Fingers of Existing Nodes II DSM03 â€“ P2P & Naming n.update_others(): //update all nodes that point to n for i = 1 to m p = find_predecessor(n â€“ 2i1) //find last node p whose ith finger might be n p.update_finger_table(n, i) n.update_finger_table(s, i): //s is now the ith finger of node n if( s Ïµ [n, finger[i].node) ) finger[i].node = s p = predecessor //maybe predecessor also needs to be",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 62,
      "chunk_id": "p62c1",
      "title": "Updating Fingers of Existing Nodes II DSM03 â€“ P2P & Naming n.update_others(): //update all nodes tha",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "s Ïµ [n, finger[i].node) ) finger[i].node = s p = predecessor //maybe predecessor also needs to be updated p.update_finger_table(s,i)",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 62,
      "chunk_id": "p62c2",
      "title": "Updating Fingers of Existing Nodes II DSM03 â€“ P2P & Naming n.update_others(): //update all nodes tha",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Updating Fingers of Existing Nodes II DSM03 â€“ P2P & Naming n.update_others(): //update all nodes that point to n for i = 1 to m p = find_predecessor(n â€“ 2i1) //find last node p whose ith finger might be n p.update_finger_table(n, i) n.update_finger_table(s, i): //s is now the ith finger of node n if( s Ïµ [n, finger[i].node) ) finger[i].node = s p = predecessor //maybe predecessor also needs to be",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 63,
      "chunk_id": "p63c1",
      "title": "Updating Fingers of Existing Nodes II DSM03 â€“ P2P & Naming n.update_others(): //update all nodes tha",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "s Ïµ [n, finger[i].node) ) finger[i].node = s p = predecessor //maybe predecessor also needs to be updated p.update_finger_table(s,i) start node N421 = N41 N38 N422 = N40 N38 N424 = N38 N38 N428 = N34 N32 N4216 = N26 N21 N4232 = N10 N8",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 63,
      "chunk_id": "p63c2",
      "title": "Updating Fingers of Existing Nodes II DSM03 â€“ P2P & Naming n.update_others(): //update all nodes tha",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Leaving Nodes â€¢ Assumption: node n leaves the system â€¢ Set n.predecessor.successor = n.successor â€¢ Set n.successor.predecessor = n.predecessor â€¢ Fix finger tables of nodes â€¢ Transfer keys â€¢ Controlled exit â€“ what if errors are happening? DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 64,
      "chunk_id": "p64c1",
      "title": "Leaving Nodes â€¢ Assumption: node n leaves the system â€¢ Set n.predecessor.successor = n.successor â€¢ S",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Chord Summary â€¢ Structured P2P â€¢ Requires global hash function â€¢ Efficient lookup â€¢ Single points of failure (as we learned it) â€¢ how to cope with that â†’ see paper DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 65,
      "chunk_id": "p65c1",
      "title": "Chord Summary â€¢ Structured P2P â€¢ Requires global hash function â€¢ Efficient lookup â€¢ Single points of",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Peer to Peer Lookup Services I â€¢ Gnutellaâ€˜s discovery/search creates heavy load â€¢ General problem: efficient lookup of host which stores a data item â€¢ Dynamics of network changes â€¢ hosts enter/leave systems â€¢ decentralized control avoids single points of failures â€¢ Chord â€¢ Protocol for efficient lookup in dynamic peer2peer systems DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 66,
      "chunk_id": "p66c1",
      "title": "Peer to Peer Lookup Services I â€¢ Gnutellaâ€˜s discovery/search creates heavy load â€¢ General problem: e",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Peer to Peer Lookup Services II â€¢ Chord finds keys efficiently â†’What happens if we donâ€™t know the correct key? â€¢ Chord keys are hashed â€¢ How can we find similar data? â€¢ How can I decide where my data is stored? â€¢ Chord has no replication â†’How can we account for peers dropping out? DSM03 â€“ P2P & Naming",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 67,
      "chunk_id": "p67c1",
      "title": "Peer to Peer Lookup Services II â€¢ Chord finds keys efficiently â†’What happens if we donâ€™t know the co",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Peer to Peer Lookup Services II â€¢ Chord finds keys efficiently â†’What happens if we donâ€™t know the correct key? â€¢ Chord keys are hashed â€¢ How can we find similar data? â€¢ How can I decide where my data is stored? â€¢ Chord has no replication â†’How can we account for peers dropping out? DSM03 â€“ P2P & Naming A Glimpse into Science Background: Locate relevant data streams in a decentralized sensor network",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 68,
      "chunk_id": "p68c1",
      "title": "Peer to Peer Lookup Services II â€¢ Chord finds keys efficiently â†’What happens if we donâ€™t know the co",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Problem: 1. Sensor data is short lived and can not be evenly distributed using hash functions. 2. Data is owned by someone who wants to keep control. 3. Similar data streams should be located close to each other. Solution: Organize peers based on a selfselected attributevaluebased identifier, while keeping log(n) discovery and support ranges, selections and wildcards within the identifier.",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 68,
      "chunk_id": "p68c2",
      "title": "Peer to Peer Lookup Services II â€¢ Chord finds keys efficiently â†’What happens if we donâ€™t know the co",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Name spaces â€¢ Flat names are good for machines, but not very convenient for humans to use. â€¢ Structured names that are composed from simple, humanreadable names. DSM03 â€“ P2P & Naming â€¢ Naming graph: â€¢ A graph in which a leaf node represents a (named) entity. A directory node is an entity that refers to other nodes. â€¢ A directory node contains a table of (node identifier, edge label) pairs",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 69,
      "chunk_id": "p69c1",
      "title": "Name spaces â€¢ Flat names are good for machines, but not very convenient for humans to use. â€¢ Structu",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â€¢ A directory node contains a table of (node identifier, edge label) pairs. A general naming graph with a single root node",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 69,
      "chunk_id": "p69c2",
      "title": "Name spaces â€¢ Flat names are good for machines, but not very convenient for humans to use. â€¢ Structu",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Naming Graphs DSM03 â€“ P2P & Naming â€¢ Root node: no incoming, only outgoing edges. Entry point. Mostly only one. â€¢ Path: N:[label1, label2, label3, â€¦, labeln] â€¢ absolute: starting from the root N: â€¢ relative: otherwise â€¢ Global name: same entity in all contexts â€¢ Local name: depends on the location â€¢ Example: Most file systems A general naming graph with a single root node",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 70,
      "chunk_id": "p70c1",
      "title": "Naming Graphs DSM03 â€“ P2P & Naming â€¢ Root node: no incoming, only outgoing edges. Entry point. Mostl",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Name Resolution DSM03 â€“ P2P & Naming To resolve a name, we need a directory node",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 71,
      "chunk_id": "p71c1",
      "title": "Name Resolution DSM03 â€“ P2P & Naming To resolve a name, we need a directory node. How do we find tha",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". How do we find that (initial) node? Closure mechanism: The mechanism to select the implicit context from which to start name resolution â€¢ www.distributedsystems.net start at a DNS name server â€¢ /home/maarten/mbox start at the local file server â€¢ 0031 20 598 7784 dial a phone number â€¢ 77.167.55.6 route message to a specific IP address",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 71,
      "chunk_id": "p71c2",
      "title": "Name Resolution DSM03 â€“ P2P & Naming To resolve a name, we need a directory node. How do we find tha",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Name Linking DSM03 â€“ P2P & Naming â€¢ Hard link/path name: a name that is resolved by following a specific path in a naming graph from one node to another",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 72,
      "chunk_id": "p72c1",
      "title": "Name Linking DSM03 â€“ P2P & Naming â€¢ Hard link/path name: a name that is resolved by following a spec",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â€¢ Soft link: Allow a node N to contain a name of another node â€¢ First resolve Nâ€™s name (leading to N) â€¢ Read the content of N, yielding name â€¢ Name resolution continues with name One way or the other, we know where and how to start name resolution given name",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 72,
      "chunk_id": "p72c2",
      "title": "Name Linking DSM03 â€“ P2P & Naming â€¢ Hard link/path name: a name that is resolved by following a spec",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mounting DSM03 â€“ P2P & Naming â€¢ Name resolution can also be used to merge different name spaces transparently through mounting â€¢ Foreign name space: the name space that needs to be accessed â€¢ Mount point: the node in the current name space containing the node identifier of the foreign name space â€¢ Mounting point: the node in the foreign name space where to continue name resolution 1) Protocol 2)",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 73,
      "chunk_id": "p73c1",
      "title": "Mounting DSM03 â€“ P2P & Naming â€¢ Name resolution can also be used to merge different name spaces tran",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mounting point: the node in the foreign name space where to continue name resolution 1) Protocol 2) Server 3) Mounting point",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 73,
      "chunk_id": "p73c2",
      "title": "Mounting DSM03 â€“ P2P & Naming â€¢ Name resolution can also be used to merge different name spaces tran",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mounting DSM03 â€“ P2P & Naming â€¢ Name resolution can also be used to merge different name spaces transparently through mounting â€¢ Foreign name space: the name space that needs to be accessed â€¢ Mount point: the node in the current name space containing the node identifier of the foreign name space â€¢ Mounting point: the node in the foreign name space where to continue name resolution 1) Protocol 2)",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 74,
      "chunk_id": "p74c1",
      "title": "Mounting DSM03 â€“ P2P & Naming â€¢ Name resolution can also be used to merge different name spaces tran",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mounting point: the node in the foreign name space where to continue name resolution 1) Protocol 2) Server 3) Mounting point",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 74,
      "chunk_id": "p74c2",
      "title": "Mounting DSM03 â€“ P2P & Naming â€¢ Name resolution can also be used to merge different name spaces tran",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Name Space Implementation DSM03 â€“ P2P & Naming Goal: Distribute the name resolution process as well as name space management across multiple machines, by distributing nodes of the naming graph. Distinguish three levels â€¢ Global level: Consists of the highlevel directory nodes",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 75,
      "chunk_id": "p75c1",
      "title": "Name Space Implementation DSM03 â€“ P2P & Naming Goal: Distribute the name resolution process as well ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Distinguish three levels â€¢ Global level: Consists of the highlevel directory nodes. Main aspect is that these directory nodes have to be jointly managed by different administrations â€¢ Administrational level: Contains midlevel directory nodes that can be grouped in such a way that each group can be assigned to a separate administration",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 75,
      "chunk_id": "p75c2",
      "title": "Name Space Implementation DSM03 â€“ P2P & Naming Goal: Distribute the name resolution process as well ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â€¢ Managerial level: Consists of lowlevel directory nodes within a single administration. Main issue is effectively mapping directory nodes to local name servers.",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 75,
      "chunk_id": "p75c3",
      "title": "Name Space Implementation DSM03 â€“ P2P & Naming Goal: Distribute the name resolution process as well ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Name Space Implementation DSM03 â€“ P2P & Naming Item Global Administrational Managerial Worldwide Organization Department Few Many Vast numbers Seconds Milliseconds Immediate Lazy Immediate Immediate Many None or few None Yes Yes Sometimes 1: Geographical scale 2: # Nodes 3: Responsiveness 4: Update propagation 5: # Replicas 6: Clientside caching?",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 76,
      "chunk_id": "p76c1",
      "title": "Name Space Implementation DSM03 â€“ P2P & Naming Item Global Administrational Managerial Worldwide Org",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Iterative Name Resolution DSM03 â€“ P2P & Naming 1. resolve(dir, [name1,..., nameK ]) sent to Server0 responsible for dir 2. Server0 resolves resolve(dir, name1) â†’ dir1, returning the identification (address) of Server1, which stores dir1. 3. Client sends resolve(dir1, [name2 , ..., nameK ]) to Server1, etc.",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 77,
      "chunk_id": "p77c1",
      "title": "Iterative Name Resolution DSM03 â€“ P2P & Naming 1. resolve(dir, [name1,..., nameK ]) sent to Server0 ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Recursive Name Resolution DSM03 â€“ P2P & Naming 1. resolve(dir, [name1,..., nameK ]) sent to Server0 responsible for dir 2. Server0 resolves resolve(dir, name1) â†’ dir1, and sends 3. resolve(dir1, [name2 , ..., nameK ]) to Server1, which stores dir1. 4. Server0 waits for result from Server1, and returns it to client.",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 78,
      "chunk_id": "p78c1",
      "title": "Recursive Name Resolution DSM03 â€“ P2P & Naming 1. resolve(dir, [name1,..., nameK ]) sent to Server0 ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Example: The Domain Name System (DNS) DSM03 â€“ P2P & Naming â€¢ Hierarchically organized name space with each node having exactly one incoming edge â€¢ edge label = node label. â€¢ domain: a subtree â€¢ domain name: a path name to a domainâ€™s root node.",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 79,
      "chunk_id": "p79c1",
      "title": "Example: The Domain Name System (DNS) DSM03 â€“ P2P & Naming â€¢ Hierarchically organized name space wit",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Modern DNS DSM03 â€“ P2P & Naming The traditional organization of the implementation of DNS The modern organization of DNS 1. Organizations use external DNS resolvers 2. Client applications (browsers) bypass organizational settings and use a DNS of their choice 3. DNShosting is outsourced to thirdparties",
    "metadata": {
      "source": "Lecture_03.pdf",
      "page": 80,
      "chunk_id": "p80c1",
      "title": "Modern DNS DSM03 â€“ P2P & Naming The traditional organization of the implementation of DNS The modern",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Prof. Dr. Janick Edinger Distributed Systems and Middleware 01Introduction",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 1,
      "chunk_id": "p1c1",
      "title": "Prof. Dr. Janick Edinger Distributed Systems and Middleware 01Introduction",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Who are we? DSM01Introduction Philipp Kisters philipp.kisters@uni... Janick Edinger janick.edinger@uni...",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 2,
      "chunk_id": "p2c1",
      "title": "Who are we? DSM01Introduction Philipp Kisters philipp.kisters@uni... Janick Edinger janick.edinger@u",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Organizational DSM01Introduction â–ªThe module consists of two parts â–ªLecture (Tuesday, 12:15 â€“ 13:45, room D220) â–ªExercise (Tuesday, 14:15 â€“ 15:45, room F009) â–ªMaterials, submissions, communication: Git and Mattermost https://git.informatik.unihamburg.de/dos/teaching/dsm_24 â–ªRecommended Literature: â–ªDistributed Systems, Maarten van Steen, Andrew S",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 3,
      "chunk_id": "p3c1",
      "title": "Organizational DSM01Introduction â–ªThe module consists of two parts â–ªLecture (Tuesday, 12:15 â€“ 13:45,",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Tanenbaum, 4th Edition, 2023 â–ªDistributed Systems â€“ Concept and Design, George Coulouris, Jean Dollimore, Tim Kindberg, Gordon Blair, 5th Edition, 2012",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 3,
      "chunk_id": "p3c2",
      "title": "Organizational DSM01Introduction â–ªThe module consists of two parts â–ªLecture (Tuesday, 12:15 â€“ 13:45,",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "DSM01Introduction Week Session Date Lecture Exercise Comment 15. Oct. 24 D220 F009 22. Oct. 24 D220 F009 29. Oct. 24 D220 D220 05. Nov. 24 D220 F009 12. Nov. 24 D220 F009 19. Nov. 24 D220 F009 26. Nov. 24 D220 F009 03. Dec. 24 no class (F009) Exercise on demand 10. Dec. 24 D220 F009 17. Dec. 24 D220 F009 07. Jan. 25 D220 F009 14. Jan. 25 D220 F009 21. Jan. 25 D220 F009 28. Jan. 25 D220 F009 04",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 4,
      "chunk_id": "p4c1",
      "title": "DSM01Introduction Week Session Date Lecture Exercise Comment 15. Oct. 24 D220 F009 22. Oct. 24 D220 ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Jan. 25 D220 F009 14. Jan. 25 D220 F009 21. Jan. 25 D220 F009 28. Jan. 25 D220 F009 04. Feb 25 First Exam ESA B Friday, 09:30 â€“ 11:30 04. Mar 25 Second Exam ESA C Tuesday, 09:30 â€“ 11:30",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 4,
      "chunk_id": "p4c2",
      "title": "DSM01Introduction Week Session Date Lecture Exercise Comment 15. Oct. 24 D220 F009 22. Oct. 24 D220 ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Goal of this course Gain an understanding of the analysis, development, and evaluation of distributed systems. DSM01Introduction",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 5,
      "chunk_id": "p5c1",
      "title": "Goal of this course Gain an understanding of the analysis, development, and evaluation of distribute",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Agenda â–ªIntroduction to Distributed Systems â–ªCategorization of Distributed Systems â–ªRecap: Layered Architectures DSM01Introduction",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 6,
      "chunk_id": "p6c1",
      "title": "Agenda â–ªIntroduction to Distributed Systems â–ªCategorization of Distributed Systems â–ªRecap: Layered A",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Agenda â–ªIntroduction to Distributed Systems â–ªCategorization of Distributed Systems â–ªRecap: Layered Architectures DSM01Introduction",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 7,
      "chunk_id": "p7c1",
      "title": "Agenda â–ªIntroduction to Distributed Systems â–ªCategorization of Distributed Systems â–ªRecap: Layered A",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Centralized Systems == Distributed Systems? Why Distributed Systems? DSM01Introduction",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 8,
      "chunk_id": "p8c1",
      "title": "Centralized Systems == Distributed Systems? Why Distributed Systems? DSM01Introduction",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Centralized Systems == Distributed Systems? Why Distributed Systems? DSM01Introduction logically? physically? DNS is locally centralized but physically highly distributed.",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 9,
      "chunk_id": "p9c1",
      "title": "Centralized Systems == Distributed Systems? Why Distributed Systems? DSM01Introduction logically? ph",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Centralized Systems == Distributed Systems? Why Distributed Systems? DSM01Introduction logically? physically? DNS is locally centralized but physically highly distributed. â€¢ harder to implement â€¢ harder maintain â€¢ harder to make robust",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 10,
      "chunk_id": "p10c1",
      "title": "Centralized Systems == Distributed Systems? Why Distributed Systems? DSM01Introduction logically? ph",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Centralized Systems == Distributed Systems? Why Distributed Systems? DSM01Introduction logically? physically? DNS is locally centralized but physically highly distributed. â€¢ harder to implement â€¢ harder maintain â€¢ harder to make robust concurrency no global clock failures everywhere",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 11,
      "chunk_id": "p11c1",
      "title": "Centralized Systems == Distributed Systems? Why Distributed Systems? DSM01Introduction logically? ph",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Centralized Systems == Distributed Systems? Why Distributed Systems? DSM01Introduction logically? physically? DNS is locally centralized but physically highly distributed",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 12,
      "chunk_id": "p12c1",
      "title": "Centralized Systems == Distributed Systems? Why Distributed Systems? DSM01Introduction logically? ph",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â€¢ harder to implement â€¢ harder maintain â€¢ harder to make robust concurrency no global clock failures everywhere A Glimpse into Science Situation: In online games, dead reckoning is used to predict the path of a person or item between two updates. Problem: It might happen that between these two updates something important happens",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 12,
      "chunk_id": "p12c2",
      "title": "Centralized Systems == Distributed Systems? Why Distributed Systems? DSM01Introduction logically? ph",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Problem: It might happen that between these two updates something important happens. Solution: Every player creates a log of all events and sends these logs as snapshots to all other player. Eventually, everybody has the same information and can agree on a correct state.",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 12,
      "chunk_id": "p12c3",
      "title": "Centralized Systems == Distributed Systems? Why Distributed Systems? DSM01Introduction logically? ph",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Why Distributed Systems? Distributed Systems == Decentralized Systems? DSM01Introduction",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 13,
      "chunk_id": "p13c1",
      "title": "Why Distributed Systems? Distributed Systems == Decentralized Systems? DSM01Introduction",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Why Distributed Systems? Distributed Systems == Decentralized Systems? DSM01Introduction A distributed system is a networked computer system in which processes and resources are sufficiently spread across multiple computers. A decentralized system is a networked computer system in which processes and resources are necessarily spread across multiple computers.",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 14,
      "chunk_id": "p14c1",
      "title": "Why Distributed Systems? Distributed Systems == Decentralized Systems? DSM01Introduction A distribut",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Perspectives on distributed systems â–ªArchitecture: How do components interact and depend on each other? â–ªProcess: What software (server, client, â€¦) is running in the system? â–ªCommunication: How is data exchanged in the system? â–ªCoordination: How do processes agree/synchronize (e.g., lack of global time)? â–ªNaming: How do you identify resources? â–ªConsistency and replication: How to keep services",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 15,
      "chunk_id": "p15c1",
      "title": "Perspectives on distributed systems â–ªArchitecture: How do components interact and depend on each oth",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "time)? â–ªNaming: How do you identify resources? â–ªConsistency and replication: How to keep services available and reliable? â–ªFault tolerance: How to keep a system alive? â–ªSecurity: How to keep a system safe? DSM01Introduction",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 15,
      "chunk_id": "p15c2",
      "title": "Perspectives on distributed systems â–ªArchitecture: How do components interact and depend on each oth",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Properties and Challenges of Distributed Systems DSM01Introduction Resource Sharing Distribution Transparency Openness Scalability Dependability Failure Handling Heterogeneity Concurrency Security QoS",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 16,
      "chunk_id": "p16c1",
      "title": "Properties and Challenges of Distributed Systems DSM01Introduction Resource Sharing Distribution Tra",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "1) Resource Sharing â–ªMake it easy for users and applications to access and share remote resources (storage, data, files, services, network infrastructure, CPU cycles) â–ªExamples: â–ªDistributed Computation (Our research: Tasklets) â–ªPeertoPeer file sharing systems â–ªEvery web application and online collaboration tool â–ªCloud services DSM01Introduction",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 17,
      "chunk_id": "p17c1",
      "title": "1) Resource Sharing â–ªMake it easy for users and applications to access and share remote resources (s",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "2) Distribution Transparency Transparency is the phenomenon by which a distributed system attempts to hide the fact that its processes and resources are physically distributed across multiple computers, possibly separated by large distances",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 18,
      "chunk_id": "p18c1",
      "title": "2) Distribution Transparency Transparency is the phenomenon by which a distributed system attempts t",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Distribution transparency is handled through many different techniques in a layer between applications and operating systems: a middleware layer DSM01Introduction",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 18,
      "chunk_id": "p18c2",
      "title": "2) Distribution Transparency Transparency is the phenomenon by which a distributed system attempts t",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "2) Distribution Transparency DSM01Introduction Transparency Description Access Access local and remote resources using identical operations Location Access resources without knowledge of their actual location Relocation Resources might move within a system without affecting the current operation Migration Hide that a resource may generally move to another location Replication Hide that multiple",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 19,
      "chunk_id": "p19c1",
      "title": "2) Distribution Transparency DSM01Introduction Transparency Description Access Access local and remo",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Hide that a resource may generally move to another location Replication Hide that multiple copies of an resource/object/service exist Concurrency Several processes can operate concurrently using shared resources Failure Complete tasks despite failures of hardware or software components",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 19,
      "chunk_id": "p19c2",
      "title": "2) Distribution Transparency DSM01Introduction Transparency Description Access Access local and remo",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "2) Distribution Transparency DSM01Introduction Transparency Description Access Access local and remote resources using identical operations Location Access resources without knowledge of their actual location Relocation Resources might move within a system without affecting the current operation Migration Hide that a resource may generally move to another location Replication Hide that multiple",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 20,
      "chunk_id": "p20c1",
      "title": "2) Distribution Transparency DSM01Introduction Transparency Description Access Access local and remo",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Hide that a resource may generally move to another location Replication Hide that multiple copies of an resource/object/service exist Concurrency Several processes can operate concurrently using shared resources Failure Complete tasks despite failures of hardware or software components URL NFS DNS GFS/HDFS Email NFS Mobile Phones",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 20,
      "chunk_id": "p20c2",
      "title": "2) Distribution Transparency DSM01Introduction Transparency Description Access Access local and remo",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "2) Distribution Transparency DSM01Introduction Discussion: How much distribution transparency is possible/good? Location Transparency: Minimum Latency: Speed of light (San Francisco â€“ Amsterdam: 35ms) Failure Transparency: Missing network connection cannot be made up for Replication Transparency: Costly to keep all copies uptodate What about locationbased services? And how to distinguish a failing",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 21,
      "chunk_id": "p21c1",
      "title": "2) Distribution Transparency DSM01Introduction Discussion: How much distribution transparency is pos",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "to keep all copies uptodate What about locationbased services? And how to distinguish a failing server from a slow one?",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 21,
      "chunk_id": "p21c2",
      "title": "2) Distribution Transparency DSM01Introduction Discussion: How much distribution transparency is pos",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "3) Openness The openness of a computer system is the characteristic that determines whether the system can be extended and reimplemented in various ways. The system might consist of components from different origins. DSM01Introduction Interoperability: Multiple different implementations of services can coexist. Portability: Services can run on multiple (or all) types of systems",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 22,
      "chunk_id": "p22c1",
      "title": "3) Openness The openness of a computer system is the characteristic that determines whether the syst",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Portability: Services can run on multiple (or all) types of systems. Extensibility: New components can be added, others can be replaced.",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 22,
      "chunk_id": "p22c2",
      "title": "3) Openness The openness of a computer system is the characteristic that determines whether the syst",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "3) Openness How to implement it? â–ªDefine services through interfaces using an Interface Definition Language (IDL). â–ªIDL serves as a languageindependent way to describe the methods, data structures, and interfaces that software components expose for remote interaction. â–ªSeparation between policies (What needs to be done?) from mechanisms (How is something done?). DSM01Introduction",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 23,
      "chunk_id": "p23c1",
      "title": "3) Openness How to implement it? â–ªDefine services through interfaces using an Interface Definition L",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "4) Quality of Service (QoS) Applications have different requirements such as reliability, security and performance",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 24,
      "chunk_id": "p24c1",
      "title": "4) Quality of Service (QoS) Applications have different requirements such as reliability, security a",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªWeb services require responsiveness, i.e., a fast processing of requests â–ªStreaming services use timecritical data that needs to be delivered in high volume and low time â–ªOnline gaming requires low latency and low packet loss Each critical resource must be reserved by the applications that require QoS, and there must be resource managers that provide guarantees. DSM01Introduction",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 24,
      "chunk_id": "p24c2",
      "title": "4) Quality of Service (QoS) Applications have different requirements such as reliability, security a",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "5) Heterogeneity The Internet consists of multiple heterogeneous networks â€“ but provides a homogeneous interface to communicate with all devices: The Internet Protocol (IP)",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 25,
      "chunk_id": "p25c1",
      "title": "5) Heterogeneity The Internet consists of multiple heterogeneous networks â€“ but provides a homogeneo",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". However, there are differences in: DSM01Introduction â–ªHardware â–ªProgramming languages â–ªData representation â–ªAvailability â–ªSecurity mechanisms â–ªLink bandwidth and speed â–ªRegulatory and legal frameworks This is the reason, why middlewares are important!",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 25,
      "chunk_id": "p25c2",
      "title": "5) Heterogeneity The Internet consists of multiple heterogeneous networks â€“ but provides a homogeneo",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "6) Dependability \"A distributed system is one in which the failure of a computer you didn't even know existed can render your own computer unusable.â€œ (Leslie Lamport) DSM01Introduction Availability: probability that the system is operating correctly at any given moment Safety: when the system temporarily fails to operate correctly, no catastrophic event happens Reliability: the property that a",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 26,
      "chunk_id": "p26c1",
      "title": "6) Dependability \"A distributed system is one in which the failure of a computer you didn't even kno",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "fails to operate correctly, no catastrophic event happens Reliability: the property that a system can run continuously without failure Maintainability: the system can be repaired easily and timely",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 26,
      "chunk_id": "p26c2",
      "title": "6) Dependability \"A distributed system is one in which the failure of a computer you didn't even kno",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "6) Dependability DSM01Introduction An important goal of distributed systems is to mask failures, as well as mask the recovery from those failures. This masking is the essence of being able to tolerate faults, i.e., to be fault tolerant. A fault is a potential defect or deviation within a component or process that may lead to a problem but hasn't yet impacted system functionality",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 27,
      "chunk_id": "p27c1",
      "title": "6) Dependability DSM01Introduction An important goal of distributed systems is to mask failures, as ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". An error occurs when a fault manifests itself and leads to an observable, unintended behavior or state within the system, affecting system operation. A failure is the most severe outcome, resulting from one or more errors that render the system unable to perform its intended functions, often requiring recovery or mitigation measures",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 27,
      "chunk_id": "p27c2",
      "title": "6) Dependability DSM01Introduction An important goal of distributed systems is to mask failures, as ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". An unreliable communication channel A lost message A deadlock caused by waiting for the lost message",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 27,
      "chunk_id": "p27c3",
      "title": "6) Dependability DSM01Introduction An important goal of distributed systems is to mask failures, as ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "6) Dependability DSM01Introduction Transient Faults: â–ªOccur briefly and then disappear. â–ªMay resolve by repeating the operation. â–ªFor example, a bird crossing a microwave beam â€“ or a bit being flipped in a message. Intermittent Faults: â–ªOccur, vanish, and reappear sporadically. â–ªIn hardware caused by loose contacts. â–ªChallenging to diagnose and may work when examined",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 28,
      "chunk_id": "p28c1",
      "title": "6) Dependability DSM01Introduction Transient Faults: â–ªOccur briefly and then disappear. â–ªMay resolve",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªIn hardware caused by loose contacts. â–ªChallenging to diagnose and may work when examined. Permanent Faults: â–ªPersist until the faulty component is replaced. â–ªExamples include burntout chips, software bugs, and diskhead crashes.",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 28,
      "chunk_id": "p28c2",
      "title": "6) Dependability DSM01Introduction Transient Faults: â–ªOccur briefly and then disappear. â–ªMay resolve",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "7) Fault Handling Something went wrong. What now? DSM01Introduction Detecting failures: Some failures can be detected. Others cannot. This is not trivial and requires a lot of thoughts. Tolerating failures: Hiding failures does not always make sense. Sometimes they need to be made explicit. Masking failures: Failures in distributed systems are inevitable. However, they can be hidden",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 29,
      "chunk_id": "p29c1",
      "title": "7) Fault Handling Something went wrong. What now? DSM01Introduction Detecting failures: Some failure",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Masking failures: Failures in distributed systems are inevitable. However, they can be hidden. Recovery from failures: Even after a failure the system should be in the correct state. Discussion",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 29,
      "chunk_id": "p29c2",
      "title": "7) Fault Handling Something went wrong. What now? DSM01Introduction Detecting failures: Some failure",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "7) Fault Handling Something went wrong. What now? DSM01Introduction Detecting failures: Some failures can be detected. Others cannot. This is not trivial and requires a lot of thoughts. Tolerating failures: Hiding failures does not always make sense. Sometimes they need to be made explicit. Masking failures: Failures in distributed systems are inevitable. However, they can be hidden",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 30,
      "chunk_id": "p30c1",
      "title": "7) Fault Handling Something went wrong. What now? DSM01Introduction Detecting failures: Some failure",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Masking failures: Failures in distributed systems are inevitable. However, they can be hidden. Recovery from failures: Even after a failure the system should be in the correct state. Discussion A Glimpse into Science Background: In an offloading system, tasks are offloaded to remote enduser devices which might fail at any time. FaultAwareness: The system recognizes faults by missing heartbeats",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 30,
      "chunk_id": "p30c2",
      "title": "7) Fault Handling Something went wrong. What now? DSM01Introduction Detecting failures: Some failure",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". FaultAwareness: The system recognizes faults by missing heartbeats. FaultTolerance: Failures can occur. Task which are abort get reinitiated and executed on another device. FaultAvoidance: Devices are monitored. Their remaining lifetime and success probability gets estimated to select the most reliable devices.",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 30,
      "chunk_id": "p30c3",
      "title": "7) Fault Handling Something went wrong. What now? DSM01Introduction Detecting failures: Some failure",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "8) Scalability Many developers of modern distributed systems easily use the adjective â€œscalableâ€ without making clear in what form their system actually scales",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 31,
      "chunk_id": "p31c1",
      "title": "8) Scalability Many developers of modern distributed systems easily use the adjective â€œscalableâ€ wit",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªSize: Number of users or processes, nodes, memory, users, â€¦ â–ªQuite well solved today: Redundant servers, operating in parallel but independently â–ªGeography: Distance between nodes â–ªLatencies and unreliable communication channels â–ªAdministration: Number of administrative domains (â€œplayersâ€) â–ªPolicies (resource usage, payment, management, security) and humans â–ªSolution: Make endusers collaborate",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 31,
      "chunk_id": "p31c2",
      "title": "8) Scalability Many developers of modern distributed systems easily use the adjective â€œscalableâ€ wit",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "(resource usage, payment, management, security) and humans â–ªSolution: Make endusers collaborate directly (P2P systems) â€“ not administrative entities DSM01Introduction",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 31,
      "chunk_id": "p31c3",
      "title": "8) Scalability Many developers of modern distributed systems easily use the adjective â€œscalableâ€ wit",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "8) Scalability Solutions and Pitfalls: â–ªHiding communication latencies â–ªAsynchronous communication: Avoid blocking requestresponse pattern â–ªMove logic to the client (e.g., as with JavaScript) DSM01Introduction",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 32,
      "chunk_id": "p32c1",
      "title": "8) Scalability Solutions and Pitfalls: â–ªHiding communication latencies â–ªAsynchronous communication: ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "8) Scalability Solutions and Pitfalls: â–ªPartitioning and Distribution â–ªSplitting the problem into smaller parts and spread these parts across multiple resources â–ªExamples are DNS (see right) or WWW â–ªIdea: Looks like a single server but work is handles by millions of individual devices DSM01Introduction",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 33,
      "chunk_id": "p33c1",
      "title": "8) Scalability Solutions and Pitfalls: â–ªPartitioning and Distribution â–ªSplitting the problem into sm",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "8) Scalability Solutions and Pitfalls: â–ªReplication â–ªContrast to distribution: Same task is performed by multiple devices. â–ªGood for load balancing â–ªCaching is one form of replication â€“ and comes with multiple questions attached. â–ªReplication requires consistency â–ªWhat about (parallel) updates? â–ªWhat about availability and, eventually, scalability? DSM01Introduction Discussion",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 34,
      "chunk_id": "p34c1",
      "title": "8) Scalability Solutions and Pitfalls: â–ªReplication â–ªContrast to distribution: Same task is performe",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "9) Concurrency Typically, multiple clients can make use of the same service. â–ªMultiple requests can be served at the same time. â–ªShared objects are altered â€“ sometimes even on different devices â–ªDistributed synchronization is required DSM01Introduction",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 35,
      "chunk_id": "p35c1",
      "title": "9) Concurrency Typically, multiple clients can make use of the same service. â–ªMultiple requests can ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "10) Security A distributed system that is not secure, is not dependable DSM01Introduction Confidentiality: information is disclosed only to authorized parties Integrity: alterations can be made only in an authorized way Authentication: verifying the correctness of a claimed identity Authorization: does an identified entity has proper access rights? Trust: one entity can be assured that another",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 36,
      "chunk_id": "p36c1",
      "title": "10) Security A distributed system that is not secure, is not dependable DSM01Introduction Confidenti",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "does an identified entity has proper access rights? Trust: one entity can be assured that another will perform particular actions according to a specific expectation More about security: Verteilte Systeme und Systemsicherheit (SVS)",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 36,
      "chunk_id": "p36c2",
      "title": "10) Security A distributed system that is not secure, is not dependable DSM01Introduction Confidenti",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Conclusion: Pitfalls There are many false assumptions when developing distributed systems: DSM01Introduction The network is reliable The network is secure The network is homogeneous The topology does not change Latency is zero Bandwidth is infinite Transport cost is zero There is one administrator",
    "metadata": {
      "source": "Lecture_01.pdf",
      "page": 37,
      "chunk_id": "p37c1",
      "title": "Conclusion: Pitfalls There are many false assumptions when developing distributed systems: DSM01Intr",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Prof. Dr. Janick Edinger Distributed Systems and Middleware 02 â€“ Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 1,
      "chunk_id": "p1c1",
      "title": "Prof. Dr. Janick Edinger Distributed Systems and Middleware 02 â€“ Introduction II",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Properties and Challenges of Distributed Systems DSM02Introduction II Resource Sharing Distribution Transparency Openness Scalability Dependability Failure Handling Heterogeneity Concurrency Security QoS",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 2,
      "chunk_id": "p2c1",
      "title": "Properties and Challenges of Distributed Systems DSM02Introduction II Resource Sharing Distribution ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Pitfalls There are many false assumptions when developing distributed systems: DSM02Introduction II The network is reliable The network is secure The network is homogeneous The topology does not change Latency is zero Bandwidth is infinite Transport cost is zero There is one administrator",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 3,
      "chunk_id": "p3c1",
      "title": "Pitfalls There are many false assumptions when developing distributed systems: DSM02Introduction II ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Agenda â–ªIntroduction to Distributed Systems â–ªCategorization of Distributed Systems â–ªRecap: Layered Architectures â–ªPeertoPeer Systems DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 4,
      "chunk_id": "p4c1",
      "title": "Agenda â–ªIntroduction to Distributed Systems â–ªCategorization of Distributed Systems â–ªRecap: Layered A",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "A Coarse Categorization 1. Highperformance distributed computing â–ªGathering a lot of computational power from many devices 2. Distributed information systems â–ªBusiness as usual â€“ transactions and databases 3. Pervasive systems â–ªNodes. Nodes everywhere. DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 5,
      "chunk_id": "p5c1",
      "title": "A Coarse Categorization 1. Highperformance distributed computing â–ªGathering a lot of computational p",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "1. Highperformance distributed computing Cluster Computing: Grid Computing: Desktop Grids: DSM02Introduction II â–ªMultiple interconnected homogeneous computers working together â–ªEnables parallel processing for improved performance â–ªCan range from small clusters to thousands of nodes â–ªDistributed computing model",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 6,
      "chunk_id": "p6c1",
      "title": "1. Highperformance distributed computing Cluster Computing: Grid Computing: Desktop Grids: DSM02Intr",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªUtilizes geographically dispersed and often heterogeneous resources â–ªFacilitates resource sharing and collaboration across organizational boundaries â–ªUtilizes idle processing power of networked personal computers or workstations â–ªAggregates the computational capabilities of many desktop machines â–ªEfficient use of otherwise underutilized resources",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 6,
      "chunk_id": "p6c2",
      "title": "1. Highperformance distributed computing Cluster Computing: Grid Computing: Desktop Grids: DSM02Intr",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "1",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 7,
      "chunk_id": "p7c1",
      "title": "1. Highperformance distributed computing Cloud Computing: Edge Computing: Internet of Things: (IoT) ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Highperformance distributed computing Cloud Computing: Edge Computing: Internet of Things: (IoT) DSM02Introduction II â–ªServiceoriented technology providing ondemand access to computing resources â–ªResources include servers, storage, databases, networking, and software â–ªScalable and costeffective, accessed over the internet â–ªDecentralized computing paradigm â–ªData processing occurs near the data",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 7,
      "chunk_id": "p7c2",
      "title": "1. Highperformance distributed computing Cloud Computing: Edge Computing: Internet of Things: (IoT) ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "accessed over the internet â–ªDecentralized computing paradigm â–ªData processing occurs near the data source or \"edge\" of the network â–ªReduces latency, enhances realtime processing, and suits IoT and mobile applications â–ªNetwork of interconnected physical devices and objects â–ªThese devices collect and exchange data over the internet â–ªEnables automation, data analysis, and smart applications in",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 7,
      "chunk_id": "p7c3",
      "title": "1. Highperformance distributed computing Cloud Computing: Edge Computing: Internet of Things: (IoT) ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "and exchange data over the internet â–ªEnables automation, data analysis, and smart applications in various domains",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 7,
      "chunk_id": "p7c4",
      "title": "1. Highperformance distributed computing Cloud Computing: Edge Computing: Internet of Things: (IoT) ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "The CloudEdge Continuum DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 8,
      "chunk_id": "p8c1",
      "title": "The CloudEdge Continuum DSM02Introduction II",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "2",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 9,
      "chunk_id": "p9c1",
      "title": "2. Distributed Information Systems DSM02Introduction II Situation: â–ªOrganizations dealing with numer",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Distributed Information Systems DSM02Introduction II Situation: â–ªOrganizations dealing with numerous networked applications â–ªInteroperability among these applications is a challenge Basic Approach: â–ªNetworked applications run on servers, serving remote clients â–ªSimplify integration by having clients combine requests for different applications â–ªClients send combined requests, collect responses,",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 9,
      "chunk_id": "p9c2",
      "title": "2. Distributed Information Systems DSM02Introduction II Situation: â–ªOrganizations dealing with numer",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "combine requests for different applications â–ªClients send combined requests, collect responses, and present a coherent result to the user Next Step: â–ªEnable direct communication between applications â–ªThis leads to Enterprise Application Integration (EAI), streamlining communication and data exchange between different applications within an organization",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 9,
      "chunk_id": "p9c3",
      "title": "2. Distributed Information Systems DSM02Introduction II Situation: â–ªOrganizations dealing with numer",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "2. Distributed Information Systems DSM02Introduction II â–ªOften, the data involved in a transaction is distributed across several servers. A TP Monitor is responsible for coordinating the execution of a transaction. It performs a distributed commit. â€¢ Occurs as a single, indivisible action. â€¢ Appears as if it happens all at once. â€¢ Maintains system integrity and correctness",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 10,
      "chunk_id": "p10c1",
      "title": "2. Distributed Information Systems DSM02Introduction II â–ªOften, the data involved in a transaction i",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â€¢ Appears as if it happens all at once. â€¢ Maintains system integrity and correctness. â€¢ Preserves the overall coherence of the system. â€¢ Operates without mutual interference. â€¢ Actions of one process do not disrupt others. â€¢ Committing changes ensures their permanence. â€¢ Data changes persist and are not lost. Atomic Consistent Isolated Durable",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 10,
      "chunk_id": "p10c2",
      "title": "2. Distributed Information Systems DSM02Introduction II â–ªOften, the data involved in a transaction i",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "3. Pervasive Systems DSM02Introduction II â€œThe most profound technologies are those that disappear. They weave themselves into the fabric of everyday life until they are indistinguishable from it.â€ â€“ Mark Weiser â€“ General idea: Computers become part of our daily lives, with no dedicated interfaces, but they are simply there",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 11,
      "chunk_id": "p11c1",
      "title": "3. Pervasive Systems DSM02Introduction II â€œThe most profound technologies are those that disappear. ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". They use sensors and actuators to understand the context and to react on behalf of the user.",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 11,
      "chunk_id": "p11c2",
      "title": "3. Pervasive Systems DSM02Introduction II â€œThe most profound technologies are those that disappear. ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "3. Pervasive Systems DSM02Introduction II 1) Ubiquitous Computing Systems Definition: Ubiquitous computing, also known as pervasive computing, refers to the concept of seamlessly integrating computation into everyday life. Key Characteristics: â–ªContinuous connectivity: Devices are always connected to the internet or a network. â–ªContextawareness: Systems adapt to users' context and needs",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 12,
      "chunk_id": "p12c1",
      "title": "3. Pervasive Systems DSM02Introduction II 1) Ubiquitous Computing Systems Definition: Ubiquitous com",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªContextawareness: Systems adapt to users' context and needs. â–ªSeamless interaction: Users can interact with computing resources effortlessly. Examples: â–ªSmart homes, IoT devices, wearable technology.",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 12,
      "chunk_id": "p12c2",
      "title": "3. Pervasive Systems DSM02Introduction II 1) Ubiquitous Computing Systems Definition: Ubiquitous com",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "3. Pervasive Systems DSM02Introduction II 2) Mobile Computing Systems Definition: Mobile computing involves the use of portable devices that can be used while in motion, providing connectivity and flexibility. Key Characteristics: â–ªMobility: Devices are designed for use on the go. â–ªWireless communication: Mobile devices typically rely on wireless networks",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 13,
      "chunk_id": "p13c1",
      "title": "3. Pervasive Systems DSM02Introduction II 2) Mobile Computing Systems Definition: Mobile computing i",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªWireless communication: Mobile devices typically rely on wireless networks. â–ªPortability: Devices are compact and lightweight. Examples: â–ªSmartphones, tablets, laptops, and GPS devices.",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 13,
      "chunk_id": "p13c2",
      "title": "3. Pervasive Systems DSM02Introduction II 2) Mobile Computing Systems Definition: Mobile computing i",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "3. Pervasive Systems DSM02Introduction II 3) Sensor Networks Definition: Sensor networks are collections of spatially distributed sensors that collaborate to monitor and collect data from the environment. Key Characteristics: â–ªDistributed sensors: Multiple sensors are deployed across an area. â–ªData collection: Sensors continuously gather information",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 14,
      "chunk_id": "p14c1",
      "title": "3. Pervasive Systems DSM02Introduction II 3) Sensor Networks Definition: Sensor networks are collect",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªData collection: Sensors continuously gather information. â–ªNetworked communication: Sensors share data through a network. Examples: â–ªEnvironmental monitoring, industrial automation, healthcare applications.",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 14,
      "chunk_id": "p14c2",
      "title": "3. Pervasive Systems DSM02Introduction II 3) Sensor Networks Definition: Sensor networks are collect",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Agenda â–ªIntroduction to Distributed Systems â–ªCategorization of Distributed Systems â–ªRecap: Layered Architectures â–ªPeertoPeer Systems DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 15,
      "chunk_id": "p15c1",
      "title": "Agenda â–ªIntroduction to Distributed Systems â–ªCategorization of Distributed Systems â–ªRecap: Layered A",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Software Layers in Distributed Systems Computerand NetworkHardware Operating System Middleware Applications Platform â–ªIndependent of the respective platform â–ªBuilds on middleware API â–ªHides platform heterogeneity â–ªProvides uniform API â–ªProvides an interface to the system resources DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 16,
      "chunk_id": "p16c1",
      "title": "Software Layers in Distributed Systems Computerand NetworkHardware Operating System Middleware Appli",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Layered Architectures Problem: The design of communicating systems is a complex task â€¢ Numerous complex functions with different levels of abstraction. â€¢ Interaction of these functions is necessary Solution: Layered Architectures â€¢ Each layer realizes one abstraction level â€¢ The totality of layers is also called protocol stack DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 17,
      "chunk_id": "p17c1",
      "title": "Layered Architectures Problem: The design of communicating systems is a complex task â€¢ Numerous comp",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Layered Architectures Layer k1/k Interface Physical Medium Layer 1 Layer 1 Layer k Layer k Layer k+1 Layer k+1 â€¦ â€¦ Layer k/k+1 Interface Layer k Protocol Layer k+1 Protocol Layer 1 Protocol Layer 1/2 Interface Interfaces: Define which services the lower layer offers to the higher layer Protocols: Communication agreement between two parties of the same layer on different machines DSM02Introduction",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 18,
      "chunk_id": "p18c1",
      "title": "Layered Architectures Layer k1/k Interface Physical Medium Layer 1 Layer 1 Layer k Layer k Layer k+1",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "agreement between two parties of the same layer on different machines DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 18,
      "chunk_id": "p18c2",
      "title": "Layered Architectures Layer k1/k Interface Physical Medium Layer 1 Layer 1 Layer k Layer k Layer k+1",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Two Examples for Layered Architectures OSI Reference Model â–ª Based on a proposal developed by the International Standards Organization (ISO): Standardization of the protocols used in the layers. â–ª OSI = Open Systems Interconnections: connection of open systems â–ª Model with seven layers TCP/IP Reference Model â–ª Architecture of the ARPANET (today Internet)",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 19,
      "chunk_id": "p19c1",
      "title": "Two Examples for Layered Architectures OSI Reference Model â–ª Based on a proposal developed by the In",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ª Originally a model with four layers (actually only an implementation, the model came later...) DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 19,
      "chunk_id": "p19c2",
      "title": "Two Examples for Layered Architectures OSI Reference Model â–ª Based on a proposal developed by the In",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "DSM02Introduction II OSI Reference Model The outer columns represent the two end devices on which an application (e.g. Skype) communicates. The middle two columns represent the routers through which messages are routed on their way from one end device to the other.",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 20,
      "chunk_id": "p20c1",
      "title": "DSM02Introduction II OSI Reference Model The outer columns represent the two end devices on which an",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "DSM02Introduction II Layer Function 1. Physical â€¢ connection of two directly connected stations (pointtopoint) â€¢ transmission & exchange of physical signals 2. Data link â€¢ connection of two stations â€¢ exchange of frames between connected computers â€¢ allows addressing in local networks with the use of MAC addresses â€¢ error handling â€¢ flow control 3",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 21,
      "chunk_id": "p21c1",
      "title": "DSM02Introduction II Layer Function 1. Physical â€¢ connection of two directly connected stations (poi",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Network â€¢ communication between arbitrary stations â€¢ unique global addressing of stations â€¢ routing, exchange of packets â€¢ best effort service Layers in the OSI Model",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 21,
      "chunk_id": "p21c2",
      "title": "DSM02Introduction II Layer Function 1. Physical â€¢ connection of two directly connected stations (poi",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "DSM02Introduction II Layer Function 4. Transport â€¢ communication of processes (open + maintain connections) â€¢ binds applications to a port: addressing of processes (=applications) local to stations â€¢ provides reliability, which ensures that packets are received â€¢ different service types are available to programmers â€’ UDP: connection less, datagram â€’ TCP: connection oriented, reliable, stream 5",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 22,
      "chunk_id": "p22c1",
      "title": "DSM02Introduction II Layer Function 4. Transport â€¢ communication of processes (open + maintain conne",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Session â€¢ manages session state across individual connections, e.g., security associations 6. Presentation â€¢ transforms application data between different local representations (host, language) 7. Application â€¢ manifests the messages and data relevant for the application â€¢ provides protocols interacting with user applications Layers in the OSI Model",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 22,
      "chunk_id": "p22c2",
      "title": "DSM02Introduction II Layer Function 4. Transport â€¢ communication of processes (open + maintain conne",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "TCP/IP Reference Model DSM02Introduction II OSI TCP/IP Example Application Application SMTP, FTP, HTTP, DHCP Presentation Session Transport Transport TCP, UDP Network Internet IP Data Link HosttoNetwork Ethernet, 802.11 (Wifi) Physical",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 23,
      "chunk_id": "p23c1",
      "title": "TCP/IP Reference Model DSM02Introduction II OSI TCP/IP Example Application Application SMTP, FTP, HT",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "How to use Protocol Stacks? DSM02Introduction II TCP Nutzdaten/Payload Paket Payload Frame Payload TCP Header Paket Header Frame Header",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 24,
      "chunk_id": "p24c1",
      "title": "How to use Protocol Stacks? DSM02Introduction II TCP Nutzdaten/Payload Paket Payload Frame Payload T",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "How to use Protocol Stacks? DSM02Introduction II 00 17 95 9A 55 67 00 60 97 D8 EE 48 08 00 45 00 00 30 3A B2 40 00 80 06 4D E7 86 5D XX XX 86 5D XX XX 04 16 00 16 37 8E 51 7B 00 00 00 00 70 02 40 00 43 BB 00 00 02 04 05 B4 01 01 04 02 0A 00 1B 56 95 AA FF 12 ...",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 25,
      "chunk_id": "p25c1",
      "title": "How to use Protocol Stacks? DSM02Introduction II 00 17 95 9A 55 67 00 60 97 D8 EE 48 08 00 45 00 00 ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "How to use Protocol Stacks? DSM02Introduction II Ethernet Header (Layer 2) IP Header (Layer 3) Payload TCP Header (Layer 4) 00 17 95 9A 55 67 00 60 97 D8 EE 48 08 00 45 00 00 30 3A B2 40 00 80 06 4D E7 86 5D XX XX 86 5D XX XX 04 16 00 16 37 8E 51 7B 00 00 00 00 70 02 40 00 43 BB 00 00 02 04 05 B4 01 01 04 02 0A 00 1B 56 95 AA FF 12 ...",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 26,
      "chunk_id": "p26c1",
      "title": "How to use Protocol Stacks? DSM02Introduction II Ethernet Header (Layer 2) IP Header (Layer 3) Paylo",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Internet Protocol Stack (TCP/IP) DSM02Introduction II Netzzugang Internet Protocol User Datagram Protocol DNS, â€¦ Transport Control Protocol HTTP, FTP, â€¦ Application Layer HosttoNetwork Layer Transport Layer Network Layer Unreliable Connectionless Reliable Connectionoriented",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 27,
      "chunk_id": "p27c1",
      "title": "Internet Protocol Stack (TCP/IP) DSM02Introduction II Netzzugang Internet Protocol User Datagram Pro",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Internet Protocol Stack (TCP/IP) DSM02Introduction II Netzzugang Internet Protocol User Datagram Protocol DNS, â€¦ Transport Control Protocol HTTP, FTP, â€¦ Own Protocol Own Protocol Application Layer HosttoNetwork Layer Transport Layer Network Layer Unreliable Connectionless Reliable Connectionoriented",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 28,
      "chunk_id": "p28c1",
      "title": "Internet Protocol Stack (TCP/IP) DSM02Introduction II Netzzugang Internet Protocol User Datagram Pro",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "PeertoPeer Systems peer Etymology: Middle English, from Middle French per, from per, adjective, equal, from Latin par 1 : one that is of equal standing with another : EQUAL; especially : one belonging to the same societal group especially based on age, grade, or status DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 29,
      "chunk_id": "p29c1",
      "title": "PeertoPeer Systems peer Etymology: Middle English, from Middle French per, from per, adjective, equa",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Definitions Various definitions, for example: PeertoPeer is a class of applications that takes advantage of resources [...] available at the edges of the Internet. ... peertopeer nodes must operate outside the DNS and have [...] autonomy from central servers. Clay Shirky DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 30,
      "chunk_id": "p30c1",
      "title": "Definitions Various definitions, for example: PeertoPeer is a class of applications that takes advan",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Definitions Another one: Peertopeer systems are distributed systems consisting of interconnected nodes able to selforganize into network topologies with the purpose of sharing resources [â€¦], capable of adapting to failures and accommodating transient populations of nodes while maintaining acceptable connectivity and performance, without requiring the intermediation or support of a global",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 31,
      "chunk_id": "p31c1",
      "title": "Definitions Another one: Peertopeer systems are distributed systems consisting of interconnected nod",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "connectivity and performance, without requiring the intermediation or support of a global centralized server or authority",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 31,
      "chunk_id": "p31c2",
      "title": "Definitions Another one: Peertopeer systems are distributed systems consisting of interconnected nod",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". AndroutsellisTheotokis and Spinellis DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 31,
      "chunk_id": "p31c3",
      "title": "Definitions Another one: Peertopeer systems are distributed systems consisting of interconnected nod",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "An Ancient Example: The Usenet â€¢ Exchange of messages in newsgroups â€¢ Synchronization between hosts â€¢ Periodically using socalled newsfeeds â€¢ News server are organized in an overlay network â€¢ Forwarding of messages to all interested neighbours â€¢ Prevention of forwarding loops: messages contain a history of visited news servers â€¢ The Usenet is an early (and current) example of a P2P system",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 32,
      "chunk_id": "p32c1",
      "title": "An Ancient Example: The Usenet â€¢ Exchange of messages in newsgroups â€¢ Synchronization between hosts ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "a history of visited news servers â€¢ The Usenet is an early (and current) example of a P2P system DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 32,
      "chunk_id": "p32c2",
      "title": "An Ancient Example: The Usenet â€¢ Exchange of messages in newsgroups â€¢ Synchronization between hosts ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "An Ancient Example: The Usenet â€¢ Exchange of messages in newsgroups â€¢ Synchronization between hosts â€¢ Periodically using socalled newsfeeds â€¢ News server are organized in an overlay network â€¢ Forwarding of messages to all interested neighbours â€¢ Prevention of forwarding loops: messages contain a history of visited news servers â€¢ The Usenet is an early (and current) example of a P2P system",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 33,
      "chunk_id": "p33c1",
      "title": "An Ancient Example: The Usenet â€¢ Exchange of messages in newsgroups â€¢ Synchronization between hosts ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "a history of visited news servers â€¢ The Usenet is an early (and current) example of a P2P system DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 33,
      "chunk_id": "p33c2",
      "title": "An Ancient Example: The Usenet â€¢ Exchange of messages in newsgroups â€¢ Synchronization between hosts ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Application Classes using P2P â€¢ Communication and collaboration between users â€¢ Goal: Applications that enable direct communication between peers â€¢ For example, chat systems based on Jabber, VoIP systems like Skype â€¢ Distributed Computing â€¢ Goal: Sharing of processing power between peers â€¢ Example: Seti@home, genome@home â€¢ Internet Service Support â€¢ Goal: Support of Internet services based on P2P",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 34,
      "chunk_id": "p34c1",
      "title": "Application Classes using P2P â€¢ Communication and collaboration between users â€¢ Goal: Applications t",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Seti@home, genome@home â€¢ Internet Service Support â€¢ Goal: Support of Internet services based on P2P â€¢ Example: P2P multicast systems DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 34,
      "chunk_id": "p34c2",
      "title": "Application Classes using P2P â€¢ Communication and collaboration between users â€¢ Goal: Applications t",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Application Classes using P2P â€¢ Database systems â€¢ Goal: couple multiple independent databases â€¢ Examples: database replication, distributed query processing, e.g., Bayou â€¢ Content Distribution â€¢ Goal: make content available to users â€¢ Examples: file sharing (Gnutella, Kazaa, etc.), distributed content storage and lookup (Chord, CAN, etc.) â€¢ Main focus of this chapter DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 35,
      "chunk_id": "p35c1",
      "title": "Application Classes using P2P â€¢ Database systems â€¢ Goal: couple multiple independent databases â€¢ Exa",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Discussion â€¢ Why not use servers? â€¢ Communication: SMTP, Videoconference Systems â€¢ Computation: Elastic Cloud Computing â€¢ Databases: pick one out of thousand â€¢ Content distribution: iTunes/AppStore sells everything... â€¢ Is there a benefit in using P2P technology? DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 36,
      "chunk_id": "p36c1",
      "title": "Discussion â€¢ Why not use servers? â€¢ Communication: SMTP, Videoconference Systems â€¢ Computation: Elas",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Organizing Servers on the Internet â€¢ The Internet assume(s|d) computers to â€¢ Be 24/7 online â€¢ Have a fixed IP address â€¢ Thus, they can be managed in registers, such as DNS â€¢ However, this is no longer true â€¢ Mobility: computers roam through different networks â€¢ IPAddress shortage: multiplex IP Adresses (NAT) â€¢ Security: block distinct services DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 37,
      "chunk_id": "p37c1",
      "title": "Organizing Servers on the Internet â€¢ The Internet assume(s|d) computers to â€¢ Be 24/7 online â€¢ Have a",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Main objective of P2P Systems â€¢ Provide an overlay network on top of the Internet â€¢ Overlay: nodes are processes that are connected to each other using the underlying network â€¢ Overlay addresses and management services are provided â€¢ Aim at integration of nodes that join sporadically DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 38,
      "chunk_id": "p38c1",
      "title": "Main objective of P2P Systems â€¢ Provide an overlay network on top of the Internet â€¢ Overlay: nodes a",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Overlay Networks DSM02Introduction II Overlay Underlay",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 39,
      "chunk_id": "p39c1",
      "title": "Overlay Networks DSM02Introduction II Overlay Underlay",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Overlay Networks DSM02Introduction II Overlay Underlay",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 40,
      "chunk_id": "p40c1",
      "title": "Overlay Networks DSM02Introduction II Overlay Underlay",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Overlay Networks DSM02Introduction II Overlay Underlay",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 41,
      "chunk_id": "p41c1",
      "title": "Overlay Networks DSM02Introduction II Overlay Underlay",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Functionality of P2P System â€¢ Join the network â€¢ Connecting nodes need to know at least one other node of the network â€¢ Exchange neighbor information â€¢ Often contains an Overlay address and an Underlay address â€¢ Route messages to a target / neighbor â€¢ Repair for disconnecting nodes â€¢ Disconnect gracefully from network DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 42,
      "chunk_id": "p42c1",
      "title": "Functionality of P2P System â€¢ Join the network â€¢ Connecting nodes need to know at least one other no",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Functionality of P2P Content Distribution Systems DSM02Introduction II Minimal functionality required â€¢ Insert new content â€¢ Locate (search for) content â€¢ Retrieve content Optional functionality (often harder to achieve) â€¢ Deletion: remove an object (and its copies!) â€¢ Update: apply changes to an existing object â€¢ Expiration: remove objects after a specified time â€¢ Versioning: â€¢ each object is",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 43,
      "chunk_id": "p43c1",
      "title": "Functionality of P2P Content Distribution Systems DSM02Introduction II Minimal functionality require",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "existing object â€¢ Expiration: remove objects after a specified time â€¢ Versioning: â€¢ each object is readonly (new versions) â€¢ Replace all existing copies",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 43,
      "chunk_id": "p43c2",
      "title": "Functionality of P2P Content Distribution Systems DSM02Introduction II Minimal functionality require",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Architectural properties: Degree of Centralization â€¢ Centralization in this context: â†’Are there any centralized components necessary to run a given system? â€¢ Various degrees of centralization can be found in systems â€¢ Purely decentralized architectures â€¢ Partially centralized architectures â€¢ Hybrid decentralized architectures DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 44,
      "chunk_id": "p44c1",
      "title": "Architectural properties: Degree of Centralization â€¢ Centralization in this context: â†’Are there any ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Purely Decentralized Architectures â€¢ All nodes perform the same task â€¢ May hinder scalability â€¢ All nodes are in the role of SERVer and cliENT (SERVENT) â€¢ Example: Gnutella 0.4, Chord DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 45,
      "chunk_id": "p45c1",
      "title": "Purely Decentralized Architectures â€¢ All nodes perform the same task â€¢ May hinder scalability â€¢ All ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Partially Centralized Architectures â€¢ Similar to purely decentralized â€¢ However, some nodes are more important â€¢ Notion of socalled supernodes (or superpeers) â€¢ Supernodes: â€¢ Often act as local index â€¢ Provide information about the content stored at local peers â€¢ Are dynamically elected â€¢ Do not constitute a single point of failure DSM02Introduction II â€normalâ€œ peers supernodes",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 46,
      "chunk_id": "p46c1",
      "title": "Partially Centralized Architectures â€¢ Similar to purely decentralized â€¢ However, some nodes are more",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Hybrid Decentralized Architectures â€¢ Centralized servers exist for some tasks, e.g. â€¢ Maintain user data (access control) â€¢ Maintain directories of metadata about available files â€¢ Exchange of data directly between peers â€¢ Sometimes called â€peerthroughpeerâ€œ or â€broker mediatedâ€œ systems â€¢ Central components constitute single points of failure! DSM02Introduction II Download of content Server lookup",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 47,
      "chunk_id": "p47c1",
      "title": "Hybrid Decentralized Architectures â€¢ Centralized servers exist for some tasks, e.g. â€¢ Maintain user ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Network Structure â€¢ Overlay network: â€¢ network which is built â€œon topâ€ of another network â€¢ Overlay networks may be created and maintained as: â€¢ Unstructured overlay networks â€¢ Structured overlay networks DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 48,
      "chunk_id": "p48c1",
      "title": "Network Structure â€¢ Overlay network: â€¢ network which is built â€œon topâ€ of another network â€¢ Overlay ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Unstructured Overlays â€¢ Creation of overlay: nondeterministic as nodes and content are added/removed â€¢ Search methods (examples): â€¢ Brute force: query flooding (breadth/depthfirst) â†’High message overhead â€¢ Random walk â†’May not find all items that match â€¢ Usually cope very well with transient node populations â€¢ Insertion and removal of peers is easy â€¢ Examples: Gnutella, Kazaa, FreeHaven",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 49,
      "chunk_id": "p49c1",
      "title": "Unstructured Overlays â€¢ Creation of overlay: nondeterministic as nodes and content are added/removed",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "node populations â€¢ Insertion and removal of peers is easy â€¢ Examples: Gnutella, Kazaa, FreeHaven DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 49,
      "chunk_id": "p49c2",
      "title": "Unstructured Overlays â€¢ Creation of overlay: nondeterministic as nodes and content are added/removed",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Structured Overlays â€¢ Content placed at precisely specified locations â€¢ Insertion and removal of peers is more complex â€¢ Structure is tightly controlled â†’must be maintained â€¢ Files may have to be migrated on insertion/removal of peers â€¢ Search methods depend on used structure (examples): â€¢ Binary search along a ring, e.g., Chord â€¢ Alphanumeric search over multiple rings, e.g., SkipNet, SkABNet â€¢",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 50,
      "chunk_id": "p50c1",
      "title": "Structured Overlays â€¢ Content placed at precisely specified locations â€¢ Insertion and removal of pee",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "along a ring, e.g., Chord â€¢ Alphanumeric search over multiple rings, e.g., SkipNet, SkABNet â€¢ Routing between regions in a Cartesian space, e.g., CAN (Content addressable network) DSM02Introduction II",
    "metadata": {
      "source": "Lecture_02.pdf",
      "page": 50,
      "chunk_id": "p50c2",
      "title": "Structured Overlays â€¢ Content placed at precisely specified locations â€¢ Insertion and removal of pee",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Prof. Dr. Janick Edinger Distributed Systems and Middleware 08 â€“ Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 1,
      "chunk_id": "p1c1",
      "title": "Prof. Dr. Janick Edinger Distributed Systems and Middleware 08 â€“ Middleware",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Agenda â–ªMiddleware Technologies â–ªRPC â–ªCORBA â–ªJava RMI â–ªSOAP â–ªREST â–ªgRPC â–ªOur reasearch in Middleware: Tasklets DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 2,
      "chunk_id": "p2c1",
      "title": "Agenda â–ªMiddleware Technologies â–ªRPC â–ªCORBA â–ªJava RMI â–ªSOAP â–ªREST â–ªgRPC â–ªOur reasearch in Middleware",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Middleware Middleware facilitates and manages the interaction between applications across heterogeneous computing platforms. It is the architectural solution to the problem of integrating a collection of servers and applications under a common service interface",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 3,
      "chunk_id": "p3c1",
      "title": "Middleware Middleware facilitates and manages the interaction between applications across heterogene",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Abstraction is a key concept in making software development easier for software developers Programming abstractions can â–ªhide hardware/platform details â–ªprovide powerful building blocks â–ªreduce programming errors â–ªoffload difficult tasks to other services â–ªreduce development and maintenance costs DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 3,
      "chunk_id": "p3c2",
      "title": "Middleware Middleware facilitates and manages the interaction between applications across heterogene",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Middleware â€œMiddleware is a layer of software above the operating system which provides higherlevel building blocks for programmers. In doing so, it helps make them more productive and helps to mask the complexities and heterogenous nature that is inherent in distributed systems.â€ David E",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 4,
      "chunk_id": "p4c1",
      "title": "Middleware â€œMiddleware is a layer of software above the operating system which provides higherlevel ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Bakken Middleware can be seen as a set of programming abstractions that make it easier to develop complex distributed systems. DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 4,
      "chunk_id": "p4c2",
      "title": "Middleware â€œMiddleware is a layer of software above the operating system which provides higherlevel ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "MessageOriented Middleware (MOM) â–ªProvide interoperability via messages: a structured data set typically characterized by a type and a set of attributevalue pairs â–ªComponents in a MOM will then publish certain messages while subscribing to other messages; components will often be both clients AND servers depending on the messages they understand Aim at highlevel persistent asynchronous",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 5,
      "chunk_id": "p5c1",
      "title": "MessageOriented Middleware (MOM) â–ªProvide interoperability via messages: a structured data set typic",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "AND servers depending on the messages they understand Aim at highlevel persistent asynchronous communication: â–ªProcesses send each other messages, which are queued â–ªSender need not wait for immediate reply, but can do other things â–ªMiddleware often ensures fault tolerance DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 5,
      "chunk_id": "p5c2",
      "title": "MessageOriented Middleware (MOM) â–ªProvide interoperability via messages: a structured data set typic",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "History of Middleware/Inter Process Communication DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 6,
      "chunk_id": "p6c1",
      "title": "History of Middleware/Inter Process Communication DSM08Middleware",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Classification of Inter Process Communication Technologies DSM08Middleware Hamed Dinari (2020). InterProcess Communication (IPC) in Distributed Environments: An Investigation and Performance Analysis of Some Middleware Technologies. International Journal of Modern Education & Computer Science",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 7,
      "chunk_id": "p7c1",
      "title": "Classification of Inter Process Communication Technologies DSM08Middleware Hamed Dinari (2020). Inte",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Remote Procedure Calls â–ªDefinition: A protocol that allows a program to cause a procedure (subroutine) to execute in another address space (commonly on another machine). â–ªFacilitates communication between distributed systems",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 8,
      "chunk_id": "p8c1",
      "title": "Remote Procedure Calls â–ªDefinition: A protocol that allows a program to cause a procedure (subroutin",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªFacilitates communication between distributed systems. â–ªApplication developers are familiar with simple procedure model â–ªWellengineered procedures operate in isolation (black box) â–ªThere is no fundamental reason not to execute procedures on separate machine â–ªCommunication between caller & callee can be hidden by using procedurecall mechanism. DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 8,
      "chunk_id": "p8c2",
      "title": "Remote Procedure Calls â–ªDefinition: A protocol that allows a program to cause a procedure (subroutin",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Remote Procedure Calls DSM08Middleware ACM Transactions on Computer Systems (TOCS), 1984",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 9,
      "chunk_id": "p9c1",
      "title": "Remote Procedure Calls DSM08Middleware ACM Transactions on Computer Systems (TOCS), 1984",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Remote Procedure Calls DSM08Middleware ACM Transactions on Computer Systems (TOCS), 1984",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 10,
      "chunk_id": "p10c1",
      "title": "Remote Procedure Calls DSM08Middleware ACM Transactions on Computer Systems (TOCS), 1984",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Remote Procedure Calls DSM08Middleware M. van Steen and A.S. Tanenbaum, Distributed Systems, 4th ed., distributedsystems.net, 2023. 1. Client procedure calls client stub. 2. Stub builds message; calls local OS. 3. OS sends message to remote OS. 4. Remote OS gives message to stub. 5. Stub unpacks parameters; calls server. 6. Server does local call; returns result to stub. 7",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 11,
      "chunk_id": "p11c1",
      "title": "Remote Procedure Calls DSM08Middleware M. van Steen and A.S. Tanenbaum, Distributed Systems, 4th ed.",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". 5. Stub unpacks parameters; calls server. 6. Server does local call; returns result to stub. 7. Stub builds message; calls OS. 8. OS sends message to clientâ€™s OS. 9. Clientâ€™s OS gives message to stub. 10. Client stub unpacks result; returns to client.",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 11,
      "chunk_id": "p11c2",
      "title": "Remote Procedure Calls DSM08Middleware M. van Steen and A.S. Tanenbaum, Distributed Systems, 4th ed.",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Stubs and Skeletons DSM08Middleware A stub for a remote object is the clientside proxy for the remote object. Such a stub implements all the interfaces that are supported by the remote object implementation. A clientside stub is responsible for: â–ª Initiating a call to the remote object â–ª Marshaling arguments to a stream â–ª Informing the remote reference layer that the call should be invoked",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 12,
      "chunk_id": "p12c1",
      "title": "Stubs and Skeletons DSM08Middleware A stub for a remote object is the clientside proxy for the remot",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ª Unmarshaling the return value or exception from a stream. â–ª Informing the remote reference layer that the call is complete. Application Stub RPC Library Transport Application Skeleton RPC Library Transport RPC TCP /IP Client Server",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 12,
      "chunk_id": "p12c2",
      "title": "Stubs and Skeletons DSM08Middleware A stub for a remote object is the clientside proxy for the remot",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Stubs and Skeletons DSM08Middleware A skeleton for a remote object is a serverside entity that contains a method which dispatches calls to the actual remote object implementation. The skeleton is responsible for: â–ª Unmarshaling arguments from the stream. â–ª Making the upcall to the actual remote object implementation",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 13,
      "chunk_id": "p13c1",
      "title": "Stubs and Skeletons DSM08Middleware A skeleton for a remote object is a serverside entity that conta",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ª Making the upcall to the actual remote object implementation. â–ª Marshaling the return value of the call or an exception (if one occurred) onto the stream. Application Stub RPC Library Transport Application Skeleton RPC Library Transport RPC TCP /IP Client Server",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 13,
      "chunk_id": "p13c2",
      "title": "Stubs and Skeletons DSM08Middleware A skeleton for a remote object is a serverside entity that conta",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "IDL â€“ Interface Definition Language DSM08Middleware IDL is a languageagnostic abstraction used to define interfaces between software components. It allows developers to describe the methods and data structures without being tied to a specific programming language.",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 14,
      "chunk_id": "p14c1",
      "title": "IDL â€“ Interface Definition Language DSM08Middleware IDL is a languageagnostic abstraction used to de",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "RPC: Parameter passing â–ªThereâ€™s more than just wrapping parameters into a message â–ªClient and server machines may have different data representations (think of byte ordering) â–ªWrapping a parameter means transforming a value into a sequence of bytes â–ªClient and server have to agree on the same encoding: â–ªHow are basic data values represented (integers, floats, characters) â–ªHow are complex data",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 15,
      "chunk_id": "p15c1",
      "title": "RPC: Parameter passing â–ªThereâ€™s more than just wrapping parameters into a message â–ªClient and server",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "â–ªHow are basic data values represented (integers, floats, characters) â–ªHow are complex data values represented (arrays, unions) â–ªConclusion: Client and server need to properly interpret messages, transforming them into machinedependent representations",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 15,
      "chunk_id": "p15c2",
      "title": "RPC: Parameter passing â–ªThereâ€™s more than just wrapping parameters into a message â–ªClient and server",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 15,
      "chunk_id": "p15c3",
      "title": "RPC: Parameter passing â–ªThereâ€™s more than just wrapping parameters into a message â–ªClient and server",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "RPC: Parameter passing â–ªCopy in/copy out semantics: while procedure is executed, nothing can be assumed about parameter values. â–ªAll data that is to be operated on is passed by parameters. Excludes passing references to (global) data. â–ªConclusion: Full access transparency cannot be realized",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 16,
      "chunk_id": "p16c1",
      "title": "RPC: Parameter passing â–ªCopy in/copy out semantics: while procedure is executed, nothing can be assu",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªConclusion: Full access transparency cannot be realized. A remote reference mechanism enhances access transparency â–ªRemote reference offers unified access to remote data â–ªRemote references can be passed as parameter in RPCs DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 16,
      "chunk_id": "p16c2",
      "title": "RPC: Parameter passing â–ªCopy in/copy out semantics: while procedure is executed, nothing can be assu",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "CORBA DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 17,
      "chunk_id": "p17c1",
      "title": "CORBA DSM08Middleware",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "OMGObject Management Group â–ªEstablished 1989 (11 members) â–ªSpecification of middleware (initially) â–ªToday â–ªOver 800 members â–ªSpecifications of middleware, modeling languages (UML), Business Process Management Plus (BPM+) and much more â–ªHosts four technical meetings per year for its members and interested nonmembers â–ªTechnology adoption only after reference implementation â–ªBut: OMG publishes only",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 18,
      "chunk_id": "p18c1",
      "title": "OMGObject Management Group â–ªEstablished 1989 (11 members) â–ªSpecification of middleware (initially) â–ª",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "nonmembers â–ªTechnology adoption only after reference implementation â–ªBut: OMG publishes only specifications, no reference implementation DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 18,
      "chunk_id": "p18c2",
      "title": "OMGObject Management Group â–ªEstablished 1989 (11 members) â–ªSpecification of middleware (initially) â–ª",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "CORBACommon Object Request Broker Architecture â–ªMiddleware Standard: Enabling communication and collaboration between objects in a distributed computing environment. â–ªLanguage Independence: Allows objects written in different programming languages to seamlessly interact, promoting interoperability and flexibility",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 19,
      "chunk_id": "p19c1",
      "title": "CORBACommon Object Request Broker Architecture â–ªMiddleware Standard: Enabling communication and coll",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªObject Request Broker (ORB): functions as an intermediary, managing communication between distributed objects by handling method invocations and providing a seamless abstraction. DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 19,
      "chunk_id": "p19c2",
      "title": "CORBACommon Object Request Broker Architecture â–ªMiddleware Standard: Enabling communication and coll",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "CORBA â€“ Object Request Broker (ORB) â–ªFacilitates communication between distributed objects. â–ªCreates and manages remote object references for clients. â–ªDispatches remote method invocations (RMIs) to the appropriate object implementation. â–ªSupports naming services for object lookup. â–ªHandles marshalling and unmarshalling of data for network transmission. â–ªImplements distributed garbage collection",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 20,
      "chunk_id": "p20c1",
      "title": "CORBA â€“ Object Request Broker (ORB) â–ªFacilitates communication between distributed objects. â–ªCreates",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªImplements distributed garbage collection. â–ªEnsures interoperability between objects developed in different programming languages. â–ªManages communication protocols for effective network communication. DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 20,
      "chunk_id": "p20c2",
      "title": "CORBA â€“ Object Request Broker (ORB) â–ªFacilitates communication between distributed objects. â–ªCreates",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "CORBAObject Adapters â–ªObject adapters bridge CORBA objects and servant classes. â–ªTasks include creating remote object references and dispatching RMIs. â–ªManage servant activation and deactivation. â–ªAssign unique object names to CORBA objects. â–ªMaintain a remote object table mapping object names to servants. â–ªHave their own names integrated into remote object references for managed objects",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 21,
      "chunk_id": "p21c1",
      "title": "CORBAObject Adapters â–ªObject adapters bridge CORBA objects and servant classes. â–ªTasks include creat",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªHave their own names integrated into remote object references for managed objects. DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 21,
      "chunk_id": "p21c2",
      "title": "CORBAObject Adapters â–ªObject adapters bridge CORBA objects and servant classes. â–ªTasks include creat",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "IDLCompiler â–ªIDLCompiler translates interface description into â–ªGeneral templates â–ªClientspecific templates â–ªServicespecific templates â–ªClient Implementor â–ªImplements functionality under use of the service via stubs â–ªService Implementor â–ªCompletes the template (skeleton) of the service DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 22,
      "chunk_id": "p22c1",
      "title": "IDLCompiler â–ªIDLCompiler translates interface description into â–ªGeneral templates â–ªClientspecific te",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "IDL in CORBA module HelloApp { interface Hello { string sayHello(); oneway void shutdown(); }; }; DSM08Middleware IDL compiler",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 23,
      "chunk_id": "p23c1",
      "title": "IDL in CORBA module HelloApp { interface Hello { string sayHello(); oneway void shutdown(); }; }; DS",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Java RMI DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 24,
      "chunk_id": "p24c1",
      "title": "Java RMI DSM08Middleware",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Java RMI â–ªRemote Method Invocation (RMI) is Javaâ€™s implementation of objecttoobject communication among Java objects to realize a distributed computing model. â–ªRMI allows us to distribute our objects on various machines, and invoke methods on the objects located on remote sites. â–ªOnce the object (or service) is registered, a client can look up that service",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 25,
      "chunk_id": "p25c1",
      "title": "Java RMI â–ªRemote Method Invocation (RMI) is Javaâ€™s implementation of objecttoobject communication am",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªOnce the object (or service) is registered, a client can look up that service. â–ªA client (application) receives a reference that allows the client to use the service (call the method). â–ªSyntax of calling is identical to a call to a method of another object in the same program. DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 25,
      "chunk_id": "p25c2",
      "title": "Java RMI â–ªRemote Method Invocation (RMI) is Javaâ€™s implementation of objecttoobject communication am",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Java RMI â€“ Specification Goals â–ªSupport seamless remote invocations on objects in different JVMs. â–ªSupport callbacks from servers to clients. â–ªIntegrate the distributed object model into the Java programming language in a natural way while retaining most of the language's object semantics. â–ªMake writing distributed applications as simple as possible (certainly simpler than with sockets)",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 26,
      "chunk_id": "p26c1",
      "title": "Java RMI â€“ Specification Goals â–ªSupport seamless remote invocations on objects in different JVMs. â–ªS",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªMake writing distributed applications as simple as possible (certainly simpler than with sockets). â–ªPreserve the safety provided by the Java runtime environment. â–ªFlexibility and extensibility are provided by: â–ªDistributed garbage collection â–ªCapability to support multiple transports â–ªVarying remote invocation mechanisms, such as unicast and multicast DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 26,
      "chunk_id": "p26c2",
      "title": "Java RMI â€“ Specification Goals â–ªSupport seamless remote invocations on objects in different JVMs. â–ªS",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Java RMI â€“ Tasks â–ªLocate Remote Objects: Application can obtain references to remote objects when â–ªa) objects are registered with the RMI naming facility, the rmiregistry, â–ªb) application can pass and return remote object references as part of its normal operation â–ªCommunicate with remote objects: handled by RMI; looks like standard Java method invocation to the programmer â–ªLoad class bytecodes",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 27,
      "chunk_id": "p27c1",
      "title": "Java RMI â€“ Tasks â–ªLocate Remote Objects: Application can obtain references to remote objects when â–ªa",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "handled by RMI; looks like standard Java method invocation to the programmer â–ªLoad class bytecodes for objects that are passed as parameters or return values: Because RMI allows a caller to pass pure Java objects to remote object, RMI provides the necessary mechanisms for loading an object's code as well as transmitting its data DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 27,
      "chunk_id": "p27c2",
      "title": "Java RMI â€“ Tasks â–ªLocate Remote Objects: Application can obtain references to remote objects when â–ªa",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Java RMI â€“ Architecture DSM08Middleware Server Skeleton Client Stub Remote Reference Layer Transport Layer Application Presentation Session Transport OSI Model The layers are independent. Each layer is defined by specific protocol and built using specific interface. Any layer can be replaced by an alternate implementation without affecting the others, e.g",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 28,
      "chunk_id": "p28c1",
      "title": "Java RMI â€“ Architecture DSM08Middleware Server Skeleton Client Stub Remote Reference Layer Transport",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Any layer can be replaced by an alternate implementation without affecting the others, e.g. the standard transport layer in RMI is TCP based, but can be substituted by a UDP based transport layer",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 28,
      "chunk_id": "p28c2",
      "title": "Java RMI â€“ Architecture DSM08Middleware Server Skeleton Client Stub Remote Reference Layer Transport",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Java RMI â€“ Serialization â–ªWhen a client code invokes a remote method on a remote object, it actually calls an ordinary/local Java method encapsulated in the stub. â–ªThe stub encodes the parameters used in the remote method with a deviceindependent encoding and transforms them in a format suitable for transport",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 29,
      "chunk_id": "p29c1",
      "title": "Java RMI â€“ Serialization â–ªWhen a client code invokes a remote method on a remote object, it actually",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". The process of encoding, writing to a stream and sending an object is referred as parameter marshalling. â–ªThus the stub method on the client side builds an information block that consists of: â–ªIdentifier of remote object to be used; â–ªName of the method to be called â–ªMarshalled parameters. â–ªThe reverse process of receiving, reading and decoding is called parameter unmarshalling. DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 29,
      "chunk_id": "p29c2",
      "title": "Java RMI â€“ Serialization â–ªWhen a client code invokes a remote method on a remote object, it actually",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Java RMI â€“ Minimal Example DSM08Middleware import java.rmi.Remote; import java.rmi.RemoteException; public interface Hello extends Remote { String sayHello() throws RemoteException; } Hello.java",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 30,
      "chunk_id": "p30c1",
      "title": "Java RMI â€“ Minimal Example DSM08Middleware import java.rmi.Remote; import java.rmi.RemoteException; ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Java RMI â€“ Minimal Example DSM08Middleware public class Client { private Client() {} public static void main(String[] args) { String host = (args.length < 1) ? null : args[0]; try { Registry registry = LocateRegistry.getRegistry(host); Hello stub = (Hello) registry.lookup(\"Hello\"); String response = stub.sayHello(); System.out.println(\"response: \" + response); } catch (Exception e) {",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 31,
      "chunk_id": "p31c1",
      "title": "Java RMI â€“ Minimal Example DSM08Middleware public class Client { private Client() {} public static v",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "response = stub.sayHello(); System.out.println(\"response: \" + response); } catch (Exception e) { System.err.println(\"Client exception: \" + e.toString()); e.printStackTrace(); } } } Client.java",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 31,
      "chunk_id": "p31c2",
      "title": "Java RMI â€“ Minimal Example DSM08Middleware public class Client { private Client() {} public static v",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Java RMI â€“ Minimal Example DSM08Middleware public class Server implements Hello { public Server() {} public String sayHello() { return \"Hello, world!\"; } public static void main(String args[]) { try { Server obj = new Server(); Hello stub = (Hello) UnicastRemoteObject.exportObject(obj, 0); Registry registry = LocateRegistry.createRegistry(1099); registry.bind(\"Hello\", stub);",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 32,
      "chunk_id": "p32c1",
      "title": "Java RMI â€“ Minimal Example DSM08Middleware public class Server implements Hello { public Server() {}",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "0); Registry registry = LocateRegistry.createRegistry(1099); registry.bind(\"Hello\", stub); System.err.println(\"Server ready\"); } catch (Exception e) { ..",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 32,
      "chunk_id": "p32c2",
      "title": "Java RMI â€“ Minimal Example DSM08Middleware public class Server implements Hello { public Server() {}",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". } } } Server.java",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 32,
      "chunk_id": "p32c3",
      "title": "Java RMI â€“ Minimal Example DSM08Middleware public class Server implements Hello { public Server() {}",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "SOAP DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 33,
      "chunk_id": "p33c1",
      "title": "SOAP DSM08Middleware",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "SOAP â€“ Simple Object Access Protocol â–ªSOAP is the standard messaging protocol used by Web services. SOAPâ€™s primary application is interapplication communication. SOAP codifies the use of XML as an encoding scheme for request and response parameters using HTTP as a means for transport",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 34,
      "chunk_id": "p34c1",
      "title": "SOAP â€“ Simple Object Access Protocol â–ªSOAP is the standard messaging protocol used by Web services. ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". or â–ªSOAP is a way for a program running in one operating system to communicate with a program running in either the same or a different operating system, using HTTP (or any other transport protocol) and XML. DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 34,
      "chunk_id": "p34c2",
      "title": "SOAP â€“ Simple Object Access Protocol â–ªSOAP is the standard messaging protocol used by Web services. ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "SOAP â–ªProtocol Neutrality: Can be used with various transport protocols (e.g., HTTP, SMTP). â–ªPlatform Independence: Allows communication between different platforms and programming languages",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 35,
      "chunk_id": "p35c1",
      "title": "SOAP â–ªProtocol Neutrality: Can be used with various transport protocols (e.g., HTTP, SMTP). â–ªPlatfor",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªPlatform Independence: Allows communication between different platforms and programming languages. â–ªSOAP â–ªcan be used over any transport protocol such as TCP, HTTP, SMTP â–ªallows for any programming model and is not tied to RPC â–ªdefines a model for processing individual, oneway messages â–ªalso allows for any number of message exchange patterns (MEPs) DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 35,
      "chunk_id": "p35c2",
      "title": "SOAP â–ªProtocol Neutrality: Can be used with various transport protocols (e.g., HTTP, SMTP). â–ªPlatfor",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "SOAPMessages â–ªSOAP message consists of three parts: â–ªSOAP Envelope â–ªtop element of the XML document representing the message. â–ªalways the root element of a SOAP message. â–ªSOAP Header (optional) â–ªSOAP Body DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 36,
      "chunk_id": "p36c1",
      "title": "SOAPMessages â–ªSOAP message consists of three parts: â–ªSOAP Envelope â–ªtop element of the XML document ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "SOAP â€“ Example Request POST /StockQuote HTTP/1.1 Host: www.stockquoteserver.com ContentType: text/xml; charset=\"utf8\" ContentLength: nnnn SOAPAction: \"SomeURI\" <SOAPENV:Envelope xmlns:SOAPENV=\"http://schemas.xmlsoap.org/soap/envelope/\" SOAPENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"> <SOAPENV:Body> <m:GetLastTradePrice xmlns:m=\"SomeURI\"> <symbol>DIS</symbol>",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 37,
      "chunk_id": "p37c1",
      "title": "SOAP â€“ Example Request POST /StockQuote HTTP/1.1 Host: www.stockquoteserver.com ContentType: text/xm",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "<SOAPENV:Body> <m:GetLastTradePrice xmlns:m=\"SomeURI\"> <symbol>DIS</symbol> </m:GetLastTradePrice> </SOAPENV:Body> </SOAPENV:Envelope> DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 37,
      "chunk_id": "p37c2",
      "title": "SOAP â€“ Example Request POST /StockQuote HTTP/1.1 Host: www.stockquoteserver.com ContentType: text/xm",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "SOAP â€“ Example Response HTTP/1.1 200 OK ContentType: text/xml; charset=\"utf8\" ContentLength: nnnn <SOAPENV:Envelope xmlns:SOAPENV=\"http://schemas.xmlsoap.org/soap/envelope/\" SOAPENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"/> <SOAPENV:Body> <m:GetLastTradePriceResponse xmlns:m=\"SomeURI\"> <Price>34.5</Price> </m:GetLastTradePriceResponse> </SOAPENV:Body> </SOAPENV:Envelope>",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 38,
      "chunk_id": "p38c1",
      "title": "SOAP â€“ Example Response HTTP/1.1 200 OK ContentType: text/xml; charset=\"utf8\" ContentLength: nnnn <S",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "<Price>34.5</Price> </m:GetLastTradePriceResponse> </SOAPENV:Body> </SOAPENV:Envelope> DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 38,
      "chunk_id": "p38c2",
      "title": "SOAP â€“ Example Response HTTP/1.1 200 OK ContentType: text/xml; charset=\"utf8\" ContentLength: nnnn <S",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "WSDLWeb Services Description Language â–ªXMLbased language for describing web service functionalities. â–ªserves as a contract defining operations, messages, and communication details. â–ªKey elements include types, message, port type, binding, and service. â–ªWSDL enables interoperability by standardizing communication details. â–ªSupports automated code generation for streamlined development",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 39,
      "chunk_id": "p39c1",
      "title": "WSDLWeb Services Description Language â–ªXMLbased language for describing web service functionalities.",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªSupports automated code generation for streamlined development. DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 39,
      "chunk_id": "p39c2",
      "title": "WSDLWeb Services Description Language â–ªXMLbased language for describing web service functionalities.",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "WSDLWeb Services Description Language <definitions name = \"HelloService\" targetNamespace = \"http://www.examples.com/wsdl/HelloService.wsdl\" xmlns = \"http://schemas.xmlsoap.org/wsdl/\" xmlns:soap = \"http://schemas.xmlsoap.org/wsdl/soap/\" xmlns:tns = \"http://www.examples.com/wsdl/HelloService.wsdl\" xmlns:xsd = \"http://www.w3.org/2001/XMLSchema\"> <message name = \"SayHelloRequest\"> <part name =",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 40,
      "chunk_id": "p40c1",
      "title": "WSDLWeb Services Description Language <definitions name = \"HelloService\" targetNamespace = \"http://w",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "xmlns:xsd = \"http://www.w3.org/2001/XMLSchema\"> <message name = \"SayHelloRequest\"> <part name = \"firstName\" type = \"xsd:string\"/> </message> <message name = \"SayHelloResponse\"> <part name = \"greeting\" type = \"xsd:string\"/> </message> <portType name = \"Hello_PortType\"> <operation name = \"sayHello\"> <input message = \"tns:SayHelloRequest\"/> <output message = \"tns:SayHelloResponse\"/> </operation>",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 40,
      "chunk_id": "p40c2",
      "title": "WSDLWeb Services Description Language <definitions name = \"HelloService\" targetNamespace = \"http://w",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "<input message = \"tns:SayHelloRequest\"/> <output message = \"tns:SayHelloResponse\"/> </operation> </portType> DSM08Middleware <binding name = \"Hello_Binding\" type = \"tns:Hello_PortType\"> <soap:binding style = \"rpc\" transport = \"http://schemas.xmlsoap.org/soap/http\"/> <operation name = \"sayHello\"> <soap:operation soapAction = \"sayHello\"/> <input> <soap:body encodingStyle =",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 40,
      "chunk_id": "p40c3",
      "title": "WSDLWeb Services Description Language <definitions name = \"HelloService\" targetNamespace = \"http://w",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "name = \"sayHello\"> <soap:operation soapAction = \"sayHello\"/> <input> <soap:body encodingStyle = \"http://schemas.xmlsoap.org/soap/encoding/\" namespace = \"urn:examples:helloservice\" use = \"encoded\"/> </input> <output> <soap:body encodingStyle = \"http://schemas.xmlsoap.org/soap/encoding/\" namespace = \"urn:examples:helloservice\" use = \"encoded\"/> </output> </operation> </binding> <service name =",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 40,
      "chunk_id": "p40c4",
      "title": "WSDLWeb Services Description Language <definitions name = \"HelloService\" targetNamespace = \"http://w",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "= \"urn:examples:helloservice\" use = \"encoded\"/> </output> </operation> </binding> <service name = \"Hello_Service\"> <documentation>WSDL File for HelloService</documentation> <port binding = \"tns:Hello_Binding\" name = \"Hello_Port\"> <soap:address location = \"http://www.examples.com/SayHello/\" /> </port> </service> </definitions>",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 40,
      "chunk_id": "p40c5",
      "title": "WSDLWeb Services Description Language <definitions name = \"HelloService\" targetNamespace = \"http://w",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "REST DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 41,
      "chunk_id": "p41c1",
      "title": "REST DSM08Middleware",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "RESTful Applications Statelessness â–ªEach client request contains all necessary information. â–ªServers do not store client state, enhancing scalability. ResourceBased â–ªResources are identified by URIs and manipulated using standard HTTP methods. Uniform Interface â–ªConsistent constraints for interacting with resources",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 42,
      "chunk_id": "p42c1",
      "title": "RESTful Applications Statelessness â–ªEach client request contains all necessary information. â–ªServers",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Uniform Interface â–ªConsistent constraints for interacting with resources. â–ªIncludes resource identification, manipulation through representations, and HATEOAS. Representation â–ªResources have multiple representations (e.g., JSON, XML). â–ªClients interact with resources through exchanged representations. DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 42,
      "chunk_id": "p42c2",
      "title": "RESTful Applications Statelessness â–ªEach client request contains all necessary information. â–ªServers",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "RESTful Applications Stateless Communication â–ªEach request is independent and selfcontained. Cacheability â–ªResponses can be marked as cacheable or noncacheable. Layered System â–ªArchitecture can have multiple layers for scalability and separation of concerns. Optional: Code on Demand â–ªClients can download and execute code from the server",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 43,
      "chunk_id": "p43c1",
      "title": "RESTful Applications Stateless Communication â–ªEach request is independent and selfcontained. Cacheab",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Optional: Code on Demand â–ªClients can download and execute code from the server. SelfDescriptive Messages â–ªMessages contain information about their purpose. HATEOAS â–ªClients navigate through hyperlinks dynamically provided in the applicationâ€™s representation. DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 43,
      "chunk_id": "p43c2",
      "title": "RESTful Applications Stateless Communication â–ªEach request is independent and selfcontained. Cacheab",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "REST APIs â€œRepresentational State Transfer is intended to evoke an image of how a welldesigned Web application behaves: a network of web pages (a virtual state machine), where the user progresses through an application by selecting links (state transitions), resulting in the next page (representing the next state of the application) being transferred to the user and rendered for their use.â€",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 44,
      "chunk_id": "p44c1",
      "title": "REST APIs â€œRepresentational State Transfer is intended to evoke an image of how a welldesigned Web a",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "the next state of the application) being transferred to the user and rendered for their use.â€ DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 44,
      "chunk_id": "p44c2",
      "title": "REST APIs â€œRepresentational State Transfer is intended to evoke an image of how a welldesigned Web a",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "REST APIs â–ªSimilar purpose like SOAP: allow heterogeneous devices/platforms to talk to each other and access services â–ªHowever, much simpler than SOAP and more lightweight â–ªStateless â–ªUse of JSON instead of XML â–ªEasy to learn and use DSM08Middleware REST uses common HTTP methods to insert/delete/update/retrieve information: â–ª GET Requests a specific representation of a resource â–ª PUT Creates or",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 45,
      "chunk_id": "p45c1",
      "title": "REST APIs â–ªSimilar purpose like SOAP: allow heterogeneous devices/platforms to talk to each other an",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "information: â–ª GET Requests a specific representation of a resource â–ª PUT Creates or updates a resource with the supplied representation â–ª DELETE Deletes the specified resource â–ª POST Submits data to be processed by the identified resource Source: mannhowie.com",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 45,
      "chunk_id": "p45c2",
      "title": "REST APIs â–ªSimilar purpose like SOAP: allow heterogeneous devices/platforms to talk to each other an",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "REST â€“ URL Endpoints â–ªA URL endpoint in a RESTful API represents an object, data, or service that the API can access. â–ªexample.com/surveys represents survey templates, and example.com/surveys/123/responses represents responses for a specific survey",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 46,
      "chunk_id": "p46c1",
      "title": "REST â€“ URL Endpoints â–ªA URL endpoint in a RESTful API represents an object, data, or service that th",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªA best practice example: DSM08Middleware URL endpoint resource GET POST PUT DELETE /surveys Retrieve all surveys Create a new survey Bulk update surveys (not advised) Remove all surveys (not advised) /surveys/123 Retrieve the details for survey 123 Error Update the details of survey 123 if it exists Remove survey 123 /surveys/123/responses Retrieve all responses for survey Create a new response",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 46,
      "chunk_id": "p46c2",
      "title": "REST â€“ URL Endpoints â–ªA URL endpoint in a RESTful API represents an object, data, or service that th",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Remove survey 123 /surveys/123/responses Retrieve all responses for survey Create a new response for survey 123 Bulk update responses for survey 123 (not advised) Remove all responses for survey 123 (not advised) /responses/42 Retrieve the details for response Error Update the details of response 42 if it exists Remove response 42 mannhowie.com/restapi",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 46,
      "chunk_id": "p46c3",
      "title": "REST â€“ URL Endpoints â–ªA URL endpoint in a RESTful API represents an object, data, or service that th",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "gRPC DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 47,
      "chunk_id": "p47c1",
      "title": "gRPC DSM08Middleware",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "gRPCMotivation REST works well butâ€¦ â–ªonly provides loosely defined contracts â–ªHTTP binding to language needs to be maintained â–ªuses inefficient JSON representation Communication should be easy and efficient! â†’This is what gRPC tries to solve gRPC nowadays is a highperformance, opensource, featurerich RPC framework, originally developed by Google, and now is a part of the cloud native computing",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 48,
      "chunk_id": "p48c1",
      "title": "gRPCMotivation REST works well butâ€¦ â–ªonly provides loosely defined contracts â–ªHTTP binding to langua",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "RPC framework, originally developed by Google, and now is a part of the cloud native computing foundation (or CNCF)",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 48,
      "chunk_id": "p48c2",
      "title": "gRPCMotivation REST works well butâ€¦ â–ªonly provides loosely defined contracts â–ªHTTP binding to langua",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". DSM08Middleware",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 48,
      "chunk_id": "p48c3",
      "title": "gRPCMotivation REST works well butâ€¦ â–ªonly provides loosely defined contracts â–ªHTTP binding to langua",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "gRPC â€“ Code Generation DSM08Middleware â–ªgRPC uses protocol buffers (protobuf) as IDL and also message interchange format. â–ªStubs are generated on the client side in gRPC from the protobuf service definition, allowing clients to make remote calls",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 49,
      "chunk_id": "p49c1",
      "title": "gRPC â€“ Code Generation DSM08Middleware â–ªgRPC uses protocol buffers (protobuf) as IDL and also messag",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªSkeletons are generated on the server side in gRPC from the same protobuf service definition, providing a foundation for implementing server logic to handle incoming remote procedure calls (RPCs)",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 49,
      "chunk_id": "p49c2",
      "title": "gRPC â€“ Code Generation DSM08Middleware â–ªgRPC uses protocol buffers (protobuf) as IDL and also messag",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". REST gRPC Crossplatform Yes Yes Message Format Custom but generally JSON Protocol buffers Message Payload Size Medium/Large Small Processing Complexity Higher (text parsing) Lower (welldefined binary structure) Browser Support Yes (native) Yes (via gRPCWeb) REST vs. gRPC",
    "metadata": {
      "source": "Lecture_08.pdf",
      "page": 49,
      "chunk_id": "p49c3",
      "title": "gRPC â€“ Code Generation DSM08Middleware â–ªgRPC uses protocol buffers (protobuf) as IDL and also messag",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Prof. Dr. Janick Edinger Distributed Systems and Middleware 04 â€“ Time",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 1,
      "chunk_id": "p1c1",
      "title": "Prof. Dr. Janick Edinger Distributed Systems and Middleware 04 â€“ Time",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Motivation DSM04Time time: 3267 time: 3269 A B",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 2,
      "chunk_id": "p2c1",
      "title": "Motivation DSM04Time time: 3267 time: 3269 A B",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Motivation DSM04Time time: 3267 time: 3269 A B time: 3268 time: 3270 A B",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 3,
      "chunk_id": "p3c1",
      "title": "Motivation DSM04Time time: 3267 time: 3269 A B time: 3268 time: 3270 A B",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Motivation DSM04Time time: 3267 time: 3269 A B time: 3268 time: 3270 A B time: 3271 time: 3273 A B update(3269)? no update",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 4,
      "chunk_id": "p4c1",
      "title": "Motivation DSM04Time time: 3267 time: 3269 A B time: 3268 time: 3270 A B time: 3271 time: 3273 A B u",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Agenda â–ªClock Synchronization â–ªLogical Clocks â–ªLamport Clocks â–ªVector Clocks â–ªGlobal State â–ªSnapshot Algorithm DSM04Time",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 5,
      "chunk_id": "p5c1",
      "title": "Agenda â–ªClock Synchronization â–ªLogical Clocks â–ªLamport Clocks â–ªVector Clocks â–ªGlobal State â–ªSnapshot",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Clock Synchronization â–ªIn a centralized system, time is unambiguous. â–ªCrystal oscillators are used to measure time in computers â–ªOscillate at a welldefined frequency â–ªEach oscillation decrements a counter by one â–ªWhen counter is 0, â†’hardware interrupt (clock tick) â–ªEach crystal runs at a slightly different frequency â–ªNo problem with a single system â–ªBut what about multiple computers? DSM04Time",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 6,
      "chunk_id": "p6c1",
      "title": "Clock Synchronization â–ªIn a centralized system, time is unambiguous. â–ªCrystal oscillators are used t",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Clock Synchronization Two problems 1. How do we synchronize physical clocks with realworld clocks? (Accuracy) 2. How do we synchronize the clocks with each other? (Precision) Accuracy is about correctness and how close a measurement is to the true value, while precision is about consistency and how close repeated measurements are to each other",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 7,
      "chunk_id": "p7c1",
      "title": "Clock Synchronization Two problems 1. How do we synchronize physical clocks with realworld clocks? (",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". You can be accurate, precise, both, or neither depending on the situation. DSM04Time",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 7,
      "chunk_id": "p7c2",
      "title": "Clock Synchronization Two problems 1. How do we synchronize physical clocks with realworld clocks? (",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Clock Synchronization Two problems 1. How do we synchronize physical clocks with realworld clocks? 2. How do we synchronize the clocks with each other? DSM04Time",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 8,
      "chunk_id": "p8c1",
      "title": "Clock Synchronization Two problems 1. How do we synchronize physical clocks with realworld clocks? 2",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Clock Synchronization Two problems 1. How do we synchronize physical clocks with realworld clocks? â–ªBasis for global time: Coordinated Universal Time (UTC) â–ª~40 shortwave radio stations accross the world broadcast time signal â–ªAccuracy Â±1ms (in practice Â±10ms) 2. How do we synchronize the clocks with each other? DSM04Time",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 9,
      "chunk_id": "p9c1",
      "title": "Clock Synchronization Two problems 1. How do we synchronize physical clocks with realworld clocks? â–ª",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Clock Synchronization Algorithms â–ªA software clock in a computer is derived from that computerâ€™s hardware clock",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 10,
      "chunk_id": "p10c1",
      "title": "Clock Synchronization Algorithms â–ªA software clock in a computer is derived from that computerâ€™s har",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªCounting the interrupts â–ªAll hardware clocks have clock drifts, leading to different values for time in different machines â–ª1s30s per year â–ªclock drift ratio Ï, precision Ï€, time Î”t â–ªmaximum offset = 2Ï * Î”t â–ªTo guarantee a precision Ï€, resynchronization is required every Ï€/(2Ï) seconds DSM04Time",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 10,
      "chunk_id": "p10c2",
      "title": "Clock Synchronization Algorithms â–ªA software clock in a computer is derived from that computerâ€™s har",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Christianâ€™s Algorithm (Network Time Protocol) â–ªClient contacts a timeserver (master) â–ªCalculate roundtrip time (RTT) of messages â–ªRTT = (T1T0) â€“ (T3T2) â–ª(T3T2) masterâ€™s interrupt handling time â–ªAssumption: Î´ = RTT/2 â–ªPi receives clock Cm from master server â–ªCi(T1) := Cm + Î´; Cm read at time T3 â–ªIf Ci > Cm+ d, slow down Ci â–ªNever! set clock back in time DSM04Time t T0 T1 T2 T3 Î´ Pi Master Cm Time?",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 11,
      "chunk_id": "p11c1",
      "title": "Christianâ€™s Algorithm (Network Time Protocol) â–ªClient contacts a timeserver (master) â–ªCalculate roun",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "> Cm+ d, slow down Ci â–ªNever! set clock back in time DSM04Time t T0 T1 T2 T3 Î´ Pi Master Cm Time? Î´",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 11,
      "chunk_id": "p11c2",
      "title": "Christianâ€™s Algorithm (Network Time Protocol) â–ªClient contacts a timeserver (master) â–ªCalculate roun",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Agenda â–ªClock Synchronization â–ªLogical Clocks â–ªLamport Clocks â–ªVector Clocks â–ªGlobal State â–ªSnapshot Algorithm DSM04Time",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 12,
      "chunk_id": "p12c1",
      "title": "Agenda â–ªClock Synchronization â–ªLogical Clocks â–ªLamport Clocks â–ªVector Clocks â–ªGlobal State â–ªSnapshot",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Logical Clocks (HappensbeforeRelationship) â–ªPrinciple of causality: If an event x is in any way the reason for a second event y, we say that x has happened before y. â–ªExample: message sending happens before receiving â–ªSystem Model: â–ªSet of processes â–ªProcess communications through messages â–ªProcesses formed as a series of events DSM04Time P Q R p1 p2 p3 q1 q2 q3 q4 q5 r1 r2 r3 r4 t",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 13,
      "chunk_id": "p13c1",
      "title": "Logical Clocks (HappensbeforeRelationship) â–ªPrinciple of causality: If an event x is in any way the ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Definition: Happenedbefore â–ªThe â€œhappenedbeforeâ€œ (â†’) relation is defined as follows 1. a, b are events of a process and a happened before b â–ªa â†’ b holds 2. If a is send event of a process and b related receive event of a process â–ªa â†’b holds 3",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 14,
      "chunk_id": "p14c1",
      "title": "Definition: Happenedbefore â–ªThe â€œhappenedbeforeâ€œ (â†’) relation is defined as follows 1. a, b are even",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". If a is send event of a process and b related receive event of a process â–ªa â†’b holds 3. If a, b, c are events in any processes with a â†’b and b â†’c â–ªa â†’c holds (transitivity) DSM04Time P Q R p1 p2 p3 q1 q2 q3 q4 q5 r1 r2 r3 r4 t p1 â†’ p2 p2 â†’ r3 p1 â†’ r3",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 14,
      "chunk_id": "p14c2",
      "title": "Definition: Happenedbefore â–ªThe â€œhappenedbeforeâ€œ (â†’) relation is defined as follows 1. a, b are even",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Definition: Happenedbefore â–ªTwo events a, b are parallel or causal independent (a || b), if neither a â†’b nor b â†’a is true. â–ªExample: q1 || r1 DSM04Time P Q R p1 p2 p3 q1 q2 q3 q4 q5 r1 r2 r3 r4 t p1 â†’ p2 p2 â†’ r3 p1 â†’ r3",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 15,
      "chunk_id": "p15c1",
      "title": "Definition: Happenedbefore â–ªTwo events a, b are parallel or causal independent (a || b), if neither ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Lamport Clocks â–ªLogical clock: each process Pi has a clock Ci â–ªCi: e Ïµ â„•0; e event in Pi â–ªClock system: function C assigns to each event e a number C(e), with C(e) = Ci(e) â–ªClock condition: A clock system is correct, if âˆ€ a,b: a â†’b â‡’ C(a) < C(b) DSM04Time Reads as: \"For all values of a and b, if a happened before b, then the value of C(a) is less than the value of C(b)",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 16,
      "chunk_id": "p16c1",
      "title": "Lamport Clocks â–ªLogical clock: each process Pi has a clock Ci â–ªCi: e Ïµ â„•0; e event in Pi â–ªClock syst",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". P1 P2 P3 t Note: â†’ happened before â‡’ logical implication",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 16,
      "chunk_id": "p16c2",
      "title": "Lamport Clocks â–ªLogical clock: each process Pi has a clock Ci â–ªCi: e Ïµ â„•0; e event in Pi â–ªClock syst",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Lamport Clocks â€“ Clock Conditions Clock condition is satisfied if â–ªC1: a, b are events in process Pi and a â†’b â‡’ Ci(a) < Ci(b) â–ªC2: a is a send event of message m in process Pi and b the corresponding receive event in process Pk â‡’Ci(a) < Ck(b) DSM04Time P1 P2 P3 t",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 17,
      "chunk_id": "p17c1",
      "title": "Lamport Clocks â€“ Clock Conditions Clock condition is satisfied if â–ªC1: a, b are events in process Pi",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Lamport Clocks â€“ Algorithm Each process Pi: â–ªinitializes Ci = 0; â–ªincrements Ci before executing an event (Ci++) â–ªe.g., local event, sending/receiving a message â–ªadds a timestamp ts to message m before sending it â–ªts(m) = Ci â–ªcomputes max{Ci,ts(m)} as the new Ci when receiving a a message from another process DSM04Time Pk max(1,3)+1 = 4 Ci Ck t Pi",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 18,
      "chunk_id": "p18c1",
      "title": "Lamport Clocks â€“ Algorithm Each process Pi: â–ªinitializes Ci = 0; â–ªincrements Ci before executing an ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Lamport Clocks â€“ Characteristics â–ªInversion of clock condition does not hold! â–ªa â†’b â‡’ C(a) < C(b) (clock condition) â–ªBut C(a) < C(b) â‡’ a â†’b â–ªWhat holds â–ªC(a) < C(b) â‡’ (a â†’b) âˆ¨ (a || b) â–ªC(a) < C(b) â‡’ Â¬(b â†’ a) â€œThe future does not affect the pastâ€œ â–ªDesirable â–ª(a â†’b â‡’ C(a) < C(b)) âˆ§ (C(a) < C(b) â‡’ a â†’b) (strong clock condition) DSM04Time P1 P2 P3 t",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 19,
      "chunk_id": "p19c1",
      "title": "Lamport Clocks â€“ Characteristics â–ªInversion of clock condition does not hold! â–ªa â†’b â‡’ C(a) < C(b) (c",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Vector Clocks â–ªLamport's clock condition does not allow to derive causal dependencies from logical clocks â–ªVector clocks provide equivalence of timestamp and causal order: VC(a) < VC(b) â‡” a â†’b â–ªAllow to determine causal dependencies using timestamps DSM04Time P Q R t a b",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 20,
      "chunk_id": "p20c1",
      "title": "Vector Clocks â–ªLamport's clock condition does not allow to derive causal dependencies from logical c",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Vector Clocks â–ªTimestamp is ndimensional vector â–ªTime is defined by a set of ndimensional vectors â–ªClock is an array C[1:n] â–ªNotation: â–ªVC (Pi)[k] kth component of vector clock of process Pi â–ªVC (a) timestamp of event a â–ªVC (a)[k] kth component of the timestamp DSM04Time P Q R t a b",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 21,
      "chunk_id": "p21c1",
      "title": "Vector Clocks â–ªTimestamp is ndimensional vector â–ªTime is defined by a set of ndimensional vectors â–ªC",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Vector Clocks â€“ Causal History of Events â–ªDefinition causal history (e) of an event e : â–ª (e) = {e' | e' râ†’e} â–ª(râ†’is the reflexive version of â†’) â–ªClaim: e' râ†’e â‡”e' Ïµ (e) â–ªClaim: e || e' â‡” Â¬ (e Ïµ (e' )) âˆ§Â¬(e' Ïµ (e)) DSM04Time P R S t Q T The cone includes all events that have a causal effect on e e",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 22,
      "chunk_id": "p22c1",
      "title": "Vector Clocks â€“ Causal History of Events â–ªDefinition causal history (e) of an event e : â–ª (e) = {e' ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Vector Clocks â€“ Timestamps â–ªTimestamp VC(e) of an event e is a vector out of (â„•0)n (n = #processes) â–ªLet Ei be the set of events at process Pi â–ªVC (e)[i] = | {e' Ïµ Ei | e' râ†’e } | = number of events of Pi that causally precede event e â–ªVC(e) encodes the causal history (e) DSM04Time P R S t Q T e The cone includes all events that have a causal effect on e",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 23,
      "chunk_id": "p23c1",
      "title": "Vector Clocks â€“ Timestamps â–ªTimestamp VC(e) of an event e is a vector out of (â„•0)n (n = #processes) ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Questions: 1) Where to add the cone? 2) What is the timestamp of e? Vector Clocks â€“ Example DSM04Time e",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 24,
      "chunk_id": "p24c1",
      "title": "Questions: 1) Where to add the cone? 2) What is the timestamp of e? Vector Clocks â€“ Example DSM04Tim",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Vector Clocks â€“ Timestamps â–ªComponent k points to most recent event of process k (and therefore implicitly on all previous events of process k) â–ªVector represents the complete causal history â–ªEncodes \"knowledge\" about all previous events DSM04Time",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 25,
      "chunk_id": "p25c1",
      "title": "Vector Clocks â€“ Timestamps â–ªComponent k points to most recent event of process k (and therefore impl",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Vector Clocks â€“ Arithmetics DSM04Time â‰¤ || More formally: â–ªVC1 â‰¤VC2 â‡”âˆ€i : VC1[i ] â‰¤VC2[i ] â–ªVC1 || VC2 â‡”Â¬(VC1 â‰¤VC2) âˆ§Â¬(VC2 â‰¤VC1) â–ªVC1 < VC2 â‡”VC1 â‰¤VC2 âˆ§VC1 â‰  VC2 comparable concurrent",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 26,
      "chunk_id": "p26c1",
      "title": "Vector Clocks â€“ Arithmetics DSM04Time â‰¤ || More formally: â–ªVC1 â‰¤VC2 â‡”âˆ€i : VC1[i ] â‰¤VC2[i ] â–ªVC1 || V",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Vector Clocks â€“ Arithmetics DSM04Time eâ€˜ e â–ªInterpretation of VC (e ) < VC (e' ): â–ªe belongs to the causal history of e' â–ªCone of eâ€˜ contains cone of e",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 27,
      "chunk_id": "p27c1",
      "title": "Vector Clocks â€“ Arithmetics DSM04Time eâ€˜ e â–ªInterpretation of VC (e ) < VC (e' ): â–ªe belongs to the ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Vector Clocks â€“ Algorithm Idea â–ªIdea: Analogous to Lamport clock, but using vectors â–ªMessages contain the complete causal history of the sender â‡’ time stamp of the send event â–ªReception of a message: merging of the cones = merging the knowledge about history â‡’ supremum of the vectors DSM04Time e eâ€˜",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 28,
      "chunk_id": "p28c1",
      "title": "Vector Clocks â€“ Algorithm Idea â–ªIdea: Analogous to Lamport clock, but using vectors â–ªMessages contai",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Vector Clocks â€“ Algorithm Idea â–ªIdea: Analogous to Lamport clock, but using vectors â–ªMessages contain the complete causal history of the sender â‡’ time stamp of the send event â–ªReception of a message: merging of the cones = merging the knowledge about history â‡’ supremum of the vectors DSM04Time e eâ€˜",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 29,
      "chunk_id": "p29c1",
      "title": "Vector Clocks â€“ Algorithm Idea â–ªIdea: Analogous to Lamport clock, but using vectors â–ªMessages contai",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Vector Clocks â€“ Algorithm Idea â–ªIdea: Analogous to Lamport clock, but using vectors â–ªMessages contain the complete causal history of the sender â‡’ time stamp of the send event â–ªReception of a message: merging of the cones = merging the knowledge about history â‡’ supremum of the vectors DSM04Time e eâ€˜",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 30,
      "chunk_id": "p30c1",
      "title": "Vector Clocks â€“ Algorithm Idea â–ªIdea: Analogous to Lamport clock, but using vectors â–ªMessages contai",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Vector Clocks â€“ Algorithm Idea â–ªIdea: Analogous to Lamport clock, but using vectors â–ªMessages contain the complete causal history of the sender â‡’ time stamp of the send event â–ªReception of a message: merging of the cones = merging the knowledge about history â‡’ supremum of the vectors DSM04Time e eâ€˜",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 31,
      "chunk_id": "p31c1",
      "title": "Vector Clocks â€“ Algorithm Idea â–ªIdea: Analogous to Lamport clock, but using vectors â–ªMessages contai",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Vector Clocks â€“ Algorithm (1) â–ªEach process has vector clock â–ª(encodes causal history) â–ªLocal Event: â–ªincrease own component â–ªSend Event: â–ªincrease own component and attach vector to message â–ªReceive Event: â–ªincrease own component and calculate supremum of vectors DSM04Time",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 32,
      "chunk_id": "p32c1",
      "title": "Vector Clocks â€“ Algorithm (1) â–ªEach process has vector clock â–ª(encodes causal history) â–ªLocal Event:",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Vector Clocks â€“ Another Example DSM04Time p1 p2 p3 p4",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 33,
      "chunk_id": "p33c1",
      "title": "Vector Clocks â€“ Another Example DSM04Time p1 p2 p3 p4",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Vector Clocks â€“ Another Example DSM04Time p1 p2 p3 p4",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 34,
      "chunk_id": "p34c1",
      "title": "Vector Clocks â€“ Another Example DSM04Time p1 p2 p3 p4",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Vector Clocks â€“ Algorithm (2) â–ªInitialization of clock in process pk: â–ªVC (pk) := (0, ..., 0); â–ªLocal event in pk: â–ªVC (pk)[k] := VC (pk)[k] + 1; â–ªSend event in pk : â–ªVC (pk)[k] := VC (pk)[k] + 1; â–ªsend (m, VC (m)); (where VC (m) = VC (pk)) â–ªReceive event in pk: â–ªVC (pk)[k] := VC (pk)[k] + 1; receive (m, VC (m)); â–ªâˆ€i = 1...n : VC (pk)[i] := max (VC (pk)[i], VC (m)[i]) DSM04Time",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 35,
      "chunk_id": "p35c1",
      "title": "Vector Clocks â€“ Algorithm (2) â–ªInitialization of clock in process pk: â–ªVC (pk) := (0, ..., 0); â–ªLoca",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Vector Clocks â€“ Interpretation â–ªOne can show: â–ªa â†’b â‡”VC(a) < VC(b) â–ªConcrete interpretation: â–ªVC(a) < VC(b) â‡”there is a causal relationship â–ªCorollary : â–ªe || e' â‡”VC (e ) || VC (e' ) â–ªOnly concurrent events do not influence each other DSM04Time b a",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 36,
      "chunk_id": "p36c1",
      "title": "Vector Clocks â€“ Interpretation â–ªOne can show: â–ªa â†’b â‡”VC(a) < VC(b) â–ªConcrete interpretation: â–ªVC(a) ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Vector Clocks â€“ Summary â–ªFoundation of many distributed algorithms â–ªBroadcast â–ªTermination â–ªDeadlock detection â–ªGarbage collection â–ªAnd more â€¦ â–ªIn general: Used nearly everywhere, where consistent state information is to be captured in distributed systems! DSM04Time",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 37,
      "chunk_id": "p37c1",
      "title": "Vector Clocks â€“ Summary â–ªFoundation of many distributed algorithms â–ªBroadcast â–ªTermination â–ªDeadlock",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Exercise â€“ Lamport Clocks DSM04Time t P Q R S",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 38,
      "chunk_id": "p38c1",
      "title": "Exercise â€“ Lamport Clocks DSM04Time t P Q R S",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Exercise â€“ Vector Clocks DSM04Time P Q R p1 p2 p3 p4 q1 q2 q3 p5 r1 r2 r3 r4",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 39,
      "chunk_id": "p39c1",
      "title": "Exercise â€“ Vector Clocks DSM04Time P Q R p1 p2 p3 p4 q1 q2 q3 p5 r1 r2 r3 r4",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Agenda â–ªClock Synchronization â–ªLogical Clocks â–ªLamport Clocks â–ªVector Clocks â–ªGlobal State â–ªSnapshot Algorithm DSM04Time",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 40,
      "chunk_id": "p40c1",
      "title": "Agenda â–ªClock Synchronization â–ªLogical Clocks â–ªLamport Clocks â–ªVector Clocks â–ªGlobal State â–ªSnapshot",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Global StateMotivation DSM04Time Distributed garbage collection: Find unreferenced objects Distributed deadlocks: Multiple processes wait for each other Distributed termination: Check whether a distributed algorithm has terminated Distributed debugging: Check whether assertions hold",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 41,
      "chunk_id": "p41c1",
      "title": "Global StateMotivation DSM04Time Distributed garbage collection: Find unreferenced objects Distribut",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Global StateMotivation DSM04Time â–ªGiven a global time: Just record state at one agreed time â–ªHowever, there is no perfect clock synchronization â–ªGoal: Assemble a meaningful global state from the local states recorded at different real times â–ªDefinitions: â–ªÏ• is a system of N processes with pi (i = 1, 2, â€¦ N) â–ªe is an event in this process (an internal action (updating a local variable) or sending",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 42,
      "chunk_id": "p42c1",
      "title": "Global StateMotivation DSM04Time â–ªGiven a global time: Just record state at one agreed time â–ªHowever",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "2, â€¦ N) â–ªe is an event in this process (an internal action (updating a local variable) or sending or receipt of a message to/from another process) â–ªhistory(pi) = hi = <ğ‘’ğ‘– 0, ğ‘’ğ‘– 1, ğ‘’ğ‘– 2, â€¦> â–ªhistory at a certain point in time k: ğ‘’ğ‘– ğ‘˜= < ğ‘’ğ‘– 0, ğ‘’ğ‘– 1,â€¦, ğ‘’ğ‘– ğ‘˜ >",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 42,
      "chunk_id": "p42c2",
      "title": "Global StateMotivation DSM04Time â–ªGiven a global time: Just record state at one agreed time â–ªHowever",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Global State â€“ Cuts DSM04Time â–ªhistory at a certain point in time k: â„ğ‘– ğ‘˜= < ğ‘’ğ‘– 0, ğ‘’ğ‘– 1,â€¦, ğ‘’ğ‘– ğ‘˜> â–ªstate ğ‘ ğ‘– ğ‘˜the state of process pi just before the kth event occurs â–ªglobal history of Ï•: H = h1 â‹ƒ h2 â‹ƒ â€¦ â‹ƒ hN (history of p1 and p2 and â€¦) â–ªglobal state S = (s1, s2, â€¦, sN) â–ªCut: The union of histories of all processes where pi is cut: C = < â„1 ğ¶1, â„2 ğ¶2,â€¦, ğ‘’ğ‘– ğ‘> â–ªEach process might be cut at a",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 43,
      "chunk_id": "p43c1",
      "title": "Global State â€“ Cuts DSM04Time â–ªhistory at a certain point in time k: â„ğ‘– ğ‘˜= < ğ‘’ğ‘– 0, ğ‘’ğ‘– 1,â€¦, ğ‘’ğ‘– ğ‘˜> â–ªst",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "of all processes where pi is cut: C = < â„1 ğ¶1, â„2 ğ¶2,â€¦, ğ‘’ğ‘– ğ‘> â–ªEach process might be cut at a different event (ek) â–ªğ‘’1 ğ¶1 is the event in process 1 that was just processed after the cut at process 1 â–ªThe set of events { ğ‘’ğ‘– ğ¶ğ‘–: i = 1, 2, â€¦, N} is called the frontier of the cut",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 43,
      "chunk_id": "p43c2",
      "title": "Global State â€“ Cuts DSM04Time â–ªhistory at a certain point in time k: â„ğ‘– ğ‘˜= < ğ‘’ğ‘– 0, ğ‘’ğ‘– 1,â€¦, ğ‘’ğ‘– ğ‘˜> â–ªst",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Global State â€“ Cuts Examples DSM04Time â–ªFirst cut <ğ‘’1 0, ğ‘’2 0> â–ªInconsistent cut â–ªWhy? p2 includes the receipt of message m1 which is sent after the cut in p1. â€œMessage from the futureâ€ â–ªSecond cut <ğ‘’1 2, ğ‘’2 2> â–ªConsistent cut â–ªIncludes the sending and receipt of m1 as well as the sending of message m2",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 44,
      "chunk_id": "p44c1",
      "title": "Global State â€“ Cuts Examples DSM04Time â–ªFirst cut <ğ‘’1 0, ğ‘’2 0> â–ªInconsistent cut â–ªWhy? p2 includes t",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Note: A cut C is consistent if, for each event it contains, it also contains all the events that happenedbefore that event: For all events ğ‘’âˆˆğ¶, ğ‘“â†’ğ‘’â‡’ğ‘“âˆˆğ¶ This is also called a consistent global state.",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 44,
      "chunk_id": "p44c2",
      "title": "Global State â€“ Cuts Examples DSM04Time â–ªFirst cut <ğ‘’1 0, ğ‘’2 0> â–ªInconsistent cut â–ªWhy? p2 includes t",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Agenda â–ªClock Synchronization â–ªLogical Clocks â–ªLamport Clocks â–ªVector Clocks â–ªGlobal State â–ªSnapshot Algorithm DSM04Time",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 45,
      "chunk_id": "p45c1",
      "title": "Agenda â–ªClock Synchronization â–ªLogical Clocks â–ªLamport Clocks â–ªVector Clocks â–ªGlobal State â–ªSnapshot",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Snapshot Algorithm of Chandy and Lamport DSM04Time â–ªFirst snapshot algorithm, published in 1985 â–ªGoal: record a set of process and channel states for a set of processes pi (i = 1, 2, ..., N), such that â–ªthe recorded global state is consistent, even though the recorded (local) states have never appeared at the same time in the execution",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 46,
      "chunk_id": "p46c1",
      "title": "Snapshot Algorithm of Chandy and Lamport DSM04Time â–ªFirst snapshot algorithm, published in 1985 â–ªGoa",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªAlgorithm: â–ªrecords (process and channel) state locally at processes â–ªdoes not give method for gathering global state at one site â–ªobvious method: processes send recorded state to collector process",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 46,
      "chunk_id": "p46c2",
      "title": "Snapshot Algorithm of Chandy and Lamport DSM04Time â–ªFirst snapshot algorithm, published in 1985 â–ªGoa",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Snapshot AlgorithmAssumptions DSM04Time â–ªNeither channels nor processes fail â–ªCommunication is reliable, i.e., each message is eventually received exactly once â–ªChannels are unidirectional and provide FIFOordered message delivery â–ªincoming: channels over which process receives messages â–ªoutgoing: channels over which process sends messages â–ªThe graph of processes and channels is strongly connected",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 47,
      "chunk_id": "p47c1",
      "title": "Snapshot AlgorithmAssumptions DSM04Time â–ªNeither channels nor processes fail â–ªCommunication is relia",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "over which process sends messages â–ªThe graph of processes and channels is strongly connected â–ªi.e., there is a path between any two processes â–ªAny process may initiate a global snapshot any time â–ªProcesses may continue their execution and send and receive normal messages while the snapshot takes place p1 p2 p3 p4",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 47,
      "chunk_id": "p47c2",
      "title": "Snapshot AlgorithmAssumptions DSM04Time â–ªNeither channels nor processes fail â–ªCommunication is relia",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Snapshot AlgorithmGoal DSM04Time â–ªConsistent cut: prevents â€œmessages from futureâ€œ (m1) â–ªMessages in transit (m2 was send in grey and arrives in blue epoch) â–ªnot captured in recorded process states of the receivers â–ªare to be recorded in channel state m1 m2",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 48,
      "chunk_id": "p48c1",
      "title": "Snapshot AlgorithmGoal DSM04Time â–ªConsistent cut: prevents â€œmessages from futureâ€œ (m1) â–ªMessages in ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Snapshot Algorithm â€“ Basic Idea DSM04Time â–ªEach process records â–ªprocess state, and â–ªset of messages sent to it â–ªWhich messages are recorded by a process p? â–ªfor each of pâ€˜s incoming channels, any message â–ªthat arrived after p recorded its state, and â–ªthat was sent before sender recorded its own state p1 p2 m1 m2 s1 s2 <m1,m2> c m3 M Mâ€˜ m0",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 49,
      "chunk_id": "p49c1",
      "title": "Snapshot Algorithm â€“ Basic Idea DSM04Time â–ªEach process records â–ªprocess state, and â–ªset of messages",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Snapshot Algorithm â€“ Markers DSM04Time â–ªThe algorithm uses special marker messages â–ªThese markers serve a dual purpose â–ªAs a prompt to for the receiver to record its state â–ªif it has not already done so â–ªAs a means of determining which messages to include in the channel state â–ªThe algorithm is defined by two rules â–ªThe marker receiving rule â–ªThe marker sending rule p1 p2 m1 m2 s1 s2 <m1,m2> c m3 M",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 50,
      "chunk_id": "p50c1",
      "title": "Snapshot Algorithm â€“ Markers DSM04Time â–ªThe algorithm uses special marker messages â–ªThese markers se",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "by two rules â–ªThe marker receiving rule â–ªThe marker sending rule p1 p2 m1 m2 s1 s2 <m1,m2> c m3 M Mâ€˜ m0",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 50,
      "chunk_id": "p50c2",
      "title": "Snapshot Algorithm â€“ Markers DSM04Time â–ªThe algorithm uses special marker messages â–ªThese markers se",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Snapshot Algorithm â€“ Marker Rules DSM04Time Marker receiving rule for process pi: When pi receives a marker message over channel c: if (pi has not yet recorded its state) it records its process state now; records the state of c as the empty set; turns on recording of messages arriving over other incoming channels; else pi records the state of c as the set of messages it has received over..",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 51,
      "chunk_id": "p51c1",
      "title": "Snapshot Algorithm â€“ Marker Rules DSM04Time Marker receiving rule for process pi: When pi receives a",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". channel c since it saved its state. end if",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 51,
      "chunk_id": "p51c2",
      "title": "Snapshot Algorithm â€“ Marker Rules DSM04Time Marker receiving rule for process pi: When pi receives a",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Snapshot Algorithm â€“ Marker Rules DSM04Time Marker sending rule for process pi: After pi has recorded its state, for each outgoing channel c: pi sends one marker message over c (before it sends any other message over c)",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 52,
      "chunk_id": "p52c1",
      "title": "Snapshot Algorithm â€“ Marker Rules DSM04Time Marker sending rule for process pi: After pi has recorde",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Snapshot Algorithm â€“ Remarks DSM04Time Marker sending rule obligates process to â–ªsend marker after having recorded the state but before sending any other message Marker receiving rule obligates process to â–ªrecord state and note incoming messages if this is the first marker â–ªrecord noted messages (i.e., channel state), otherwise",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 53,
      "chunk_id": "p53c1",
      "title": "Snapshot Algorithm â€“ Remarks DSM04Time Marker sending rule obligates process to â–ªsend marker after h",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Each process may begin algorithm at any time â–ªacts as if it received marker and follows marker receiving rule Several processes may start the algorithm â–ªas long as markers they use can be distinguished",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 53,
      "chunk_id": "p53c2",
      "title": "Snapshot Algorithm â€“ Remarks DSM04Time Marker sending rule obligates process to â–ªsend marker after h",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Snapshot Algorithm â€“ Example 1 DSM04Time â–ªM sent over a FIFOchannel after s1 was recorded, and before any other message is sent by p1 â–ªNo â€œmessages from futureâ€œ => consistent cut â–ªMâ€˜ sent over FIFOchannel after s2 was recorded, before any other message is sent by p2 â–ªall messages sent before s2 is recorded arrive before Mâ€˜ at p1 â–ªno message sent after s2 is recorded arrive before Mâ€˜ at p1 â–ªi.e.,",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 54,
      "chunk_id": "p54c1",
      "title": "Snapshot Algorithm â€“ Example 1 DSM04Time â–ªM sent over a FIFOchannel after s1 was recorded, and befor",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "recorded arrive before Mâ€˜ at p1 â–ªno message sent after s2 is recorded arrive before Mâ€˜ at p1 â–ªi.e., no â€œmessages from futureâ€ <m1, m2> p1 p2 M' M m1 m2 s1 c s2",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 54,
      "chunk_id": "p54c2",
      "title": "Snapshot Algorithm â€“ Example 1 DSM04Time â–ªM sent over a FIFOchannel after s1 was recorded, and befor",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Snapshot Algorithm â€“ Example 2 DSM04Time p1 p2 M m1 m2 m3 m4 m p3 p1 p2 p3",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 55,
      "chunk_id": "p55c1",
      "title": "Snapshot Algorithm â€“ Example 2 DSM04Time p1 p2 M m1 m2 m3 m4 m p3 p1 p2 p3",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Snapshot Algorithm â€“ Example 2 DSM04Time M m1 m2 m3 m4 m M Mâ€˜ p1 p2 p3 p1 p2 p3",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 56,
      "chunk_id": "p56c1",
      "title": "Snapshot Algorithm â€“ Example 2 DSM04Time M m1 m2 m3 m4 m M Mâ€˜ p1 p2 p3 p1 p2 p3",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Snapshot Algorithm â€“ Example 2 DSM04Time M m1 m2 m3 m4 m M Mâ€˜ Mâ€˜ p1 p2 p3 p1 p2 p3",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 57,
      "chunk_id": "p57c1",
      "title": "Snapshot Algorithm â€“ Example 2 DSM04Time M m1 m2 m3 m4 m M Mâ€˜ Mâ€˜ p1 p2 p3 p1 p2 p3",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Snapshot Algorithm â€“ Example 2 DSM04Time M m1 m2 m3 m4 m M Mâ€˜ Mâ€˜ <m5> <m1, m2> p1 p2 p3 p1 p2 p3",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 58,
      "chunk_id": "p58c1",
      "title": "Snapshot Algorithm â€“ Example 2 DSM04Time M m1 m2 m3 m4 m M Mâ€˜ Mâ€˜ <m5> <m1, m2> p1 p2 p3 p1 p2 p3",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Snapshot AlgorithmSummary DSM04Time â–ªThe ability to calculate global snapshots in a distributed system is very important. â–ªBut donâ€™t want to interrupt running distributed application. â–ªChandyLamport algorithm calculates global snapshot. â–ªObeys causality (creates a consistent cut). â–ªCan be used to detect global properties.",
    "metadata": {
      "source": "Lecture_04.pdf",
      "page": 59,
      "chunk_id": "p59c1",
      "title": "Snapshot AlgorithmSummary DSM04Time â–ªThe ability to calculate global snapshots in a distributed syst",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Prof. Dr. Janick Edinger Distributed Systems and Middleware 05 â€“ Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 1,
      "chunk_id": "p1c1",
      "title": "Prof. Dr. Janick Edinger Distributed Systems and Middleware 05 â€“ Coordination",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Agenda â–ªMutual Exclusion â–ªElection DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 2,
      "chunk_id": "p2c1",
      "title": "Agenda â–ªMutual Exclusion â–ªElection DSM05Coordination",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mutual ExclusionMotivation â–ªVery much related to mutual exclusion in local systems (operating systems) â–ªHow is it done there? â–ªIn distributed systems: No central variables or signals available â–ªSolutions must solely be based on message passing â–ªBasic solutions â–ªPermissionbased: A process wanting to enter its critical region, or access a resource, needs permission from other processes",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 3,
      "chunk_id": "p3c1",
      "title": "Mutual ExclusionMotivation â–ªVery much related to mutual exclusion in local systems (operating system",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªTokenbased: A token is passed between processes. The one who has the token may proceed in its critical region, or pass it on when not interested. DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 3,
      "chunk_id": "p3c2",
      "title": "Mutual ExclusionMotivation â–ªVery much related to mutual exclusion in local systems (operating system",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Centralized Solution â–ªDo it as in oneprocessor systems: Use a central controller. â–ªOne process is selected as the coordinator. a) Process P1 asks the coordinator for permission to access a shared resource. Permission is granted. b) Process P2 then asks permission to access the same resource. The coordinator does not reply",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 4,
      "chunk_id": "p4c1",
      "title": "Centralized Solution â–ªDo it as in oneprocessor systems: Use a central controller. â–ªOne process is se",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". b) Process P2 then asks permission to access the same resource. The coordinator does not reply. c) When P1 releases the resource, it tells the coordinator, which then replies to P2. â–ªSimple, but SPOF and bottleneck. Plus, how to distinguish a dead coordinator from a â€œrequest deniedâ€? However, powerful! DSM05Coordination a) b) c)",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 4,
      "chunk_id": "p4c2",
      "title": "Centralized Solution â–ªDo it as in oneprocessor systems: Use a central controller. â–ªOne process is se",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mutual Exclusion using Lamportâ€˜s Algorithm â–ªUsed to order critical section requests and to resolve any conflict between requests â–ªA request with smaller timestamp will be given permission to execute critical section first than a request with larger timestamp, and so on. â–ªMessages â–ªA process sends a REQUEST message to all other processes to get their permission to enter critical section",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 5,
      "chunk_id": "p5c1",
      "title": "Mutual Exclusion using Lamportâ€˜s Algorithm â–ªUsed to order critical section requests and to resolve a",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªA process sends a REPLY message to requesting process to give its permission to enter the critical section. â–ªA process sends a RELEASE message to all other processes upon exiting the critical section. â–ªEvery process pi, keeps a queue to store critical section requests ordered by their timestamps",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 5,
      "chunk_id": "p5c2",
      "title": "Mutual Exclusion using Lamportâ€˜s Algorithm â–ªUsed to order critical section requests and to resolve a",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªEvery process pi, keeps a queue to store critical section requests ordered by their timestamps. â–ªrequest_queuei denotes the queue of process pi â–ªA timestamp is given to each critical section request using Lamportâ€™s logical clock. DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 5,
      "chunk_id": "p5c3",
      "title": "Mutual Exclusion using Lamportâ€˜s Algorithm â–ªUsed to order critical section requests and to resolve a",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mutual Exclusion using Lamportâ€˜s Algorithm To enter critical section: â–ªWhen a process pi wants to enter the critical section â–ªsends a request message Request(tsi,i) to all other processes â–ªplaces the request on request_queuei",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 6,
      "chunk_id": "p6c1",
      "title": "Mutual Exclusion using Lamportâ€˜s Algorithm To enter critical section: â–ªWhen a process pi wants to en",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªWhen a process pj receives the request message Request(tsi,i) from process pi â–ªreturn a timestamped REPLY message to process pi â–ªplace the request of process pi on request_queuej DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 6,
      "chunk_id": "p6c2",
      "title": "Mutual Exclusion using Lamportâ€˜s Algorithm To enter critical section: â–ªWhen a process pi wants to en",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mutual Exclusion using Lamportâ€˜s Algorithm To execute the critical section: â–ªA process pi can enter the critical section â–ªif it has received the message with timestamp larger than (tsi, i) from all other sites â–ªand its own request is at the top of request_queuei DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 7,
      "chunk_id": "p7c1",
      "title": "Mutual Exclusion using Lamportâ€˜s Algorithm To execute the critical section: â–ªA process pi can enter ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mutual Exclusion using Lamportâ€˜s Algorithm To release the critical section: â–ªWhen a process pi exits the critical section â–ªit removes its own request from the top of its request queue â–ªAnd sends a timestamped RELEASE message to all other processes â–ªWhen a process pj receives the timestamped RELEASE message from process pi â–ªit removes the request of pi from its request queue DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 8,
      "chunk_id": "p8c1",
      "title": "Mutual Exclusion using Lamportâ€˜s Algorithm To release the critical section: â–ªWhen a process pi exits",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mutual Exclusion using Lamportâ€˜s Algorithm DSM05Coordination p1, 2 p2, 1",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 9,
      "chunk_id": "p9c1",
      "title": "Mutual Exclusion using Lamportâ€˜s Algorithm DSM05Coordination p1, 2 p2, 1",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mutual Exclusion using Lamportâ€˜s Algorithm DSM05Coordination p1, 2 p2, 1 p1, 2 p2, 1 p2, 1",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 10,
      "chunk_id": "p10c1",
      "title": "Mutual Exclusion using Lamportâ€˜s Algorithm DSM05Coordination p1, 2 p2, 1 p1, 2 p2, 1 p2, 1",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mutual Exclusion using Lamportâ€˜s Algorithm DSM05Coordination p1, 2 p2, 1 p1, 2 p2, 1 p2, 1 p1, 2 p2, 1 p2, 1 p1, 2",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 11,
      "chunk_id": "p11c1",
      "title": "Mutual Exclusion using Lamportâ€˜s Algorithm DSM05Coordination p1, 2 p2, 1 p1, 2 p2, 1 p2, 1 p1, 2 p2,",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mutual Exclusion using Lamportâ€˜s Algorithm DSM05Coordination p1, 2 p2, 1 p1, 2 p2, 1 p2, 1 p1, 2 p2, 1 p2, 1 p1, 2",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 12,
      "chunk_id": "p12c1",
      "title": "Mutual Exclusion using Lamportâ€˜s Algorithm DSM05Coordination p1, 2 p2, 1 p1, 2 p2, 1 p2, 1 p1, 2 p2,",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mutual Exclusion using Lamportâ€˜s Algorithm DSM05Coordination p1, 2 p2, 1 p1, 2 p2, 1 p2, 1 p1, 2 p2, 1 p2, 1 p1, 2",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 13,
      "chunk_id": "p13c1",
      "title": "Mutual Exclusion using Lamportâ€˜s Algorithm DSM05Coordination p1, 2 p2, 1 p1, 2 p2, 1 p2, 1 p1, 2 p2,",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mutual Exclusion using Lamportâ€˜s Algorithm DSM05Coordination p1, 2 p2, 1 p1, 2 p2, 1 p2, 1 p1, 2 p2, 1 p2, 1 p1, 2",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 14,
      "chunk_id": "p14c1",
      "title": "Mutual Exclusion using Lamportâ€˜s Algorithm DSM05Coordination p1, 2 p2, 1 p1, 2 p2, 1 p2, 1 p1, 2 p2,",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mutual Exclusion using Lamportâ€˜s Algorithm DSM05Coordination p1, 2 p2, 1 p1, 2 p2, 1 p2, 1 p1, 2 p1, 2 p1, 2 p1, 2 p2, 1 p2, 1 p1, 2",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 15,
      "chunk_id": "p15c1",
      "title": "Mutual Exclusion using Lamportâ€˜s Algorithm DSM05Coordination p1, 2 p2, 1 p1, 2 p2, 1 p2, 1 p1, 2 p1,",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Optimization: Ricart & Agrawala â–ªInterested process sends a request to all other processes â–ªThe receiving processes return a response to a request only when: â–ªthey have no interest in the shared resource; or â–ªthey are waiting for the resource, but have lower priority (known through comparison of timestamps). â–ªIn all other cases, reply is deferred, implying some more local administration",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 16,
      "chunk_id": "p16c1",
      "title": "Optimization: Ricart & Agrawala â–ªInterested process sends a request to all other processes â–ªThe rece",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªIn all other cases, reply is deferred, implying some more local administration. â–ªProblem: Really prone to failures (#nodes points of failure) DSM05Coordination a) b) c)",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 16,
      "chunk_id": "p16c2",
      "title": "Optimization: Ricart & Agrawala â–ªInterested process sends a request to all other processes â–ªThe rece",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mutual Exclusion â€“ Tokenbased â–ªOrganize processes in a logical ring, and let a token be passed between them. The one that holds the token is allowed to enter the critical region (if it wants to). â–ªSimple, but: â–ªwhen token gets lost, a new token needs to be created. Plus, it needs to be ensured, that it is the only token in the system. Otherwise â€¦? DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 17,
      "chunk_id": "p17c1",
      "title": "Mutual Exclusion â€“ Tokenbased â–ªOrganize processes in a logical ring, and let a token be passed betwe",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mutual Exclusion â€“ A Fully Decentralized Solution â–ªEach resource has N coordinators, â€˜randomlyâ€™ selected from a group of peers â–ªA hash function is used to compute the N keys of the coordinators â–ªEvery node in the network can compute these keys â–ªTo access a resource, a process needs a majority vote from m > N/2 coordinators â–ªif vote is <m, process backs of for a random amount of time â–ªm can be",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 18,
      "chunk_id": "p18c1",
      "title": "Mutual Exclusion â€“ A Fully Decentralized Solution â–ªEach resource has N coordinators, â€˜randomlyâ€™ sele",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "from m > N/2 coordinators â–ªif vote is <m, process backs of for a random amount of time â–ªm can be configured",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 18,
      "chunk_id": "p18c2",
      "title": "Mutual Exclusion â€“ A Fully Decentralized Solution â–ªEach resource has N coordinators, â€˜randomlyâ€™ sele",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Why not N/2 + 1? DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 18,
      "chunk_id": "p18c3",
      "title": "Mutual Exclusion â€“ A Fully Decentralized Solution â–ªEach resource has N coordinators, â€˜randomlyâ€™ sele",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mutual Exclusion â€“ A Fully Decentralized Solution â–ªCoordinators can crash and restart any time â–ªRecovery: Start over and forget everything that has happened â–ªProblem: Might already have given access to resource â–ªIf f â‰¥ 2m â€“ N, mutual exclusion not given (f = #restarted coordinators) â–ªIn practice: Violations can be neglected when m is set conservatively â–ªWhat happens when multiple processes request",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 19,
      "chunk_id": "p19c1",
      "title": "Mutual Exclusion â€“ A Fully Decentralized Solution â–ªCoordinators can crash and restart any time â–ªReco",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "can be neglected when m is set conservatively â–ªWhat happens when multiple processes request access at (almost) the same time? â–ªNo process gets >m votes, resource keeps underutilized/unused â–ªSolution: Clients can give back their votes and coordinators can vote again â–ªAfter a while, a client typically receives sufficient votes DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 19,
      "chunk_id": "p19c2",
      "title": "Mutual Exclusion â€“ A Fully Decentralized Solution â–ªCoordinators can crash and restart any time â–ªReco",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Mutual Exclusion â€“ Summary â–ªThe centralized algorithm is simplest and also most efficient â–ªLeast messages required (request, grant to enter, release) â–ªShortest delay before a process can enter the critical section â–ªAll algorithms suffer from failures â–ªComplex recovery mechanism necessary for distributed algorithms â†’Better go for a centralized solution But what if this central devices failsâ€¦?",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 20,
      "chunk_id": "p20c1",
      "title": "Mutual Exclusion â€“ Summary â–ªThe centralized algorithm is simplest and also most efficient â–ªLeast mes",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "algorithms â†’Better go for a centralized solution But what if this central devices failsâ€¦? DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 20,
      "chunk_id": "p20c2",
      "title": "Mutual Exclusion â€“ Summary â–ªThe centralized algorithm is simplest and also most efficient â–ªLeast mes",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Agenda â–ªMutual Exclusion â–ªElection DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 21,
      "chunk_id": "p21c1",
      "title": "Agenda â–ªMutual Exclusion â–ªElection DSM05Coordination",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Election Algorithms â–ªMany distributed algorithms require one process to act as coordinator â–ªAs all processes are equal, each could take over",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 22,
      "chunk_id": "p22c1",
      "title": "Election Algorithms â–ªMany distributed algorithms require one process to act as coordinator â–ªAs all p",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªBut who actually does? Election required! â–ªAssumptions: â–ªAll processes have unique idâ€™s â–ªAll processes know idâ€™s of all processes in the system (but not if they are up or down) â–ªElection means identifying the process with the highest id that is up â–ªElection algorithms differ in how they identify this process DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 22,
      "chunk_id": "p22c2",
      "title": "Election Algorithms â–ªMany distributed algorithms require one process to act as coordinator â–ªAs all p",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Election Algorithms â–ªWhen do elections take place? â–ªWhen leader is not responding anymore â–ªWhen system recovers from crash Conditions: â–ªLiveness: Every node will eventually enter an elected state or a nonelected state. â–ªSafety: Only a single node can enter the elected state and eventually, become the leader of the distributed system DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 23,
      "chunk_id": "p23c1",
      "title": "Election Algorithms â–ªWhen do elections take place? â–ªWhen leader is not responding anymore â–ªWhen syst",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Election Algorithms â€“ Bully Algorithm â–ªConsider N processes {P0 , . . . , PNâˆ’1} and let id(Pk ) = k . When a process Pk notices that the coordinator is no longer responding to requests, it initiates an election: 1. Pk sends an ELECTION message to all processes with higher identifiers: Pk+1, Pk+2 , . . . , PNâˆ’1. 2. If no one responds, Pk wins the election and becomes coordinator. 3",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 24,
      "chunk_id": "p24c1",
      "title": "Election Algorithms â€“ Bully Algorithm â–ªConsider N processes {P0 , . . . , PNâˆ’1} and let id(Pk ) = k ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". . . , PNâˆ’1. 2. If no one responds, Pk wins the election and becomes coordinator. 3. If one of the higherups answers, it takes over and Pkâ€™s job is done. DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 24,
      "chunk_id": "p24c2",
      "title": "Election Algorithms â€“ Bully Algorithm â–ªConsider N processes {P0 , . . . , PNâˆ’1} and let id(Pk ) = k ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Election Algorithms â€“ Bully Algorithm What happens when process 7 wakes up? DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 25,
      "chunk_id": "p25c1",
      "title": "Election Algorithms â€“ Bully Algorithm What happens when process 7 wakes up? DSM05Coordination",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Election Algorithms â€“ Ring Algorithm â–ªProcess priority is obtained by organizing processes into a (logical) ring. The process with the highest priority should be elected as coordinator. â–ªAny process can start an election by sending an election message to its successor. If a successor is down, the message is passed on to the next successor",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 26,
      "chunk_id": "p26c1",
      "title": "Election Algorithms â€“ Ring Algorithm â–ªProcess priority is obtained by organizing processes into a (l",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". If a successor is down, the message is passed on to the next successor. â–ªIf a message is passed on, the sender adds itself to the list. When it gets back to the initiator, everyone had a chance to make its presence known. â–ªThe initiator sends a coordinator message around the ring containing a list of all living processes. The one with the highest priority is elected as coordinator",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 26,
      "chunk_id": "p26c2",
      "title": "Election Algorithms â€“ Ring Algorithm â–ªProcess priority is obtained by organizing processes into a (l",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". The one with the highest priority is elected as coordinator. DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 26,
      "chunk_id": "p26c3",
      "title": "Election Algorithms â€“ Ring Algorithm â–ªProcess priority is obtained by organizing processes into a (l",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Election Algorithms â€“ Ring Algorithm â–ªThe solid line shows the election messages initiated by P6 â–ªThe dashed one, the messages by P3 â–ªP6 and P3 eventually receive their own election messages and send out coordinator messages next DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 27,
      "chunk_id": "p27c1",
      "title": "Election Algorithms â€“ Ring Algorithm â–ªThe solid line shows the election messages initiated by P6 â–ªTh",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Election Algorithms â€“ Example: RAFT Basics â–ªWe have a (relatively small) group of servers â–ªA server is in one of three states: follower , candidate, or leader â–ªThe protocol works in terms, starting with term 0 â–ªEach server starts in the follower state",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 28,
      "chunk_id": "p28c1",
      "title": "Election Algorithms â€“ Example: RAFT Basics â–ªWe have a (relatively small) group of servers â–ªA server ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". â–ªA leader is to regularly broadcast messages (perhaps just a simple heartbeat) â–ªWhen a follower does not receive heartbeats anymore, it starts an election DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 28,
      "chunk_id": "p28c2",
      "title": "Election Algorithms â€“ Example: RAFT Basics â–ªWe have a (relatively small) group of servers â–ªA server ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Election Algorithms â€“ Example: RAFT Election â–ªWhen server s1 timed out (has not received a heartbeat for a while), it â–ªincrements current term â–ªchanges to Candidate state â–ªVotes for itself â–ªsends RequestVote RPCs to all other servers â–ªLeader still alive? â–ªResponds with RPC and s1 returns to follower state â–ªOtherwise: Continue election DSM05Coordination The message primitives in RAFT are called",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 29,
      "chunk_id": "p29c1",
      "title": "Election Algorithms â€“ Example: RAFT Election â–ªWhen server s1 timed out (has not received a heartbeat",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "state â–ªOtherwise: Continue election DSM05Coordination The message primitives in RAFT are called remote procedure calls (RPCs) If leader s receives the message, it responds by acknowledging that it is still the leader",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 29,
      "chunk_id": "p29c2",
      "title": "Election Algorithms â€“ Example: RAFT Election â–ªWhen server s1 timed out (has not received a heartbeat",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". s1 returns to the follower state.",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 29,
      "chunk_id": "p29c3",
      "title": "Election Algorithms â€“ Example: RAFT Election â–ªWhen server s1 timed out (has not received a heartbeat",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Election Algorithms â€“ Example: RAFT Election (continued) â–ªEach server will vote for at most one candidate on a FIFO basis â–ªMajority rule: At most one candidate can win the election for each term â–ªOn RequestVote: â–ªCheck term in RPC vs. own current term â–ªOwn term higher? â†’ignore request â–ªOwn term lower? â†’update current term, vote for requester â–ªSimilar â†’Further checks necessary DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 30,
      "chunk_id": "p30c1",
      "title": "Election Algorithms â€“ Example: RAFT Election (continued) â–ªEach server will vote for at most one cand",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Election Algorithms â€“ Example: RAFT Election (continued) â–ªThere are three possible results of an election 1) s1 wins the election â†’send heartbeats to other servers to show dominance 2) another server s2 establishes itself as leader (and term(s2) â‰¥ term(s1)) â†’go back to follower state 3) a period of time goes by with no winner (split votes) â†’reinitiate the election â†’How can we prevent this from",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 31,
      "chunk_id": "p31c1",
      "title": "Election Algorithms â€“ Example: RAFT Election (continued) â–ªThere are three possible results of an ele",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "of time goes by with no winner (split votes) â†’reinitiate the election â†’How can we prevent this from happening again and again? DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 31,
      "chunk_id": "p31c2",
      "title": "Election Algorithms â€“ Example: RAFT Election (continued) â–ªThere are three possible results of an ele",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Election Algorithms â€“ Example: RAFT Election (continued) â–ªThere are three possible results of an election 1) s1 wins the election â†’send heartbeats to other servers to show dominance 2) another server s2 establishes itself as leader (and term(s2) â‰¥ term(s1)) â†’go back to follower state 3) a period of time goes by with no winner (split votes) â†’reinitiate the election â†’How can we prevent this from",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 32,
      "chunk_id": "p32c1",
      "title": "Election Algorithms â€“ Example: RAFT Election (continued) â–ªThere are three possible results of an ele",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "of time goes by with no winner (split votes) â†’reinitiate the election â†’How can we prevent this from happening again and again? â†’Solution: choose random timeout between T and 2T (typically 150300ms) DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 32,
      "chunk_id": "p32c2",
      "title": "Election Algorithms â€“ Example: RAFT Election (continued) â–ªThere are three possible results of an ele",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Election Algorithms â€“ Example: RAFT DSM05Coordination Follower Candidate Leader starts up times out, starts election times out, new election receives votes from majority of servers discovers server with higher term discovers current leader or new term",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 33,
      "chunk_id": "p33c1",
      "title": "Election Algorithms â€“ Example: RAFT DSM05Coordination Follower Candidate Leader starts up times out,",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Election Algorithms â€“ In LargeScale Systems Two approaches â–ªProof of work â–ªProof of stake DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 34,
      "chunk_id": "p34c1",
      "title": "Election Algorithms â€“ In LargeScale Systems Two approaches â–ªProof of work â–ªProof of stake DSM05Coord",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Election Algorithms â€“ Proof of work Basics â–ªConsider a potentially large group of processes â–ªEach process is required to solve a computational puzzle â–ªWhen a process solves the puzzle, it broadcasts its victory to the group Solving a computational puzzle â–ªMake use of a secure hashing function H(m): â–ªm is some data; H(m) returns a fixedlength bit string â–ªcomputing h = H(m) is computationally",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 35,
      "chunk_id": "p35c1",
      "title": "Election Algorithms â€“ Proof of work Basics â–ªConsider a potentially large group of processes â–ªEach pr",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "H(m): â–ªm is some data; H(m) returns a fixedlength bit string â–ªcomputing h = H(m) is computationally efficient â–ªfinding a function Hâˆ’1 such that m = Hâˆ’1(H(m)) is computationally extremely difficult â–ªPractice: finding Hâˆ’1 boils down to an extensive trialanderror procedure DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 35,
      "chunk_id": "p35c2",
      "title": "Election Algorithms â€“ Proof of work Basics â–ªConsider a potentially large group of processes â–ªEach pr",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Election Algorithms â€“ Proof of work Controlled race â–ªGiven a globally known secure hash function H* â–ªTask: given a bit string h = H*(m), find a bit string hËœ such that â–ªh* = H*(hËœ âŠ™ h) where: â–ªhâˆ— is a bit string with K leading zeroes â–ªhËœ âŠ™ h denotes some predetermined bitwise operation on hËœ and h â–ªBy controlling K , we control the difficulty of finding hËœ",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 36,
      "chunk_id": "p36c1",
      "title": "Election Algorithms â€“ Proof of work Controlled race â–ªGiven a globally known secure hash function H* ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". Success probability p = ( )K â–ªCurrent practice in many PoWbased blockchain systems, K = 64 â–ªWith K = 64, it takes about 10 minutes on a supercomputer to find hËœ â–ªWith K = 64, it takes about 100 years on a laptop to find hËœ DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 36,
      "chunk_id": "p36c2",
      "title": "Election Algorithms â€“ Proof of work Controlled race â–ªGiven a globally known secure hash function H* ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Election Algorithms â€“ Proof of work Discussion â–ªLarge K leads to? â–ªLong time between two successful guesses â–ªFew transactions can be processed per time unit â–ªHuge amounts of computational power (energy) is used. Wasted? â–ªSmall K leads to? â–ªLess energy consumption â–ªMore transactions per time unit â–ªPossible forking of the blockchain â–ªCan we do better? DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 37,
      "chunk_id": "p37c1",
      "title": "Election Algorithms â€“ Proof of work Discussion â–ªLarge K leads to? â–ªLong time between two successful ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Election Algorithms â€“ Proof of work Discussion â–ªLarge K leads to? â–ªLong time between two successful guesses â–ªFew transactions can be processed per time unit â–ªHuge amounts of computational power (energy) is used. Wasted? â–ªSmall K leads to? â–ªLess energy consumption â–ªMore transactions per time unit â–ªPossible forking of the blockchain â–ªCan we do better? DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 38,
      "chunk_id": "p38c1",
      "title": "Election Algorithms â€“ Proof of work Discussion â–ªLarge K leads to? â–ªLong time between two successful ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": "Election Algorithms â€“ Proof of stake Basics â–ªWe assume a blockchain system in which N secure tokens are used: â–ªEach token has a unique owner â–ªEach token has a uniquely associated index 1 â‰¤ k â‰¤ N â–ªA token cannot be modified or copied without this going unnoticed Principle â–ªDraw a random number k âˆˆ {1,..., N} â–ªLook up the process P that owns the token with index k . P is the next leader",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 39,
      "chunk_id": "p39c1",
      "title": "Election Algorithms â€“ Proof of stake Basics â–ªWe assume a blockchain system in which N secure tokens ",
      "ocr_used": false,
      "course": "DOS"
    }
  },
  {
    "page_content": ". P is the next leader. â–ªThe more tokens a process owns, the higher the probability it will be selected as leader. DSM05Coordination",
    "metadata": {
      "source": "Lecture_05.pdf",
      "page": 39,
      "chunk_id": "p39c2",
      "title": "Election Algorithms â€“ Proof of stake Basics â–ªWe assume a blockchain system in which N secure tokens ",
      "ocr_used": false,
      "course": "DOS"
    }
  }
]