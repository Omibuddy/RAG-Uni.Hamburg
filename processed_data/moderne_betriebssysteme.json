[
  {
    "page_content": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – 02 Prozesse mit Material von Olaf Spinczyk (Universität Osnabrück) und Horst Schirmeier (TU Dortmund)",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 1,
      "chunk_id": "p1c1",
      "title": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – 02 Prozesse mit Material von Olaf Spinczyk (Unive",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Abstraktionen – ein Überblick Prozesse konkret: UNIXProzessmodell Leichtgewichtige Prozessmodelle Systeme mit leichtgewichtigen Prozessen MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 2,
      "chunk_id": "p2c1",
      "title": "Inhalt Abstraktionen – ein Überblick Prozesse konkret: UNIXProzessmodell Leichtgewichtige Prozess",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Abstraktionen – ein Überblick Prozesse konkret: UNIXProzessmodell Leichtgewichtige Prozessmodelle Systeme mit leichtgewichtigen Prozessen MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 3,
      "chunk_id": "p3c1",
      "title": "Inhalt Abstraktionen – ein Überblick Prozesse konkret: UNIXProzessmodell Leichtgewichtige Prozess",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Ein Prozess… „... P ist ein Tripel (S, f, s), wobei S einen Zustandsraum, f eine Aktionsfunktion und s ⊂S die Anfangszustände des Prozesses P bezeichnen. Ein Prozess erzeugt Abläufe, die durch die Aktionsfunktion generiert werden können.“ – Horning/Randell, Process Structuring MOBS: 02Prozesse „... ist das Aktivitätszentrum innerhalb einer Folge von Elementaroperationen",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 4,
      "chunk_id": "p4c1",
      "title": "Ein Prozess… „... P ist ein Tripel (S, f, s), wobei S einen Zustandsraum, f eine Aktionsfunktion und",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". ist das Aktivitätszentrum innerhalb einer Folge von Elementaroperationen. Damit wird ein Prozess zu einer abstrakten Einheit, die sich durch die Instruktionen eines abstrakten Programms bewegt, wenn dieses auf einem Rechner ausgeführt wird.“ – Dennis/van Horn, Programming Semantics for Multiprogrammed Computations „..",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 4,
      "chunk_id": "p4c2",
      "title": "Ein Prozess… „... P ist ein Tripel (S, f, s), wobei S einen Zustandsraum, f eine Aktionsfunktion und",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". wird durch ein Programm kontrolliert und benötigt zur Ausführung dieses Programms einen Prozessor.“ – Habermann, Introduction to Operating System Design",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 4,
      "chunk_id": "p4c3",
      "title": "Ein Prozess… „... P ist ein Tripel (S, f, s), wobei S einen Zustandsraum, f eine Aktionsfunktion und",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Ein Prozess… „ist ein Programm in Ausführung.“– unbekannte Referenz, „Mundart“ Dazu gehört ein Prozesskontext, i.d.R.: Speicher: Code, Daten und Stapelsegment (text, data, bss, stack, heap) Prozessorregisterinhalte Instruktionszeiger Stapelzeiger Prozesszustand Benutzerkennung Zugriffsrechte aktuell belegte Betriebsmittel Dateien, E/AGeräte, usw",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 5,
      "chunk_id": "p5c1",
      "title": "Ein Prozess… „ist ein Programm in Ausführung.“– unbekannte Referenz, „Mundart“ Dazu gehört ein Pro",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". MOBS: 02Prozesse Vielzweckregister … wird repräsentiert durch einen Prozesskontrollblock (process control block, PCB)",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 5,
      "chunk_id": "p5c2",
      "title": "Ein Prozess… „ist ein Programm in Ausführung.“– unbekannte Referenz, „Mundart“ Dazu gehört ein Pro",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prozessmodell MOBS: 02Prozesse Technische Sicht Instruktionszeiger Kontextwechsel Konzeptionelle Sicht 4 unabhängige sequentielle Kontrollflüsse RealzeitSicht (GanttDiagramm) Zu jedem Zeitpunkt nur ein Prozess aktiv (UniProzessorHW)",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 6,
      "chunk_id": "p6c1",
      "title": "Prozessmodell MOBS: 02Prozesse Technische Sicht Instruktionszeiger Kontextwechsel Konzeptionelle S",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prozessverhalten undzustände (1) MOBS: 02Prozesse Prozesszustände RUNNING Prozess wird gerade ausgeführt READY Prozess ist rechenbereit, wartet auf die CPU BLOCKED Prozess wartet auf die Beendigung einer E/AAktivität",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 7,
      "chunk_id": "p7c1",
      "title": "Prozessverhalten undzustände (1) MOBS: 02Prozesse Prozesszustände RUNNING Prozess wird gerade ausgef",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prozessverhalten undzustände (2) MOBS: 02Prozesse Prozess A hat einen E/AVorgang gestartet und ist in den Zustand BLOCKED übergegangen. Da A die CPU nun nicht benötigt, hat das Betriebssystem den Prozess C ausgewählt und von READY in RUNNING überführt. Es fand ein Kontextwechsel von A zu C statt.",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 8,
      "chunk_id": "p8c1",
      "title": "Prozessverhalten undzustände (2) MOBS: 02Prozesse Prozess A hat einen E/AVorgang gestartet und ist i",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prozessverhalten undzustände (3) MOBS: 02Prozesse C hat die CPU zu lange „besessen“, wurde „verdrängt“ und ist daher nun wieder im Zustand READY. Damit kann jetzt endlich auch B bearbeitet werden und wird RUNNING.",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 9,
      "chunk_id": "p9c1",
      "title": "Prozessverhalten undzustände (3) MOBS: 02Prozesse C hat die CPU zu lange „besessen“, wurde „verdräng",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prozessverhalten undzustände (4) MOBS: 02Prozesse Die E/AOperation von A ist nun abgeschlossen. Daraufhin wird A nun READY und wartet auf die Zuteilung der CPU.",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 10,
      "chunk_id": "p10c1",
      "title": "Prozessverhalten undzustände (4) MOBS: 02Prozesse Die E/AOperation von A ist nun abgeschlossen. Dara",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "CPUZuteilung (Scheduling) MOBS: 02Prozesse Ein einzelner SchedulingAlgorithmus charakterisiert sich durch die Reihenfolge von Prozessen in der Warteschlange und die Bedingungen, unter denen die Prozesse der Warteschlange zugeführt werden.",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 11,
      "chunk_id": "p11c1",
      "title": "CPUZuteilung (Scheduling) MOBS: 02Prozesse Ein einzelner SchedulingAlgorithmus charakterisiert sich ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "CPUZuteilung (Scheduling) (auch ”Ablaufplanung“) Sorgt für den geordneten Ablauf konkurrierender Prozesse Grundsätzliche Fragestellungen Welche Arten von Ereignissen führen zur Verdrängung? In welcher Reihenfolge sollen Prozesse ablaufen? Ziele eines SchedulingAlgorithmus benutzerorientiert, z.B. kurze Antwortzeiten systemorientiert, z.B",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 12,
      "chunk_id": "p12c1",
      "title": "CPUZuteilung (Scheduling) (auch ”Ablaufplanung“) Sorgt für den geordneten Ablauf konkurrierender Pr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". kurze Antwortzeiten systemorientiert, z.B. optimale CPUAuslastung Kein SchedulingAlgorithmus kann alle Bedürfnisse erfüllen MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 12,
      "chunk_id": "p12c2",
      "title": "CPUZuteilung (Scheduling) (auch ”Ablaufplanung“) Sorgt für den geordneten Ablauf konkurrierender Pr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prozesssynchronisation Beispiel: unkoordinierter Druckerzugriff MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 13,
      "chunk_id": "p13c1",
      "title": "Prozesssynchronisation Beispiel: unkoordinierter Druckerzugriff MOBS: 02Prozesse",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prozesssynchronisation Ursache: kritische Abschnitte Lösungsmöglichkeit: Gegenseitiger Ausschluss MutexAbstraktion MOBS: 02Prozesse Wenn sich einer der Prozesse A oder B zwischen lock und unlock befindet, kann der jeweils andere das lock nicht passieren und blockiert dort, bis der kritische Abschnitt wieder frei ist (unlock).",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 14,
      "chunk_id": "p14c1",
      "title": "Prozesssynchronisation Ursache: kritische Abschnitte Lösungsmöglichkeit: Gegenseitiger Ausschluss ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verklemmungen (Deadlocks ) MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 15,
      "chunk_id": "p15c1",
      "title": "Verklemmungen (Deadlocks ) MOBS: 02Prozesse",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Interprozesskommunikation Ermöglicht die Zusammenarbeit mehrerer Prozesse lokal (local), z.B. DruckerDämon, XServer entfernt (remote), z.B",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 16,
      "chunk_id": "p16c1",
      "title": "Interprozesskommunikation Ermöglicht die Zusammenarbeit mehrerer Prozesse lokal (local), z.B. Druc",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Webserver, DatenbankServer, ftpServer „Client/ServerSysteme“ Abstraktionen/Programmiermodelle Gemeinsamer Speicher mehrere Prozesse dürfen gleichzeitig denselben Speicherbereich nutzen zusätzlich Synchronisation notwendig Nachrichtenaustausch Semantik eines Faxes (verschickt wird die Kopie einer Nachricht) synchron oder asynchron MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 16,
      "chunk_id": "p16c2",
      "title": "Interprozesskommunikation Ermöglicht die Zusammenarbeit mehrerer Prozesse lokal (local), z.B. Druc",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Die Speicherhierarchie MOBS: 02Prozesse Speichereigenschaften steigende Zugriffszeiten steigende Kapazität sinkender Preis pro Bit Sehr wirtschaftlich durch das Lokalitätsprinzip!",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 17,
      "chunk_id": "p17c1",
      "title": "Die Speicherhierarchie MOBS: 02Prozesse Speichereigenschaften steigende Zugriffszeiten steigende K",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Speicherverwaltung Adressabbildung Logische Adressen auf physikalische Adressen Gestattet Relokation von Code u. Daten Platzierungsstrategie In welcher Lücke soll Speicher reserviert werden? Kompaktifizierung verwenden? Wie minimiert man das Fragmentierungsproblem? Ersetzungsstrategie Welcher Speicherbereich könnte sinnvoll ausgelagert werden? MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 18,
      "chunk_id": "p18c1",
      "title": "Speicherverwaltung Adressabbildung Logische Adressen auf physikalische Adressen Gestattet Relokat",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Abstraktionen – ein Überblick Prozesse konkret: UNIXProzessmodell Shells und E/A UNIXPhilosophie Prozesserzeugung Prozesszustände Leichtgewichtige Prozessmodelle Systeme mit leichtgewichtigen Prozessen MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 19,
      "chunk_id": "p19c1",
      "title": "Inhalt Abstraktionen – ein Überblick Prozesse konkret: UNIXProzessmodell Shells und E/A UNIXPhil",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX (K. Thompson, D. Ritchie, 1968) Eine lange Geschichte … Ursprung: Bell Labs Alternative zu „Multics“ Version 1 entstand auf einer DEC PDP 7 Assembler, 8K 18 Bit Worte Version 3 in „C“ realisiert MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 20,
      "chunk_id": "p20c1",
      "title": "UNIX (K. Thompson, D. Ritchie, 1968) Eine lange Geschichte … Ursprung: Bell Labs Alternative zu „",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX (K. Thompson, D. Ritchie, 1968) MOBS: 02Prozesse Quelle: Wikipedia (GPL)",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 21,
      "chunk_id": "p21c1",
      "title": "UNIX (K. Thompson, D. Ritchie, 1968) MOBS: 02Prozesse Quelle: Wikipedia (GPL)",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIXProzesse sind primäres Strukturierungskonzept für Aktivitäten Anwendungsprozesse und Systemprozesse können leicht und schnell weitere Prozesse erzeugen Elternprozess → Kindprozess MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 22,
      "chunk_id": "p22c1",
      "title": "UNIXProzesse sind primäres Strukturierungskonzept für Aktivitäten Anwendungsprozesse und Systempro",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIXProzesse bilden eine ProzessHierarchie: MOBS: 02Prozesse Jeder UNIXProzess hat eine eindeutige Nummer (ProzessID, PID). Die PID des Elternprozesses heißt PPID. Der initProzess liest aus der /etc/inittab die Liste der Terminals und startet für jedes das Programm getty, das die Einwahl über das Terminal mit Hilfe von login erlaubt",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 23,
      "chunk_id": "p23c1",
      "title": "UNIXProzesse bilden eine ProzessHierarchie: MOBS: 02Prozesse Jeder UNIXProzess hat eine eindeutige ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Auch die Shell nutzt Prozesse: Jedes Kommando wird als eigener Kindprozess ausgeführt.",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 23,
      "chunk_id": "p23c2",
      "title": "UNIXProzesse bilden eine ProzessHierarchie: MOBS: 02Prozesse Jeder UNIXProzess hat eine eindeutige ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIXShell „Schale“ (shell), die den „Kern“ (kernel) umgibt Textbasierte Nutzerschnittstelle zum Starten von Kommandos: Suche im Dateisystem entsprechend $PATH (z.B",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 24,
      "chunk_id": "p24c1",
      "title": "UNIXShell „Schale“ (shell), die den „Kern“ (kernel) umgibt Textbasierte Nutzerschnittstelle zum St",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". /usr/bin:/bin:...) Jedes ausgeführte Kommando ist ein eigener Kindprozess Typischerweise blockiert die Shell bis das Kommando terminiert Man kann aber auch Kommandos stoppen und fortsetzen („job control“) oder sie im Hintergrund ausführen ... MOBS: 02Prozesse Das Kommando which zeigt an, wo ein bestimmtes Kommando gefunden wird.",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 24,
      "chunk_id": "p24c2",
      "title": "UNIXShell „Schale“ (shell), die den „Kern“ (kernel) umgibt Textbasierte Nutzerschnittstelle zum St",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIXShells: Job Control MOBS: 02Prozesse  Kommando wird gestartet  die Shell blockiert Kommando wird gestoppt die Shell läuft weiter Durch das & am Ende wird kate im Hintergrund gestartet  jobs zeigt alle gestarteten Kommandos an  bg schickt ein gestopptes Kommando in den Hintergrund",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 25,
      "chunk_id": "p25c1",
      "title": "UNIXShells: Job Control MOBS: 02Prozesse  Kommando wird gestartet  die Shell blockiert Kommando w",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIXShells: Job Control MOBS: 02Prozesse  Kommando wird gestartet  die Shell blockiert Kommando wird gestoppt die Shell läuft weiter Durch das & am Ende wird kate im Hintergrund gestartet  jobs zeigt alle gestarteten Kommandos an  bg schickt ein gestopptes Kommando in den Hintergrund Beispiel in der Vorlesung: endless.c",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 26,
      "chunk_id": "p26c1",
      "title": "UNIXShells: Job Control MOBS: 02Prozesse  Kommando wird gestartet  die Shell blockiert Kommando w",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "StandardE/AKanäle von Prozessen Normalerweise verbunden mit dem Terminal, in dem die Shell läuft, die den Prozess gestartet hat: StandardEingabe Zum Lesen von Benutzereingaben (Tastatur) StandardAusgabe Textausgaben des Prozesses (TerminalFenster) StandardFehlerausgabe Separater Kanal für Fehlermeldungen (normalerweise auch das Terminal) Praktisch alle Kommandos akzeptieren auch Dateien als",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 27,
      "chunk_id": "p27c1",
      "title": "StandardE/AKanäle von Prozessen Normalerweise verbunden mit dem Terminal, in dem die Shell läuft, d",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "(normalerweise auch das Terminal) Praktisch alle Kommandos akzeptieren auch Dateien als Einoder Ausgabekanäle (statt des Terminals) Shells bieten eine einfache Syntax, um die StandardE/AKanäle umzuleiten ..",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 27,
      "chunk_id": "p27c2",
      "title": "StandardE/AKanäle von Prozessen Normalerweise verbunden mit dem Terminal, in dem die Shell läuft, d",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 27,
      "chunk_id": "p27c3",
      "title": "StandardE/AKanäle von Prozessen Normalerweise verbunden mit dem Terminal, in dem die Shell läuft, d",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "StandardE/AKanäle umleiten MOBS: 02Prozesse Umleitung der StandardAusgabe in die Datei „d1“ mit > Umleitung der StandardEingabe auf die Datei „d2“ mit < Mit | (pipe) verbindet die Shell die StandardAusgabe des linken mit der StandardEingabe des rechten Prozesses.",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 28,
      "chunk_id": "p28c1",
      "title": "StandardE/AKanäle umleiten MOBS: 02Prozesse Umleitung der StandardAusgabe in die Datei „d1“ mit > Um",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Die UNIXPhilosophie Doug McIlroy, der Erfinder der UNIXPipes, fasste die Philosophie hinter UNIX einmal wie folgt zusammen: \"This is the Unix philosophy:Write programs that do one thing and do it well.Write programs to work together.Write programs to handle text streams, because that is a universal interface.\" MOBS: 02Prozesse Für gewöhnlich wird das abgekürzt: „Do one thing, do it well.“",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 29,
      "chunk_id": "p29c1",
      "title": "Die UNIXPhilosophie Doug McIlroy, der Erfinder der UNIXPipes, fasste die Philosophie hinter UNIX ei",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIXProzesssteuerung: System Calls Ein erster Überblick ..",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 30,
      "chunk_id": "p30c1",
      "title": "UNIXProzesssteuerung: System Calls Ein erster Überblick ... getpid (2) liefert PID des laufenden P",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". getpid (2) liefert PID des laufenden Prozesses getppid (2) liefert PID des Elternprozesses (PPID) getuid (2) liefert die Benutzerkennung des laufenden Prozesses (UID) fork (2) erzeugt neuen Kindprozess exit (3), _exit (2) beendet den laufenden Prozess wait (2) wartet auf die Beendigung eines Kindprozesses execve (2) lädt und startet ein Programm im Kontext des laufenden Prozesses MOBS:",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 30,
      "chunk_id": "p30c2",
      "title": "UNIXProzesssteuerung: System Calls Ein erster Überblick ... getpid (2) liefert PID des laufenden P",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Kindprozesses execve (2) lädt und startet ein Programm im Kontext des laufenden Prozesses MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 30,
      "chunk_id": "p30c3",
      "title": "UNIXProzesssteuerung: System Calls Ein erster Überblick ... getpid (2) liefert PID des laufenden P",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIXProzesse im Detail: fork() System Call: pid_t fork (void) Dupliziert den laufenden Prozess (Prozesserzeugung!) Der Kindprozess erbt ... Adressraum (code, data, bss, stack) Prozessgruppe, Signaltabelle (dazu später mehr) Offene Dateien, aktuelles Arbeitsverzeichnis (dazu viel später mehr) Nicht kopiert wird ..",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 31,
      "chunk_id": "p31c1",
      "title": "UNIXProzesse im Detail: fork() System Call: pid_t fork (void) Dupliziert den laufenden Prozess (Pro",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Process ID (PID), Parent Process ID (PPID) anhängige Signale, AccountingDaten,... Ein Prozess ruft fork auf, aber zwei kehren zurück MOBS: 02Prozesse Benutzerkennung StandardE/AKanäle",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 31,
      "chunk_id": "p31c2",
      "title": "UNIXProzesse im Detail: fork() System Call: pid_t fork (void) Dupliziert den laufenden Prozess (Pro",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verwendung von fork() MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 32,
      "chunk_id": "p32c1",
      "title": "Verwendung von fork() MOBS: 02Prozesse",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verwendung von fork() MOBS: 02Prozesse #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <sys/types.h> int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); /*Process duplicated. From here on, both process are running.*/ if (pid > 0) { printf(\"Parent process. Child id: %d\\n\", pid); } else if (pid == 0) { printf(\"Child process",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 33,
      "chunk_id": "p33c1",
      "title": "Verwendung von fork() MOBS: 02Prozesse #include <stdio.h> #include <stdlib.h> #include <unistd.h> #i",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Child id: %d\\n\", pid); } else if (pid == 0) { printf(\"Child process. ID: %d, PPID: %d\\n\", getpid(), getppid()); } else { printf(\"Something went wrong.\\n\"); } return EXIT_SUCCESS; } Identischer Code, nur vollständig für copy&paste",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 33,
      "chunk_id": "p33c2",
      "title": "Verwendung von fork() MOBS: 02Prozesse #include <stdio.h> #include <stdlib.h> #include <unistd.h> #i",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); if (pid > 0) { printf(\"Parent. Child id: %d\\n\", pid); } else if (pid == 0) { printf(\"Child. ID: %d, PPID: %d\\n\", getpid(), getppid()); } else { printf(\"Something went wrong.\\n\"); } return EXIT_SUCCESS; } Verwendung von fork() MOBS: 02Prozesse int main(void) { pid_t pid; printf(\"Parent",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 34,
      "chunk_id": "p34c1",
      "title": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); if (pid > 0) { printf(\"Parent. Child id: %d\\n\", pid); } else if (pid == 0) { printf(\"Child. ID: %d, PPID: %d\\n\", getpid(), getppid()); } else { printf(\"Something went wrong.\\n\"); } return EXIT_SUCCESS; } PID: 7553 PID: 7554",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 34,
      "chunk_id": "p34c2",
      "title": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); if (pid > 0) { printf(\"Parent. Child id: %d\\n\", pid); } else if (pid == 0) { printf(\"Child. ID: %d, PPID: %d\\n\", getpid(), getppid()); } else { printf(\"Something went wrong.\\n\"); } return EXIT_SUCCESS; } Verwendung von fork() MOBS: 02Prozesse int main(void) { pid_t pid; printf(\"Parent",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 35,
      "chunk_id": "p35c1",
      "title": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); if (pid > 0) { printf(\"Parent. Child id: %d\\n\", pid); } else if (pid == 0) { printf(\"Child. ID: %d, PPID: %d\\n\", getpid(), getppid()); } else { printf(\"Something went wrong.\\n\"); } return EXIT_SUCCESS; } Parent. ID: 7553 PPID: 4015 PID: 7553 PID: 7554",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 35,
      "chunk_id": "p35c2",
      "title": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); if (pid > 0) { printf(\"Parent. Child id: %d\\n\", pid); } else if (pid == 0) { printf(\"Child. ID: %d, PPID: %d\\n\", getpid(), getppid()); } else { printf(\"Something went wrong.\\n\"); } return EXIT_SUCCESS; } Verwendung von fork() MOBS: 02Prozesse int main(void) { pid_t pid; printf(\"Parent",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 36,
      "chunk_id": "p36c1",
      "title": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); if (pid > 0) { printf(\"Parent. Child id: %d\\n\", pid); } else if (pid == 0) { printf(\"Child. ID: %d, PPID: %d\\n\", getpid(), getppid()); } else { printf(\"Something went wrong.\\n\"); } return EXIT_SUCCESS; } Parent. ID: 7553 PPID: 4015 PID: 7553 PID: 7554",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 36,
      "chunk_id": "p36c2",
      "title": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); if (pid > 0) { printf(\"Parent. Child id: %d\\n\", pid); } else if (pid == 0) { printf(\"Child. ID: %d, PPID: %d\\n\", getpid(), getppid()); } else { printf(\"Something went wrong.\\n\"); } return EXIT_SUCCESS; } int main(void) { pid_t pid; printf(\"Parent",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 37,
      "chunk_id": "p37c1",
      "title": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); if (pid > 0) { printf(\"Parent. Child id: %d\\n\", pid); } else if (pid == 0) { printf(\"Child. ID: %d, PPID: %d\\n\", getpid(), getppid()); } else { printf(\"Something went wrong.\\n\"); } return EXIT_SUCCESS; } Verwendung von fork() MOBS: 02Prozesse Parent. ID: 7553 PPID: 4015 PID: 7553 PID: 7554",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 37,
      "chunk_id": "p37c2",
      "title": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); if (pid > 0) { printf(\"Parent. Child id: %d\\n\", pid); } else if (pid == 0) { printf(\"Child. ID: %d, PPID: %d\\n\", getpid(), getppid()); } else { printf(\"Something went wrong.\\n\"); } return EXIT_SUCCESS; } int main(void) { pid_t pid; printf(\"Parent",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 38,
      "chunk_id": "p38c1",
      "title": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); if (pid > 0) { printf(\"Parent. Child id: %d\\n\", pid); } else if (pid == 0) { printf(\"Child. ID: %d, PPID: %d\\n\", getpid(), getppid()); } else { printf(\"Something went wrong.\\n\"); } return EXIT_SUCCESS; } Verwendung von fork() MOBS: 02Prozesse Parent. ID: 7553 PPID: 4015 Child. ID: 7554, PPID: 7553 PID: 7553 PID: 7554",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 38,
      "chunk_id": "p38c2",
      "title": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); if (pid > 0) { printf(\"Parent. Child id: %d\\n\", pid); } else if (pid == 0) { printf(\"Child. ID: %d, PPID: %d\\n\", getpid(), getppid()); } else { printf(\"Something went wrong.\\n\"); } return EXIT_SUCCESS; } int main(void) { pid_t pid; printf(\"Parent",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 39,
      "chunk_id": "p39c1",
      "title": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); if (pid > 0) { printf(\"Parent. Child id: %d\\n\", pid); } else if (pid == 0) { printf(\"Child. ID: %d, PPID: %d\\n\", getpid(), getppid()); } else { printf(\"Something went wrong.\\n\"); } return EXIT_SUCCESS; } Verwendung von fork() MOBS: 02Prozesse Parent. ID: 7553 PPID: 4015 Child. ID: 7554, PPID: 7553 PID: 7553 PID: 7554",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 39,
      "chunk_id": "p39c2",
      "title": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); if (pid > 0) { printf(\"Parent. Child id: %d\\n\", pid); } else if (pid == 0) { printf(\"Child. ID: %d, PPID: %d\\n\", getpid(), getppid()); } else { printf(\"Something went wrong.\\n\"); } return EXIT_SUCCESS; } int main(void) { pid_t pid; printf(\"Parent",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 40,
      "chunk_id": "p40c1",
      "title": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); if (pid > 0) { printf(\"Parent. Child id: %d\\n\", pid); } else if (pid == 0) { printf(\"Child. ID: %d, PPID: %d\\n\", getpid(), getppid()); } else { printf(\"Something went wrong.\\n\"); } return EXIT_SUCCESS; } Verwendung von fork() MOBS: 02Prozesse Parent. ID: 7553 PPID: 4015 Child. ID: 7554, PPID: 7553 Parent. Child ID: 7554 PID: 7553 PID: 7554",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 40,
      "chunk_id": "p40c2",
      "title": "int main(void) { pid_t pid; printf(\"Parent. ID: %d PPID: %d\\n\", getpid(), getppid()); pid = fork(); ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: Schnelle Prozesserzeugung Das Kopieren des Adressraums kostet viel Zeit Insbesondere bei direkt folgendem exec..() pure Verschwendung! Historische Lösung: vfork Der Elternprozess wird suspendiert, bis der Kindprozess exec..() aufruft oder mit _exit() terminiert Der Kindprozess benutzt einfach Code und Daten des Elternprozesses (kein Kopieren!) Der Kindprozess darf keine Daten",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 41,
      "chunk_id": "p41c1",
      "title": "Diskussion: Schnelle Prozesserzeugung Das Kopieren des Adressraums kostet viel Zeit Insbesondere b",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "einfach Code und Daten des Elternprozesses (kein Kopieren!) Der Kindprozess darf keine Daten verändern teilweise nicht so einfach: z.B",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 41,
      "chunk_id": "p41c2",
      "title": "Diskussion: Schnelle Prozesserzeugung Das Kopieren des Adressraums kostet viel Zeit Insbesondere b",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". kein exit() aufrufen, sondern _exit()! MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 41,
      "chunk_id": "p41c3",
      "title": "Diskussion: Schnelle Prozesserzeugung Das Kopieren des Adressraums kostet viel Zeit Insbesondere b",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: Schnelle Prozesserzeugung Heutige Lösung: copyonwrite Mit Hilfe der MMU teilen sich Elternund Kindprozess dasselbe Codeund Datensegment. Erst wenn der Kindprozess Daten ändert, wird das Segment kopiert Wenn nach dem fork() direkt ein exec..() folgt, kommt das nicht vor fork() mit copyonwrite ist kaum langsamer als vfork() MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 42,
      "chunk_id": "p42c1",
      "title": "Diskussion: Schnelle Prozesserzeugung Heutige Lösung: copyonwrite Mit Hilfe der MMU teilen sich El",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIXProzesse im Detail: _exit() System Call: void _exit (int) Terminiert den laufenden Prozess und übergibt das Argument als „exit status“ an den Elternprozess Aufruf kehrt nicht zurück! Gibt die belegten Ressourcen des Prozesses frei offene Dateien, belegter Speicher, ..",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 43,
      "chunk_id": "p43c1",
      "title": "UNIXProzesse im Detail: _exit() System Call: void _exit (int) Terminiert den laufenden Prozess und ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Sendet dem eigenen Elternprozess das Signal SIGCHLD Die Bibliotheksfunktion exit (3) räumt zusätzlich noch die von der libc belegten Ressourcen auf Gepufferte Ausgaben werden beispielsweise herausgeschrieben! Normale Prozesse sollten exit (3) benutzen, nicht _exit MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 43,
      "chunk_id": "p43c2",
      "title": "UNIXProzesse im Detail: _exit() System Call: void _exit (int) Terminiert den laufenden Prozess und ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: Verwaiste Prozesse (engl. „orphan processes“) Ein UNIXProzess wird zum Waisenkind, wenn sein Elternprozess terminiert Was passiert mit der Prozesshierarchie? MOBS: 02Prozesse init (PID 1) adoptiert alle verwaisten Prozesse. So bleibt die Prozesshierarchie intakt.",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 44,
      "chunk_id": "p44c1",
      "title": "Diskussion: Verwaiste Prozesse (engl. „orphan processes“) Ein UNIXProzess wird zum Waisenkind, wenn",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIXProzesse im Detail: wait() System Call: pid_t wait (int *) Blockiert den aufrufenden Prozess bis ein Kindprozess terminiert. Der Rückgabewert ist dessen PID. Über das Zeigerargument erhält der Aufrufer u.a. den „exit status“ Wenn ein Kindprozess bereits terminiert ist, kehrt der Aufruf sofort zurück MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 45,
      "chunk_id": "p45c1",
      "title": "UNIXProzesse im Detail: wait() System Call: pid_t wait (int *) Blockiert den aufrufenden Prozess bi",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verwendung von wait() MOBS: 02Prozesse Ein Prozess kann auch von außen „getötet“ werden, d.h. er ruft nicht exit auf. In diesem Fall würde WIFEXITED 0 liefern.",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 46,
      "chunk_id": "p46c1",
      "title": "Verwendung von wait() MOBS: 02Prozesse Ein Prozess kann auch von außen „getötet“ werden, d.h. er ruf",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: Zombies Bevor der exit status eines terminierten Prozesses mit Hilfe von wait abgefragt wird, ist er ein „Zombie“ Die Ressourcen solcher Prozesse können freigegeben werden, aber die Prozessverwaltung muss sie noch kennen Insbesondere der exit status muss gespeichert werden MOBS: 02Prozesse Beispielprogramm von eben während der 5 Sekunden Wartezeit",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 47,
      "chunk_id": "p47c1",
      "title": "Diskussion: Zombies Bevor der exit status eines terminierten Prozesses mit Hilfe von wait abgefragt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Zombies werden von ps als <defunct> dargestellt.",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 47,
      "chunk_id": "p47c2",
      "title": "Diskussion: Zombies Bevor der exit status eines terminierten Prozesses mit Hilfe von wait abgefragt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Film vom 1968 Regie: G. A. Romero Wikipedia: In 1999 the Library of Congress entered it into the United States National Film Registry with other films deemed „historically, culturally or aesthetically important.“ Zombies… MOBS: 02Prozesse Quelle: Wikipedia (Public Domain)",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 48,
      "chunk_id": "p48c1",
      "title": "Film vom 1968 Regie: G. A. Romero Wikipedia: In 1999 the Library of Congress entered it into the U",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIXProzesse im Detail: _execve() System Call: int execve (const char *kommando, const char *args[ ], const char *envp[ ]) Lädt und startet das angegebene Kommando Der Aufruf kehrt nur im Fehlerfall zurück Der komplette Adressraum wird ersetzt Es handelt sich aber weiterhin um denselben Prozess! Selbe PID, PPID, offenen Dateien, ..",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 49,
      "chunk_id": "p49c1",
      "title": "UNIXProzesse im Detail: _execve() System Call: int execve (const char *kommando, const char *args[ ]",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Die libc biete einige komfortable Hilfsfunktionen, die intern execve aufrufen: execl, execv, execlp, execvp, ... MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 49,
      "chunk_id": "p49c2",
      "title": "UNIXProzesse im Detail: _execve() System Call: int execve (const char *kommando, const char *args[ ]",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verwendung von exec..() MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 50,
      "chunk_id": "p50c1",
      "title": "Verwendung von exec..() MOBS: 02Prozesse",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: Warum kein forkexec()? Durch die Trennung von fork und execve hat der Elternprozess mehr Kontrolle: Operationen im Kontext des Kindprozesses ausführen Voller Zugriff auf die Daten des Elternprozesses Shells nutzen diese Möglichkeit zum Beispiel zur... Umleitung der StandardE/AKanäle Aufsetzen von Pipes MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 51,
      "chunk_id": "p51c1",
      "title": "Diskussion: Warum kein forkexec()? Durch die Trennung von fork und execve hat der Elternprozess meh",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIXProzesszustände ein paar mehr als wir bisher kannten... MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 52,
      "chunk_id": "p52c1",
      "title": "UNIXProzesszustände ein paar mehr als wir bisher kannten... MOBS: 02Prozesse",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Abstraktionen – ein Überblick Prozesse konkret: UNIXProzessmodell Leichtgewichtige Prozessmodelle „Gewicht“ von Prozessen Leichtgewichtige Prozesse Federgewichtige Prozesse Systeme mit leichtgewichtigen Prozessen MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 53,
      "chunk_id": "p53c1",
      "title": "Inhalt Abstraktionen – ein Überblick Prozesse konkret: UNIXProzessmodell Leichtgewichtige Prozess",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Das „Gewicht“ von Prozessen Das Gewicht eines Prozesses ist ein bildlicher Ausdruck für die Größe seines Kontexts und damit die Zeit, die für einen Prozesswechsel benötigt wird CPUZuteilungsentscheidung alten Kontext sichern neuen Kontext laden Klassische UNIXProzesse sind „schwergewichtig“ MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 54,
      "chunk_id": "p54c1",
      "title": "Das „Gewicht“ von Prozessen Das Gewicht eines Prozesses ist ein bildlicher Ausdruck für die Größe s",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Leichtgewichtige Prozesse (Threads) Die 1:1Beziehung zwischen Kontrollfluss und Adressraum wird aufgebrochen Eng kooperierende Threads (deutsch „Fäden“) können sich einen Adressraum teilen (code + data + bss + heap, aber nicht stack!) MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 55,
      "chunk_id": "p55c1",
      "title": "Leichtgewichtige Prozesse (Threads) Die 1:1Beziehung zwischen Kontrollfluss und Adressraum wird auf",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Leichtgewichtige Prozesse (Threads) Vorteile: Aufwändige Operationen können in einen leichtgewichtigen Hilfsprozess ausgelagert werden, während der Elternprozess erneut auf Eingabe reagieren kann Typisches Beispiel: Webserver Programme, die aus mehreren unabhängigen Kontrollflüssen bestehen, profitieren unmittelbar von MultiprozessorHardware Schneller Kontextwechsel, wenn man im selben",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 56,
      "chunk_id": "p56c1",
      "title": "Leichtgewichtige Prozesse (Threads) Vorteile: Aufwändige Operationen können in einen leichtgewicht",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "profitieren unmittelbar von MultiprozessorHardware Schneller Kontextwechsel, wenn man im selben Adressraum bleibt Je nach Scheduler eventuell mehr Rechenzeit Nachteil: Programmierung ist schwierig: Zugriff auf gemeinsame Daten muss koordiniert werden MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 56,
      "chunk_id": "p56c2",
      "title": "Leichtgewichtige Prozesse (Threads) Vorteile: Aufwändige Operationen können in einen leichtgewicht",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Federgewichtige Prozesse (engl. UserLevel Threads) Werden komplett auf der Anwendungsebene implementiert. Das Betriebssystem weiß nichts davon Realisiert durch Bibliothek: UserLevel Thread Package MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 57,
      "chunk_id": "p57c1",
      "title": "Federgewichtige Prozesse (engl. UserLevel Threads) Werden komplett auf der Anwendungsebene implemen",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Federgewichtige Prozesse Vorteile: Extrem schneller Kontextwechsel: Nur wenige Prozessorregister sind auszutauschen",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 58,
      "chunk_id": "p58c1",
      "title": "Federgewichtige Prozesse Vorteile: Extrem schneller Kontextwechsel: Nur wenige Prozessorregister s",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Ein Trap in den Kern entfällt Jede Anwendung kann sich das passende ThreadPackage wählen Nachteile: Blockierung eines federgewichtigen Prozesses führt zur Blockierung des ganzen Programms Kein Geschwindigkeitsvorteil durch MultiProzessoren Kein zusätzlicher Rechenzeitanteil MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 58,
      "chunk_id": "p58c2",
      "title": "Federgewichtige Prozesse Vorteile: Extrem schneller Kontextwechsel: Nur wenige Prozessorregister s",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Abstraktionen – ein Überblick Prozesse konkret: UNIXProzessmodell Leichtgewichtige Prozessmodelle Systeme mit leichtgewichtigen Prozessen Windows Linux MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 59,
      "chunk_id": "p59c1",
      "title": "Inhalt Abstraktionen – ein Überblick Prozesse konkret: UNIXProzessmodell Leichtgewichtige Prozess",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Threads in Windows (1) MOBS: 02Prozesse Ein Prozess enthält 1 bis N Threads, die auf denselben globalen Daten operieren.",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 60,
      "chunk_id": "p60c1",
      "title": "Threads in Windows (1) MOBS: 02Prozesse Ein Prozess enthält 1 bis N Threads, die auf denselben globa",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Threads in Windows (2) Prozess: Umgebung und Adressraum für Threads Ein Win32Prozess enthält immer mindestens 1 Thread Thread: Code ausführende Einheit Jeder Thread verfügt über einen eigenen Stack und Registersatz (insbesondere PC) Threads bekommen vom Scheduler Rechenzeit zugeteilt Alle Threads sind KernelLevel Threads UserLevel Threads möglich („Fibers“), aber unüblich Strategie: Anzahl",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 61,
      "chunk_id": "p61c1",
      "title": "Threads in Windows (2) Prozess: Umgebung und Adressraum für Threads Ein Win32Prozess enthält immer",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "sind KernelLevel Threads UserLevel Threads möglich („Fibers“), aber unüblich Strategie: Anzahl der Threads gering halten Überlappte (asynchrone) E/A MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 61,
      "chunk_id": "p61c2",
      "title": "Threads in Windows (2) Prozess: Umgebung und Adressraum für Threads Ein Win32Prozess enthält immer",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Threads in Linux Linux implementiert POSIX Threads in Form der pthreadBibliothek Möglich macht das ein Linuxspezifischer System Call MOBS: 02Prozesse Für Linux sind alle Threads und Prozesse intern „Tasks“ Der Scheduler macht also keinen Unterschied",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 62,
      "chunk_id": "p62c1",
      "title": "Threads in Linux Linux implementiert POSIX Threads in Form der pthreadBibliothek Möglich macht das",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Zusammenfassung Prozesse sind die zentrale Abstraktion für Aktivitäten in heutigen Betriebssystemen UNIXSysteme stellen diverse System Calls zur Verfügung, um Prozesse zu erzeugen, zu verwalten und miteinander zu verknüpfen alles im Sinne der Philosophie: „Do one thing, do it well.“ Leichtgewichtige Fadenmodelle haben viele Vorteile in UNIXSystemen bis in die 90er Jahre nicht verfügbar in",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 63,
      "chunk_id": "p63c1",
      "title": "Zusammenfassung Prozesse sind die zentrale Abstraktion für Aktivitäten in heutigen Betriebssystemen",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Fadenmodelle haben viele Vorteile in UNIXSystemen bis in die 90er Jahre nicht verfügbar in Windows von Beginn an (ab NT) integraler Bestandteil MOBS: 02Prozesse",
    "metadata": {
      "source": "MOBS_02_Prozesse.pdf",
      "page": 63,
      "chunk_id": "p63c2",
      "title": "Zusammenfassung Prozesse sind die zentrale Abstraktion für Aktivitäten in heutigen Betriebssystemen",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – 01 Einführung mit Material von Olaf Spinczyk (Universität Osnabrück) und Horst Schirmeier (TU Dresden)",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 1,
      "chunk_id": "p1c1",
      "title": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – 01 Einführung mit Material von Olaf Spinczyk (Uni",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Organisatorisches ▪Was ist ein Betriebssystem? ▪Grundlagen und Begriffe ▪Die Entwicklung von (modernen) Betriebssystemen ▪Vom Webstuhl zum Smartphone MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 2,
      "chunk_id": "p2c1",
      "title": "Inhalt ▪Organisatorisches ▪Was ist ein Betriebssystem? ▪Grundlagen und Begriffe ▪Die Entwicklung von",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Organisatorisches ▪Was ist ein Betriebssystem? ▪Grundlagen und Begriffe ▪Die Entwicklung von (modernen) Betriebssystemen ▪Vom Webstuhl zum Smartphone MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 3,
      "chunk_id": "p3c1",
      "title": "Inhalt ▪Organisatorisches ▪Was ist ein Betriebssystem? ▪Grundlagen und Begriffe ▪Die Entwicklung von",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "VorstellungIch MOBS: 01Einführung BWL Informatik Bachelor BWL Uni Mannheim Master Wirtschaftsinformatik Uni Mannheim PhD Uni Mannheim Prof. Dr. Christian Becker (Distributed Systems, Pervasive Computing) National Taiwan University, Taipei University of Alberta, Edmonton University of British Columbia, Vancouver Hong Kong Polytechnic University, HK Janick",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 4,
      "chunk_id": "p4c1",
      "title": "VorstellungIch MOBS: 01Einführung BWL Informatik Bachelor BWL Uni Mannheim Master Wirtschaftsinforma",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Vorstellung MOBS: 01Einführung • Wissenschaftliche Hilfskräfte mit MOBSErfahrung • Unterstützen bei Organisation & Übungsblättern • Ansprechpartner/innen für Übungsblätter • Durchführung des freiwilligen Tutoriums Liviana & Luis • Wissenschaftlicher Mitarbeiter bei DOS • Kann auch ziemlich gut ML • Wird eine oder mehrere Übungen leiten Hassan",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 5,
      "chunk_id": "p5c1",
      "title": "Vorstellung MOBS: 01Einführung • Wissenschaftliche Hilfskräfte mit MOBSErfahrung • Unterstützen bei ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Studiengang VorstellungIhr MOBS: 01Einführung Semester 10+ 3 1 Computing in Science Informatik MenschComputerInteraktion SystemSystemEntwicklung Wirtschaftsinformatik Lehramt",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 6,
      "chunk_id": "p6c1",
      "title": "Studiengang VorstellungIhr MOBS: 01Einführung Semester 10+ 3 1 Computing in Science Informatik Mensc",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Organisatorisches MOBS: 01Einführung ▪Das Modul besteht aus zwei Teilen ▪Vorlesung (montags, 10:00 – 11:30 Uhr, Raum G021/022) https://unihamburg.zoom.us/j/61220778193?pwd=NWVOMkdSQ2JMNEhRMm11Qk55TEJwUT09 ▪Übung (dienstags, 10:15 – 11:45 Uhr, Raum G021/022) https://unihamburg.zoom.us/j/61220778193?pwd=NWVOMkdSQ2JMNEhRMm11Qk55TEJwUT09 ▪Materialien, Abgaben, Kommunikation: Moodle ▪Kursname: Moderne",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 7,
      "chunk_id": "p7c1",
      "title": "Organisatorisches MOBS: 01Einführung ▪Das Modul besteht aus zwei Teilen ▪Vorlesung (montags, 10:00 –",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "▪Materialien, Abgaben, Kommunikation: Moodle ▪Kursname: Moderne Betriebssysteme https://lernen.min.unihamburg.de/course/view.php?id=5391",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 7,
      "chunk_id": "p7c2",
      "title": "Organisatorisches MOBS: 01Einführung ▪Das Modul besteht aus zwei Teilen ▪Vorlesung (montags, 10:00 –",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "MOBS: 01Einführung Woche Zeitraum Vorlesung Übung Kommentar 07.04. – 13.04. G021/022 G021/022 14.04. – 20.04. G021/022 G021/022 Übung: Hassan 21.04. – 27.04. fällt aus fällt aus Ostermontag 28.04. – 04.05. G021/022 G021/022 05.05. – 11.05. G021/022 G021/022 12.05. – 18.05. G021/022 G021/022 19.05. – 25.05. G021/022 G021/022 26.05. – 01.06. fällt aus fällt aus Pfingstferien 02.06. – 08.06",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 8,
      "chunk_id": "p8c1",
      "title": "MOBS: 01Einführung Woche Zeitraum Vorlesung Übung Kommentar 07.04. – 13.04. G021/022 G021/022 14.04.",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". – 25.05. G021/022 G021/022 26.05. – 01.06. fällt aus fällt aus Pfingstferien 02.06. – 08.06. G021/022 G021/022 09.06. – 15.06. G021/022 G021/022 16.06. – 22.06. G021/022 G021/022 23.06. – 29.06. G021/022 G021/022 30.06. – 06.07. G021/022 G021/022 07.07. – 13.07. G021/022 G021/022 14.07. – 20.07. G021/022 G021/022 Klausur 22.07. / 11.09. (vsl.) ESA A / Phil B Beide Termine: 09:30 – 11:30 Uhr",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 8,
      "chunk_id": "p8c2",
      "title": "MOBS: 01Einführung Woche Zeitraum Vorlesung Übung Kommentar 07.04. – 13.04. G021/022 G021/022 14.04.",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Lernziele der Vorlesung ▪Grundlagenwissen über Betriebssysteme erwerben ▪Funktionsweise und Struktur ▪Algorithmen und Implementierung ▪Vielfalt und Unterschiede der Betriebssysteme kennen ▪Spezialzwecksysteme, Vielzwecksysteme, Systeme von Systemen ▪Verständnis der Vorgänge in einem Rechnersystem ▪Schnittstelle der Systemsoftware zur Hardware MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 9,
      "chunk_id": "p9c1",
      "title": "Lernziele der Vorlesung ▪Grundlagenwissen über Betriebssysteme erwerben ▪Funktionsweise und Struktur",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Lernziele der Vorlesung (und Übung) ▪Erfahrung mit systemnaher Programmierung sammeln ▪Systemschnittstelle von UNIX (Linux) ▪Programmiersprache C ▪Aktuelle Trends und Herausforderungen kennen MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 10,
      "chunk_id": "p10c1",
      "title": "Lernziele der Vorlesung (und Übung) ▪Erfahrung mit systemnaher Programmierung sammeln ▪Systemschnitt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Voraussetzungen ▪Grundkenntnisse aus Vorlesungen ▪Rechnerstrukturen (optional) ▪Programmierkenntnisse (beliebige Sprache) ▪Neugier ▪Spaß am Tüfteln MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 11,
      "chunk_id": "p11c1",
      "title": "Voraussetzungen ▪Grundkenntnisse aus Vorlesungen ▪Rechnerstrukturen (optional) ▪Programmierkenntniss",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt der Vorlesung ▪Kontrollflussabstraktionen: Prozesse, Threads ▪Prozessorzuteilung (engl. “Scheduling”) ▪Kooperation und Konkurrenz von Kontrollflüssen: Synchronisation, Deadlocks ▪Verwaltung und Virtualisierung des Hauptspeichers ▪Einund Ausgabe ▪Dateisysteme MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 12,
      "chunk_id": "p12c1",
      "title": "Inhalt der Vorlesung ▪Kontrollflussabstraktionen: Prozesse, Threads ▪Prozessorzuteilung (engl. “Sche",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt der Übung ▪Einführung in C ▪Systemnahe Programmierung unter UNIX ▪Aufgabenblätter ▪Abgabe freiwillig aber Inhalt klausurrelevant ▪Abgaben werden (automatisiert) bepunktet ▪LiveWettbewerbe ▪Pseudonymisierte Bestenliste online ▪Gewinner: Ruhm, Ehre, Teilnahme an Fachgruppentreffen MOBS: 01Einführung Mehr Informationen in der Übung am Dienstag",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 13,
      "chunk_id": "p13c1",
      "title": "Inhalt der Übung ▪Einführung in C ▪Systemnahe Programmierung unter UNIX ▪Aufgabenblätter ▪Abgabe fre",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prüfung ▪Klausur am Ende des Semesters ▪geplant: 22.07. & 11.09. ▪Relevant: Vorlesungsund Übungsstoff ▪In Präsenz ▪Fokus auf Anwendungsaufgaben ▪Inhalte und mögliche Aufgabentypen werden im Laufe des Semesters besprochen (und trainiert) MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 14,
      "chunk_id": "p14c1",
      "title": "Prüfung ▪Klausur am Ende des Semesters ▪geplant: 22.07. & 11.09. ▪Relevant: Vorlesungsund Übungsstof",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Empfohlene Literatur ▪[1] A. Silberschatz et al. Operating System Concepts (8th Ed.). Wiley, 2008. ISBN10: ▪[2] A. Tanenbaum, H. Bos Moderne Betriebssysteme (4. Aufl.). Pearson, 2016. ISBN 9783868942705 ▪[3] J. Gustedt Modern C. Manning, 2019. ISBN 9781617295812 https://modernc.gforge.inria.fr/ ▪[4] R. Stevens et al. Advanced Programming in the UNIX Environment (3rd Ed.), AddisonWesley, 2013",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 15,
      "chunk_id": "p15c1",
      "title": "Empfohlene Literatur ▪[1] A. Silberschatz et al. Operating System Concepts (8th Ed.). Wiley, 2008. I",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Stevens et al. Advanced Programming in the UNIX Environment (3rd Ed.), AddisonWesley, 2013. ISBN10: 0321637739 MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 15,
      "chunk_id": "p15c2",
      "title": "Empfohlene Literatur ▪[1] A. Silberschatz et al. Operating System Concepts (8th Ed.). Wiley, 2008. I",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Organisatorisches ▪Was ist ein Betriebssystem? ▪Grundlagen und Begriffe ▪Die Entwicklung von (modernen) Betriebssystemen ▪Vom Webstuhl zum Smartphone MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 16,
      "chunk_id": "p16c1",
      "title": "Inhalt ▪Organisatorisches ▪Was ist ein Betriebssystem? ▪Grundlagen und Begriffe ▪Die Entwicklung von",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Los geht‘s… MOBS: 01Einführung Was ist ein Betriebssystem?",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 17,
      "chunk_id": "p17c1",
      "title": "Los geht‘s… MOBS: 01Einführung Was ist ein Betriebssystem?",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Definitionen (1) „Ein Computer ist, wenn er genau betrachtet wird, nur eine Ansammlung von Plastik und Metall, das zur Leitung von Strom benötigt wird. Dieser „Industriemüll“ kann somit nicht ausschließlich das sein, was wir unter einem modernen Computer verstehen, etwas, das dem Computer „Leben“ einhaucht und ihn zu dem Werkzeug unseres Jahrhunderts macht",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 18,
      "chunk_id": "p18c1",
      "title": "Definitionen (1) „Ein Computer ist, wenn er genau betrachtet wird, nur eine Ansammlung von Plastik u",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Es ist das Betriebssystem, das die Kontrolle über das Plastik und Metall (Hardware) übernimmt und anderen Softwareprogrammen (Excel, Word, … ) eine standardisierte Arbeitsplattform (Windows, Unix, OS/2) schafft.“ – Ewert et al., Literatur zu „Freehand 10“ MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 18,
      "chunk_id": "p18c2",
      "title": "Definitionen (1) „Ein Computer ist, wenn er genau betrachtet wird, nur eine Ansammlung von Plastik u",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Definitionen (2) „Be'triebs·sys·tem Programmbündel, das die Bedienung eines Computers ermöglicht.“ – Universalwörterbuch Rechtschreibung MOBS: 01Einführung „Summe derjenigen Programme, die als residenter Teil einer EDVAnlage für den Betrieb der Anlage und für die Ausführung der Anwenderprogramme erforderlich ist.“ – Lexikon der Informatik „Die Programme eines digitalen Rechensystems, die zusammen",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 19,
      "chunk_id": "p19c1",
      "title": "Definitionen (2) „Be'triebs·sys·tem Programmbündel, das die Bedienung eines Computers ermöglicht.“ –",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "ist.“ – Lexikon der Informatik „Die Programme eines digitalen Rechensystems, die zusammen mit den Eigenschaften der Rechenanlage die Grundlage der möglichen Betriebsarten des digitalen Rechensystems bilden und insbesondere die Abwicklung von Programmen steuern und überwachen.“ – DIN 44300",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 19,
      "chunk_id": "p19c2",
      "title": "Definitionen (2) „Be'triebs·sys·tem Programmbündel, das die Bedienung eines Computers ermöglicht.“ –",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Definitionen (3) „Ein Programm das als Vermittler zwischen Rechnerbenutzer und Rechnerhardware fungiert",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 20,
      "chunk_id": "p20c1",
      "title": "Definitionen (3) „Ein Programm das als Vermittler zwischen Rechnerbenutzer und Rechnerhardware fungi",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Der Sinn des Betriebssystems ist eine Umgebung bereitzustellen, in der Benutzer bequem und effizient Programme ausführen können.“ – Silberschatz [1] MOBS: 01Einführung „Eine Softwareschicht, die alle Teile des Systems verwaltet und dem Benutzer eine Schnittstelle oder virtuelle Maschine anbietet, die leichter zu verstehen und zu programmieren ist [als die nackte Hardware].“ – Tanenbaum [2]",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 20,
      "chunk_id": "p20c2",
      "title": "Definitionen (3) „Ein Programm das als Vermittler zwischen Rechnerbenutzer und Rechnerhardware fungi",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Definitionen (3) „Ein Programm das als Vermittler zwischen Rechnerbenutzer und Rechnerhardware fungiert",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 21,
      "chunk_id": "p21c1",
      "title": "Definitionen (3) „Ein Programm das als Vermittler zwischen Rechnerbenutzer und Rechnerhardware fungi",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Der Sinn des Betriebssystems ist eine Umgebung bereitzustellen, in der Benutzer bequem und effizient Programme ausführen können.“ – Silberschatz [1] MOBS: 01Einführung „Eine Softwareschicht, die alle Teile des Systems verwaltet und dem Benutzer eine Schnittstelle oder virtuelle Maschine anbietet, die leichter zu verstehen und zu programmieren ist [als die nackte Hardware].“ – Tanenbaum [2] Aus:",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 21,
      "chunk_id": "p21c2",
      "title": "Definitionen (3) „Ein Programm das als Vermittler zwischen Rechnerbenutzer und Rechnerhardware fungi",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "die leichter zu verstehen und zu programmieren ist [als die nackte Hardware].“ – Tanenbaum [2] Aus: Moderne Betriebssysteme, A",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 21,
      "chunk_id": "p21c3",
      "title": "Definitionen (3) „Ein Programm das als Vermittler zwischen Rechnerbenutzer und Rechnerhardware fungi",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Tanenbaum, 2009",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 21,
      "chunk_id": "p21c4",
      "title": "Definitionen (3) „Ein Programm das als Vermittler zwischen Rechnerbenutzer und Rechnerhardware fungi",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Vielfalt der Anforderungen MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 22,
      "chunk_id": "p22c1",
      "title": "Vielfalt der Anforderungen MOBS: 01Einführung",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Zwischenfazit ▪Es gibt viele Auslegungen des Begriffs „Betriebssystem“ ▪Festhalten kann man: ▪Das Betriebssystem dient den Anwendern bzw. deren Anwendungsprogramm(en) und nie dem Selbstzweck ▪Es muss die Hardware genau kennen und den Anwendungen geeignete Abstraktionen zur Verfügung stellen MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 23,
      "chunk_id": "p23c1",
      "title": "Zwischenfazit ▪Es gibt viele Auslegungen des Begriffs „Betriebssystem“ ▪Festhalten kann man: ▪Das Be",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Zwischenfazit ▪Hardware und Anwendungsanforderungen bestimmen die Dienste des Betriebssystems ▪Struktur und Funktionsweise ergeben sich entsprechend ▪Um zu verstehen, welche Hardwareabstraktionen Betriebssysteme heute anbieten, muss man ihre Entwicklungsgeschichte im Zusammenhang mit der Hardwareentwicklung und typischen Anwendungen betrachten MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 24,
      "chunk_id": "p24c1",
      "title": "Zwischenfazit ▪Hardware und Anwendungsanforderungen bestimmen die Dienste des Betriebssystems ▪Struk",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Organisatorisches ▪Was ist ein Betriebssystem? ▪Grundlagen und Begriffe ▪Die Entwicklung von (modernen) Betriebssystemen ▪Vom Webstuhl zum Smartphone MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 25,
      "chunk_id": "p25c1",
      "title": "Inhalt ▪Organisatorisches ▪Was ist ein Betriebssystem? ▪Grundlagen und Begriffe ▪Die Entwicklung von",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Am Anfang stand die Lochkarte ▪Es gibt sie schon seit 1725 zur Webstuhlsteuerung ▪Herman Hollerith nutzte sie 1890 für eine Volkszählung ▪aus seiner Firma und zwei weiteren ging später IBM hervor ▪Sie wurde bis in die 70er Jahre als vielseitiger Speicher eingesetzt (Kapazität: 80 Byte) MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 26,
      "chunk_id": "p26c1",
      "title": "Am Anfang stand die Lochkarte ▪Es gibt sie schon seit 1725 zur Webstuhlsteuerung ▪Herman Hollerith n",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Am Anfang stand die Lochkarte ▪Es gibt sie schon seit 1725 zur Webstuhlsteuerung ▪Herman Hollerith nutzte sie 1890 für eine Volkszählung ▪aus seiner Firma und zwei weiteren ging später IBM hervor ▪Sie wurde bis in die 70er Jahre als vielseitiger Speicher eingesetzt (Kapazität: 80 Byte) MOBS: 01Einführung 80MB 170m 2.500kg 1TB 2.125km 31.250t",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 27,
      "chunk_id": "p27c1",
      "title": "Am Anfang stand die Lochkarte ▪Es gibt sie schon seit 1725 zur Webstuhlsteuerung ▪Herman Hollerith n",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Erste elektronische Universalrechner MOBS: 01Einführung Ein Rechenmonster! ▪Größe: 10m x 17m x 2,7m ▪Gewicht: 27t ▪Leistung: 174kW (> 17.000 Röhren!) ▪Preis: 468.000 $ ▪Geschwindigkeit: 500 Additionen pro Sekunde",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 28,
      "chunk_id": "p28c1",
      "title": "Erste elektronische Universalrechner MOBS: 01Einführung Ein Rechenmonster! ▪Größe: 10m x 17m x 2,7m ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Serielle Verarbeitung (ab 1945) ▪Programmierung ▪i.d.R. in Maschinencode ▪Eingabe über Lochkartenleser, Ausgaben über Drucker ▪Fehleranzeige durch Kontrolllämpchen ▪Rechnerzeitzuteilung auf Papierterminkalender ▪Rechnerzeitverschwendung durch zu großzügige Reservierung oder Abbruch wegen Fehler MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 29,
      "chunk_id": "p29c1",
      "title": "Serielle Verarbeitung (ab 1945) ▪Programmierung ▪i.d.R. in Maschinencode ▪Eingabe über Lochkartenles",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Serielle Verarbeitung (ab 1945) ▪Minimale Auslastung der CPU ▪Die meiste Zeit verbrauchten langsame E/A Geräte (Lochkarten, Drucker) ▪Erste Systemsoftware in Form von Programmbibliotheken ▪Binder, Lader, Debugger, Gerätetreiber, … MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 30,
      "chunk_id": "p30c1",
      "title": "Serielle Verarbeitung (ab 1945) ▪Minimale Auslastung der CPU ▪Die meiste Zeit verbrauchten langsame ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Einfache Stapelsysteme (ab 1955) ▪Verringerten die Häufigkeit manueller Betriebseingriffe ▪Die ersten Betriebssysteme: „residente Monitore“ ▪Interpretation von JobSteuerbefehlen ▪Laden und Ausführen von Programmen ▪Geräteansteuerung MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 31,
      "chunk_id": "p31c1",
      "title": "Einfache Stapelsysteme (ab 1955) ▪Verringerten die Häufigkeit manueller Betriebseingriffe ▪Die erste",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Einfache Stapelsysteme (ab 1955) MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 32,
      "chunk_id": "p32c1",
      "title": "Einfache Stapelsysteme (ab 1955) MOBS: 01Einführung",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Einfache Stapelsysteme (ab 1955) ▪Probleme durch fehlerhafte Anwendungen: ▪Programm terminiert nicht ▪schreibt in den Speicherbereich des residenten Monitors ▪greift auf den Kartenleser direkt zu und interpretiert Steuerbefehle als Daten MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 33,
      "chunk_id": "p33c1",
      "title": "Einfache Stapelsysteme (ab 1955) ▪Probleme durch fehlerhafte Anwendungen: ▪Programm terminiert nicht",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Einfache Stapelsysteme (ab 1955) Lösungen: ▪Zeitgeberbaustein (timer) liefert Unterbrechungen (interrupts) ▪Fallen (traps) für fehlerhafte Programme ▪Schutzgatterregister (engl. fence register) realisiert primitiven Speicherschutz ▪Privilegierter Arbeitsmodus der CPU (supervisor mode) • Deaktivierung des Schutzgatters • Ein/Ausgabe MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 34,
      "chunk_id": "p34c1",
      "title": "Einfache Stapelsysteme (ab 1955) Lösungen: ▪Zeitgeberbaustein (timer) liefert Unterbrechungen (inter",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Der Ein/AusgabeFlaschenhals ▪Problem: CPU ist schneller als Kartenleser und Drucker ▪kostbare Rechenzeit wird durch (aktives) Warten verschwendet MOBS: 01Einführung ▪Lösung 1: Offline processing ▪dank Bandlaufwerken ▪Parallelisierung von Ein/ Ausgaben durch mehrere Satellitenrechner",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 35,
      "chunk_id": "p35c1",
      "title": "Der Ein/AusgabeFlaschenhals ▪Problem: CPU ist schneller als Kartenleser und Drucker ▪kostbare Rechen",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Der Ein/AusgabeFlaschenhals ▪Problem: CPU ist schneller als Kartenleser und Drucker ▪kostbare Rechenzeit wird durch (aktives) Warten verschwendet MOBS: 01Einführung ▪Lösung 2: Spooling ▪dank Plattenlaufwerken (wahlfreier Zugriff), Direct Memory Access und Unterbrechungen ▪Berechnungen und Ein/Ausgaben werden dabei parallelisiert ▪Regeln für Prozessorzuteilung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 36,
      "chunk_id": "p36c1",
      "title": "Der Ein/AusgabeFlaschenhals ▪Problem: CPU ist schneller als Kartenleser und Drucker ▪kostbare Rechen",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Mehrprogrammbetrieb (ab 1965) ▪Trotz spooling nutzt ein einzelnes Programm die CPU nicht effizient ▪CPUStöße (CPU bursts) und E/AStöße (I/O bursts), bei denen die CPU warten muss, wechseln sich ab ▪Beim Mehrprogrammbetrieb bearbeitet die CPU mehrere Aufträge gleichzeitig: MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 37,
      "chunk_id": "p37c1",
      "title": "Mehrprogrammbetrieb (ab 1965) ▪Trotz spooling nutzt ein einzelnes Programm die CPU nicht effizient ▪",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Mehrprogrammbetrieb (ab 1965) ▪Trotz spooling nutzt ein einzelnes Programm die CPU nicht effizient ▪CPUStöße (CPU bursts) und E/AStöße (I/O bursts), bei denen die CPU warten muss, wechseln sich ab ▪Beim Mehrprogrammbetrieb bearbeitet die CPU mehrere Aufträge gleichzeitig: MOBS: 01Einführung Das Betriebssystem wird immer komplexer: ▪Umgang mit nebenläufigen E/A Aktivitäten ▪Verwaltung des",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 38,
      "chunk_id": "p38c1",
      "title": "Mehrprogrammbetrieb (ab 1965) ▪Trotz spooling nutzt ein einzelnes Programm die CPU nicht effizient ▪",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Das Betriebssystem wird immer komplexer: ▪Umgang mit nebenläufigen E/A Aktivitäten ▪Verwaltung des Arbeitsspeichers für mehrere Programme ▪Interne Verwaltung von Programmen in Ausführung („Prozesse“) ▪Prozessorzuteilung (scheduling) ▪Mehrbenutzerbetrieb: Sicherheit und Abrechnung (accounting)",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 38,
      "chunk_id": "p38c2",
      "title": "Mehrprogrammbetrieb (ab 1965) ▪Trotz spooling nutzt ein einzelnes Programm die CPU nicht effizient ▪",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Mehrprogrammbetrieb (ab 1965) ▪Speicherverwaltung: ▪Den zu startenden Programmen muss dynamisch freier Speicher zugewiesen werden ▪Speicherschutz: ▪Einfaches Schutzgatter reicht nicht mehr, um einzelne Programme zu isolieren → Lösung: einfache MMU („Memory Management Unit“ ) ▪Prozessverwaltung: ▪Jedes „Programm in Ausführung“ besitzt einen Kontext",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 39,
      "chunk_id": "p39c1",
      "title": "Mehrprogrammbetrieb (ab 1965) ▪Speicherverwaltung: ▪Den zu startenden Programmen muss dynamisch frei",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Beim Prozesswechsel muss dieser ausgetauscht werden MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 39,
      "chunk_id": "p39c2",
      "title": "Mehrprogrammbetrieb (ab 1965) ▪Speicherverwaltung: ▪Den zu startenden Programmen muss dynamisch frei",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Dialogbetrieb (ab 1970) ▪Neue Einund Ausgabegeräte erlauben interaktive Software ▪Tastatur, Monitor, später Maus ▪TimeSharingBetrieb ▪ermöglicht akzeptable Antwortzeiten für interaktive Nutzer ▪ZeitgeberUnterbrechungen sorgen für Verdrängung (zu) lang laufender Prozesse ▪Systemprogramme erlauben auch interaktive SWEntwicklung ▪Editor, Shell, Übersetzer, Debugger ▪Platten und Dateisysteme erlauben",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 40,
      "chunk_id": "p40c1",
      "title": "Dialogbetrieb (ab 1970) ▪Neue Einund Ausgabegeräte erlauben interaktive Software ▪Tastatur, Monitor,",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "interaktive SWEntwicklung ▪Editor, Shell, Übersetzer, Debugger ▪Platten und Dateisysteme erlauben jederzeit Zugriff auf Programme und Daten MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 40,
      "chunk_id": "p40c2",
      "title": "Dialogbetrieb (ab 1970) ▪Neue Einund Ausgabegeräte erlauben interaktive Software ▪Tastatur, Monitor,",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Personal Computer (ab 1980) ▪Technologischer Fortschritt ermöglicht PCs ▪Privatpersonen können eigenen Computer besitzen",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 41,
      "chunk_id": "p41c1",
      "title": "Personal Computer (ab 1980) ▪Technologischer Fortschritt ermöglicht PCs ▪Privatpersonen können eigen",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". ▪MULTICS → UNIX → POSIX (IEEE Standard) → LINUX ▪1974 entwickelt Intel den 8080, die erste Allzweck8BitCPU ▪Suche nach Betriebssystem führt zu Bill Gates und MSDOS ▪Erste Entwicklung von graphischen Benutzeroberflächen (GUIs) ▪Erste Konzepte im Xerox Palo Alto Research Center (Xerox PARC) ▪Aufgegriffen und weiterentwickelt von Steve Jobs (Apple Macintosh) ▪Später auch in Windows als Nachfolger",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 41,
      "chunk_id": "p41c2",
      "title": "Personal Computer (ab 1980) ▪Technologischer Fortschritt ermöglicht PCs ▪Privatpersonen können eigen",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "und weiterentwickelt von Steve Jobs (Apple Macintosh) ▪Später auch in Windows als Nachfolger von MSDOS MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 41,
      "chunk_id": "p41c3",
      "title": "Personal Computer (ab 1980) ▪Technologischer Fortschritt ermöglicht PCs ▪Privatpersonen können eigen",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Mobile Geräte (ab 1990) ▪Ubiquitous Computing ▪„Im 21",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 42,
      "chunk_id": "p42c1",
      "title": "Mobile Geräte (ab 1990) ▪Ubiquitous Computing ▪„Im 21. Jahrhundert wird die technologische Revolutio",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Jahrhundert wird die technologische Revolution das Alltägliche, Kleine und Unsichtbare sein.“ – Mark Weiser, The Computer for the 21st Century MOBS: 01Einführung ▪Tragbare Geräte ▪Erste Kombinationen aus Telefonen und Computern (Personal Digital AssistantPDA) ▪Der Begriff Smartphone wird 1997 von Ericsson geprägt ▪Erstes erfolgreiche mobile Betriebssystem: Symbian für Samsung, Sony Ericsson,",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 42,
      "chunk_id": "p42c2",
      "title": "Mobile Geräte (ab 1990) ▪Ubiquitous Computing ▪„Im 21. Jahrhundert wird die technologische Revolutio",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Ericsson geprägt ▪Erstes erfolgreiche mobile Betriebssystem: Symbian für Samsung, Sony Ericsson, Nokia, … ▪Heute: Android (72%) und iOS (28%), Samsung, Windows, KaiOS (alle < 0,5%)",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 42,
      "chunk_id": "p42c3",
      "title": "Mobile Geräte (ab 1990) ▪Ubiquitous Computing ▪„Im 21. Jahrhundert wird die technologische Revolutio",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Weitere Entwicklung der Systeme (Hardware, Betriebssysteme und Anwendungen “Hand in Hand”) MOBS: 01Einführung Spezialzwecksysteme ▪ Eingebettete Systeme ▪ Sensorknoten ▪ Hochleistungsrechnen Systeme von Systemen ▪ Virtuelle Systeme ▪ Cloud Computing ▪ Internet of Things Vielzwecksysteme ▪ Server ▪ Personal Computer ▪ Smartphones Erste Systeme ▪ „Stapelverarbeitung“ ▪ Dialogbetrieb Beliebige",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 43,
      "chunk_id": "p43c1",
      "title": "Weitere Entwicklung der Systeme (Hardware, Betriebssysteme und Anwendungen “Hand in Hand”) MOBS: 01E",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "▪ Personal Computer ▪ Smartphones Erste Systeme ▪ „Stapelverarbeitung“ ▪ Dialogbetrieb Beliebige Anwendungen …und der Vorlesung Genau eine Anwendung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 43,
      "chunk_id": "p43c2",
      "title": "Weitere Entwicklung der Systeme (Hardware, Betriebssysteme und Anwendungen “Hand in Hand”) MOBS: 01E",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Zusammenfassung ▪Betriebssysteme erfüllen hauptsächlich zwei Aufgaben: ▪Sie bieten Anwendungsprogrammierer/innen „schöne“ Abstraktionen ▪Sie verwalten die Hardware und teilen Ressourcen zu ▪Betriebssysteme sind weit mehr als nur Windows, Linux und MacOS ▪Zahlreiche spezialisierte Systeme haben unterschiedlichste Anwendungen ▪Die Entwicklung von Betriebssystemen ist eng gekoppelt an die Entwicklung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 44,
      "chunk_id": "p44c1",
      "title": "Zusammenfassung ▪Betriebssysteme erfüllen hauptsächlich zwei Aufgaben: ▪Sie bieten Anwendungsprogram",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Anwendungen ▪Die Entwicklung von Betriebssystemen ist eng gekoppelt an die Entwicklung von Hardware ▪Ein Verständnis von Betriebssystemen hilft, den eigenen Computer besser zu verstehen MOBS: 01Einführung",
    "metadata": {
      "source": "MOBS_01_Einführung.pdf",
      "page": 44,
      "chunk_id": "p44c2",
      "title": "Zusammenfassung ▪Betriebssysteme erfüllen hauptsächlich zwei Aufgaben: ▪Sie bieten Anwendungsprogram",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – 03 Scheduling mit Material von Olaf Spinczyk (Universität Osnabrück) und Horst Schirmeier (TU Dortmund)",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 1,
      "chunk_id": "p1c1",
      "title": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – 03 Scheduling mit Material von Olaf Spinczyk (Uni",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Abfertigungszustände und Zustandsübergänge ▪Klassische CPUZuteilungsstrategien ▪Bewertungskriterien und Vergleich ▪Beispiele MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 2,
      "chunk_id": "p2c1",
      "title": "Inhalt ▪Wiederholung ▪Abfertigungszustände und Zustandsübergänge ▪Klassische CPUZuteilungsstrategien",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Abfertigungszustände und Zustandsübergänge ▪Klassische CPUZuteilungsstrategien ▪Bewertungskriterien und Vergleich ▪Beispiele MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 3,
      "chunk_id": "p3c1",
      "title": "Inhalt ▪Wiederholung ▪Abfertigungszustände und Zustandsübergänge ▪Klassische CPUZuteilungsstrategien",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Wiederholung ▪Prozesse sind die zentrale Abstraktion für Aktivitäten in heutigen Betriebssystemen ▪Konzeptionell unabhängige sequentielle Kontrollflüsse (Folge von CPUund E/AStößen) ▪Tatsächlich findet ein Multiplexing der CPU statt ▪UNIXSysteme stellen diverse System Calls zur Verfügung, um Prozesse zu erzeugen, zu verwalten und miteinander zu verknüpfen ▪Moderne Betriebssysteme unterstützen",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 4,
      "chunk_id": "p4c1",
      "title": "Wiederholung ▪Prozesse sind die zentrale Abstraktion für Aktivitäten in heutigen Betriebssystemen ▪K",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "zu erzeugen, zu verwalten und miteinander zu verknüpfen ▪Moderne Betriebssysteme unterstützen darüber hinaus auch leichtund federgewichtige Prozesse ▪Prozesse unterliegen der Kontrolle des Betriebssystems ▪BetriebsmittelZuteilung ▪BetriebsmittelEntzug MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 4,
      "chunk_id": "p4c2",
      "title": "Wiederholung ▪Prozesse sind die zentrale Abstraktion für Aktivitäten in heutigen Betriebssystemen ▪K",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Abfertigungszustände und Zustandsübergänge ▪Klassische CPUZuteilungsstrategien ▪Bewertungskriterien und Vergleich ▪Beispiele MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 5,
      "chunk_id": "p5c1",
      "title": "Inhalt ▪Wiederholung ▪Abfertigungszustände und Zustandsübergänge ▪Klassische CPUZuteilungsstrategien",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Abfertigungszustand ▪Jedem Prozess ist in Abhängigkeit von der Einplanungsebene ein logischer Zustand zugeordnet, der den Abfertigungszustand zu einem Zeitpunkt angibt: ▪kurzfristig (shortterm scheduling) ▪bereit, laufend, blockiert ▪mittelfristig (mediumterm scheduling) ▪ausgelagert bereit, ausgelagert blockiert ▪langfristig (longterm scheduling) ▪erzeugt, beendet MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 6,
      "chunk_id": "p6c1",
      "title": "Abfertigungszustand ▪Jedem Prozess ist in Abhängigkeit von der Einplanungsebene ein logischer Zustan",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Kurzfristige Einplanung ▪bereit (READY) zur Ausführung durch den Prozessor (die CPU) ▪Der Prozess ist auf der Warteliste für die CPUZuteilung (ready list) ▪Seine Listenposition bestimmt sich durch das Einplanungsverfahren ▪laufend (RUNNING) Zuteilung des Betriebsmittels ”CPU“ ist erfolgt ▪Der Prozess führt Berechnungen durch, er vollzieht seinen CPUStoß ▪Für jeden Prozessor gibt es zu einem",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 7,
      "chunk_id": "p7c1",
      "title": "Kurzfristige Einplanung ▪bereit (READY) zur Ausführung durch den Prozessor (die CPU) ▪Der Prozess is",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prozess führt Berechnungen durch, er vollzieht seinen CPUStoß ▪Für jeden Prozessor gibt es zu einem Zeitpunkt nur einen laufenden Prozess ▪blockiert (BLOCKED) auf ein bestimmtes Ereignis ▪Der Prozess führt ”Ein/Ausgabe“ durch, er vollzieht seinen E/AStoß ▪Er erwartet die Erfüllung mindestens einer Bedingung MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 7,
      "chunk_id": "p7c2",
      "title": "Kurzfristige Einplanung ▪bereit (READY) zur Ausführung durch den Prozessor (die CPU) ▪Der Prozess is",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Mittelfristige Einplanung Ein Prozess ist komplett ausgelagert, d.h. der Inhalt seines gesamten Adressraums wurde in den Hintergrundspeicher verschoben (swapout) und der von dem Prozess belegte Vordergrundspeicher wurde freigegeben",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 8,
      "chunk_id": "p8c1",
      "title": "Mittelfristige Einplanung Ein Prozess ist komplett ausgelagert, d.h. der Inhalt seines gesamten Adre",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Die Einlagerung (swapin) des Adressraums ist abzuwarten: ▪ausgelagert bereit (READY SUSPEND) ▪Die CPUZuteilung (”bereit“) ist außer Kraft gesetzt ▪Der Prozess ist auf der Warteliste für die Speicherzuteilung ▪ausgelagert blockiert (BLOCKED SUSPEND) ▪Der Prozess erwartet weiterhin ein Ereignis (”blockiert“) ▪Tritt das Ereignis ein, wird der Prozess ”ausgelagert bereit“ MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 8,
      "chunk_id": "p8c2",
      "title": "Mittelfristige Einplanung Ein Prozess ist komplett ausgelagert, d.h. der Inhalt seines gesamten Adre",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Langfristige Einplanung ▪erzeugt (NEW) und fertig zur Programmverarbeitung fork(2) ▪Der Prozess ist instanziiert, ihm wurde ein Programm zugeordnet ▪Ggf. steht die Zuteilung des Betriebsmittels ”Speicher“ jedoch noch aus ▪beendet (EXIT) und erwartet die Entsorgung exit(2)/wait(2) ▪Der Prozess ist terminiert, seine Betriebsmittel werden freigegeben ▪Ggf",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 9,
      "chunk_id": "p9c1",
      "title": "Langfristige Einplanung ▪erzeugt (NEW) und fertig zur Programmverarbeitung fork(2) ▪Der Prozess ist ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". muss ein anderer Prozess den ”Kehraus“ vollenden (z. B. UNIX) MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 9,
      "chunk_id": "p9c2",
      "title": "Langfristige Einplanung ▪erzeugt (NEW) und fertig zur Programmverarbeitung fork(2) ▪Der Prozess ist ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Zustandsübergänge MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 10,
      "chunk_id": "p10c1",
      "title": "Zustandsübergänge MOBS: 03Scheduling",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Einplanungsund Auswahlzeitpunkt ▪Jeder Übergang in den Zustand bereit (READY) aktualisiert die CPUWarteschlange ▪Eine Entscheidung über die Einreihung des Prozesskontrollblocks wird getroffen ▪Das Ergebnis hängt von CPUZuteilungsstrategie des Systems ab ▪Einplanung/Umplanung (scheduling/rescheduling) erfolgt, . .",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 11,
      "chunk_id": "p11c1",
      "title": "Einplanungsund Auswahlzeitpunkt ▪Jeder Übergang in den Zustand bereit (READY) aktualisiert die CPUWa",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". . . ▪ nachdem ein Prozess erzeugt worden ist ▪ wenn ein Prozess freiwillig die Kontrolle über die CPU abgibt ▪ sofern das von einem Prozess erwartete Ereignis eingetreten ist ▪ sobald ein ausgelagerter Prozess wieder aufgenommen wird ▪Ein Prozess kann dazu gedrängt werden, die CPU abzugeben → präemptives Scheduling, auch ▪z.B. durch Zeitgeberunterbrechung MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 11,
      "chunk_id": "p11c2",
      "title": "Einplanungsund Auswahlzeitpunkt ▪Jeder Übergang in den Zustand bereit (READY) aktualisiert die CPUWa",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Abfertigungszustände und Zustandsübergänge ▪Klassische CPUZuteilungsstrategien ▪FCFS einfach ▪RR, VRR zeitscheibenbasiert ▪SPN (SJF), SRTF, HRRN vorhersagebasiert ▪FB (MLQ, MLFQ) prioritätenbasiert ▪Bewertungskriterien und Vergleich ▪Beispiele MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 12,
      "chunk_id": "p12c1",
      "title": "Inhalt ▪Wiederholung ▪Abfertigungszustände und Zustandsübergänge ▪Klassische CPUZuteilungsstrategien",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "FirstCome FirstServed – FCFS MOBS: 03Scheduling ▪Ein einfaches und gerechtes (?) Verfahren: ”wer zuerst kommt, mahlt zuerst“ ▪Einreihungskriterium ist die Ankunftszeit eines Prozesses ▪Arbeitet nichtverdrängend und setzt kooperative Prozesse voraus",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 13,
      "chunk_id": "p13c1",
      "title": "FirstCome FirstServed – FCFS MOBS: 03Scheduling ▪Ein einfaches und gerechtes (?) Verfahren: ”wer zue",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "FirstCome FirstServed – FCFS MOBS: 03Scheduling ▪Beispiel ▪Die normalisierte Durchlaufzeit (Tr /Ts) von C steht in einem sehr schlechten Verhältnis zur Bedienzeit Ts",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 14,
      "chunk_id": "p14c1",
      "title": "FirstCome FirstServed – FCFS MOBS: 03Scheduling ▪Beispiel ▪Die normalisierte Durchlaufzeit (Tr /Ts) ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: FCFS – „KonvoiEffekt“ MOBS: 03Scheduling ▪Mit dem Problem sind immer kurz laufende E/Alastige Prozesse konfrontiert, die langen CPUlastigen Prozessen folgen ▪Prozesse mit langen CPUStößen werden begünstigt ▪Prozesse mit kurzen CPUStößen werden benachteiligt ▪Das Verfahren minimiert die Zahl der Kontextwechsel",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 15,
      "chunk_id": "p15c1",
      "title": "Diskussion: FCFS – „KonvoiEffekt“ MOBS: 03Scheduling ▪Mit dem Problem sind immer kurz laufende E/Ala",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Der KonvoiEffekt verursacht allerdings folgende Probleme: ▪hohe Antwortzeit ▪niedriger E/ADurchsatz ▪Bei einem Mix von CPUund E/Alastigen Prozessen ist FCFS daher ungeeignet ▪Typischerweise nur in reinen Stapelverarbeitungssystemen",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 15,
      "chunk_id": "p15c2",
      "title": "Diskussion: FCFS – „KonvoiEffekt“ MOBS: 03Scheduling ▪Mit dem Problem sind immer kurz laufende E/Ala",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Round Robin – RR MOBS: 03Scheduling ▪Verringert die bei FCFS auftretende Benachteiligung kurzer CPUStöße: „Jeder gegen jeden“ ▪Die Prozessorzeit wird in Zeitscheiben aufgeteilt (time slicing) ▪Mit Ablauf der Zeitscheibe erfolgt ggf",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 16,
      "chunk_id": "p16c1",
      "title": "Round Robin – RR MOBS: 03Scheduling ▪Verringert die bei FCFS auftretende Benachteiligung kurzer CPUS",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". ein Prozesswechsel ▪Der unterbrochene Prozess wird ans Ende der Bereitliste verdrängt ▪Der nächste Prozess wird gemäß FCFS der Bereitliste entnommen ▪Basis für CPUSchutz: Zeitgeber bewirkt Unterbrechung am Ende der Zeitscheibe ▪Die Zeitscheibenlänge bestimmt maßgeblich die Effektivität des Verfahrens ▪zu lang, Degenerierung zu FCFS; zu kurz, sehr hoher Overhead ▪Faustregel: etwas länger als die",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 16,
      "chunk_id": "p16c2",
      "title": "Round Robin – RR MOBS: 03Scheduling ▪Verringert die bei FCFS auftretende Benachteiligung kurzer CPUS",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "▪zu lang, Degenerierung zu FCFS; zu kurz, sehr hoher Overhead ▪Faustregel: etwas länger als die Dauer einer ”typischen Interaktion“",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 16,
      "chunk_id": "p16c3",
      "title": "Round Robin – RR MOBS: 03Scheduling ▪Verringert die bei FCFS auftretende Benachteiligung kurzer CPUS",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: RR – Leistungsprobleme MOBS: 03Scheduling ▪E/Alastige Prozesse beenden ihren CPUStoß innerhalb ihrer Zeitscheibe ▪sie blockieren und kommen mit Ende ihres E/AStoßes in die Bereitliste ▪CPUlastige Prozesse schöpfen dagegen ihre Zeitscheibe voll aus ▪sie werden verdrängt und kommen sofort wieder in die Bereitliste ▪die CPUZeit ist zu Gunsten CPUlastiger Prozesse ungleich verteilt",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 17,
      "chunk_id": "p17c1",
      "title": "Diskussion: RR – Leistungsprobleme MOBS: 03Scheduling ▪E/Alastige Prozesse beenden ihren CPUStoß inn",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "sofort wieder in die Bereitliste ▪die CPUZeit ist zu Gunsten CPUlastiger Prozesse ungleich verteilt ▪E/Alastige Prozesse werden schlecht bedient und dadurch Geräte schlecht ausgelastet ▪die Varianz der Antwortzeit E/Alastiger Prozesse erhöht sich",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 17,
      "chunk_id": "p17c2",
      "title": "Diskussion: RR – Leistungsprobleme MOBS: 03Scheduling ▪E/Alastige Prozesse beenden ihren CPUStoß inn",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Virtual Round Robin – VRR MOBS: 03Scheduling ▪Vermeidet die bei RR mögliche ungleiche Verteilung der CPUZeiten ▪Prozesse kommen mit Ende ihrer E/AStöße in eine Vorzugsliste ▪Diese Liste wird vor der Bereitliste abgearbeitet ▪Das Verfahren arbeitet mit Zeitscheiben unterschiedlicher Längen ▪Prozesse der Vorzugsliste bekommen keine volle Zeitscheibe zugeteilt ▪Ihnen wird die Restlaufzeit ihrer",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 18,
      "chunk_id": "p18c1",
      "title": "Virtual Round Robin – VRR MOBS: 03Scheduling ▪Vermeidet die bei RR mögliche ungleiche Verteilung der",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "der Vorzugsliste bekommen keine volle Zeitscheibe zugeteilt ▪Ihnen wird die Restlaufzeit ihrer vorher nicht voll genutzten Zeit gewährt ▪Sollte ihr CPUStoß länger dauern, werden sie in die Bereitliste verdrängt",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 18,
      "chunk_id": "p18c2",
      "title": "Virtual Round Robin – VRR MOBS: 03Scheduling ▪Vermeidet die bei RR mögliche ungleiche Verteilung der",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Shortest Process Next – SPN MOBS: 03Scheduling ▪Verringert die bei FCFS auftretende Benachteiligung kurzer CPUStöße: „Die Kleinen nach vorne“ ▪Grundlage dafür ist die Kenntnis über die Prozesslaufzeiten ▪Verdrängung findet nicht statt ▪das Hauptproblem besteht in der Vorhersage der Laufzeiten ▪Stapelbetrieb: Programmierer geben das erforderliche time limit* vor ▪Dialogbetrieb: Schätzung der",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 19,
      "chunk_id": "p19c1",
      "title": "Shortest Process Next – SPN MOBS: 03Scheduling ▪Verringert die bei FCFS auftretende Benachteiligung ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "▪Stapelbetrieb: Programmierer geben das erforderliche time limit* vor ▪Dialogbetrieb: Schätzung der früheren Stoßlängen des Prozesses ▪Antwortzeiten werden wesentlich verkürzt und die Gesamtleistung steigt ▪Dafür: Gefahr der Aushungerung (starvation) CPUlastiger Prozesse *Die Zeitdauer, innerhalb der der Job (wahrscheinlich/ hoffentlich) beendet wird, bevor er abgebrochen wird.",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 19,
      "chunk_id": "p19c2",
      "title": "Shortest Process Next – SPN MOBS: 03Scheduling ▪Verringert die bei FCFS auftretende Benachteiligung ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: SPN – CPUStoßdauer MOBS: 03Scheduling ▪Mögliche Basis für die Schätzung ist die Mittelwertbildung über alle bisherigen CPUStoßlängen eines Prozesses: ▪Problem dieser Berechnung ist die gleiche Gewichtung aller CPUStöße ▪Jüngere CPUStöße sind jedoch von größerer Bedeutung als ältere und sollten daher auch mit größerer Gewichtung berücksichtigt werden ▪Ursache ist das Lokalitätsprinzip",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 20,
      "chunk_id": "p20c1",
      "title": "Diskussion: SPN – CPUStoßdauer MOBS: 03Scheduling ▪Mögliche Basis für die Schätzung ist die Mittelwe",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: SPN – Stoßgewichtung MOBS: 03Scheduling ▪Die weiter zurückliegenden CPUStöße sollen weniger Gewicht erhalten: ▪Für den konstanten Gewichtungsfaktor α gilt: 0 < α < 1 ▪Er drückt die relative Gewichtung einzelner CPUStöße der Zeitreihe aus ▪Rekursive Einsetzung führt zu ... ▪für α = 0.8:",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 21,
      "chunk_id": "p21c1",
      "title": "Diskussion: SPN – Stoßgewichtung MOBS: 03Scheduling ▪Die weiter zurückliegenden CPUStöße sollen weni",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: SPN – Stoßgewichtung MOBS: 03Scheduling ▪Die weiter zurückliegenden CPUStöße sollen weniger Gewicht erhalten: ▪Für den konstanten Gewichtungsfaktor α gilt: 0 < α < 1 ▪Er drückt die relative Gewichtung einzelner CPUStöße der Zeitreihe aus ▪Rekursive Einsetzung führt zu ... ▪für α = 0.8:",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 22,
      "chunk_id": "p22c1",
      "title": "Diskussion: SPN – Stoßgewichtung MOBS: 03Scheduling ▪Die weiter zurückliegenden CPUStöße sollen weni",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Shortest Remaining Time First – SRTF ▪Erweitert den SPNAnsatz um Verdrängung ▪Dadurch geeignet für den Dialogbetrieb ▪Führt zu besseren Durchlaufzeiten ▪Der laufende Prozess wird verdrängt, wenn gilt: Terw < Trest ▪Terw ist die erwartete CPUStoßlänge eines eintreffenden Prozesses ▪Trest ist die verbleibende CPUStoßlänge des laufenden Prozesses ▪Anders als RR basiert SRTF nicht auf",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 23,
      "chunk_id": "p23c1",
      "title": "Shortest Remaining Time First – SRTF ▪Erweitert den SPNAnsatz um Verdrängung ▪Dadurch geeignet für d",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "ist die verbleibende CPUStoßlänge des laufenden Prozesses ▪Anders als RR basiert SRTF nicht auf Zeitgeberunterbrechungen, ist aber präemptiv ▪Dafür müssen allerdings Stoßlängen abgeschätzt werden ▪Wie SPN kann auch SRTF Prozesse zum ”Verhungern“ bringen MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 23,
      "chunk_id": "p23c2",
      "title": "Shortest Remaining Time First – SRTF ▪Erweitert den SPNAnsatz um Verdrängung ▪Dadurch geeignet für d",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Highest Response Ratio Next – HRRN ▪Vermeidet das bei SRTF mögliche Verhungern von CPUlastigen Prozessen ▪Das Altern (aging), d.h. die Wartezeit von Prozessen wird berücksichtigt ▪w ist die bisherige ”Wartezeit des Prozesses“ ▪s ist die ”erwartete Bedienzeit“ ▪Ausgewählt wird immer der Prozess mit dem größten Verhältniswert R ▪Basiert wieder auf der Schätzung der Bedienzeit MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 24,
      "chunk_id": "p24c1",
      "title": "Highest Response Ratio Next – HRRN ▪Vermeidet das bei SRTF mögliche Verhungern von CPUlastigen Proze",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Feedback – FB ▪Begünstigt kurze Prozesse, ohne die relativen Längen der Prozesse abschätzen zu müssen ▪Grundlage ist die \"Bestrafung“ (penalization) von „Langläufern“ ▪Prozesse unterliegen dem Verdrängungsprinzip ▪Mehrere Bereitlisten kommen zum Einsatz, je nach Anzahl von Prioritätsebenen ▪Wenn ein Prozess erstmalig eintrifft, läuft er auf höchster Ebene ▪Mit Ablauf der Zeitscheibe kommt er in",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 25,
      "chunk_id": "p25c1",
      "title": "Feedback – FB ▪Begünstigt kurze Prozesse, ohne die relativen Längen der Prozesse abschätzen zu müsse",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prozess erstmalig eintrifft, läuft er auf höchster Ebene ▪Mit Ablauf der Zeitscheibe kommt er in die nächst niedrigere Ebene ▪Die unterste Ebene arbeitet nach RR ▪Kurze Prozesse laufen relativ schnell durch, lange Prozesse können verhungern ▪Die Wartezeit kann berücksichtigt werden, um wieder höhere Ebenen zu erreichen (antiaging) MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 25,
      "chunk_id": "p25c2",
      "title": "Feedback – FB ▪Begünstigt kurze Prozesse, ohne die relativen Längen der Prozesse abschätzen zu müsse",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "FB – SchedulingModell MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 26,
      "chunk_id": "p26c1",
      "title": "FB – SchedulingModell MOBS: 03Scheduling",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: Prioritäten ▪Ein Prozess“Vorrang“, der Zuteilungsentscheidungen maßgeblich beeinflusst ▪Statische Prioritäten werden zum Zeitpunkt der Prozesserzeugung festgelegt ▪Der Wert kann im weiteren Verlauf nicht mehr verändert werden ▪Das Verfahren erzwingt eine deterministische Ordnung zwischen Prozessen ▪Dynamische Prioritäten werden während der Prozesslaufzeit aktualisiert ▪Die",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 27,
      "chunk_id": "p27c1",
      "title": "Diskussion: Prioritäten ▪Ein Prozess“Vorrang“, der Zuteilungsentscheidungen maßgeblich beeinflusst ▪",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "zwischen Prozessen ▪Dynamische Prioritäten werden während der Prozesslaufzeit aktualisiert ▪Die Aktualisierung erfolgt im Betriebssystem, aber auch vom Benutzer aus ▪SPN, SRTF, HRRN und FB sind Spezialfälle dieses Verfahrens MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 27,
      "chunk_id": "p27c2",
      "title": "Diskussion: Prioritäten ▪Ein Prozess“Vorrang“, der Zuteilungsentscheidungen maßgeblich beeinflusst ▪",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Kombinationen – Multilevel Scheduling ▪Mehrere Betriebsformen lassen sich nebeneinander (”gleichzeitig“) betreiben ▪z.B. gleichzeitige Unterstützung von {Dialogund Hintergrundbetrieb} oder {Echtzeitund sonstigem Betrieb} ▪Dialogorientierte bzw",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 28,
      "chunk_id": "p28c1",
      "title": "Kombinationen – Multilevel Scheduling ▪Mehrere Betriebsformen lassen sich nebeneinander (”gleichzeit",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". zeitkritische Prozesse werden bevorzugt bedient ▪Die technische Umsetzung erfolgt typischerweise über mehrere Bereitlisten ▪Jeder Bereitliste ist eine bestimmte Zuteilungsstrategie zugeordnet ▪Die Listen werden typischerweise nach Priorität, FCFS oder RR verarbeitet ▪Ein höchst komplexes Gebilde ▪FB kann als Spezialfall dieses Verfahrens aufgefasst werden MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 28,
      "chunk_id": "p28c2",
      "title": "Kombinationen – Multilevel Scheduling ▪Mehrere Betriebsformen lassen sich nebeneinander (”gleichzeit",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Kombinationen – Multilevel Scheduling MOBS: 03Scheduling Quelle: Silberschatz",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 29,
      "chunk_id": "p29c1",
      "title": "Kombinationen – Multilevel Scheduling MOBS: 03Scheduling Quelle: Silberschatz",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Abfertigungszustände und Zustandsübergänge ▪Klassische CPUZuteilungsstrategien ▪Bewertungskriterien und Vergleich ▪Beispiele MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 30,
      "chunk_id": "p30c1",
      "title": "Inhalt ▪Wiederholung ▪Abfertigungszustände und Zustandsübergänge ▪Klassische CPUZuteilungsstrategien",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Ziele = Bewertungskriterien ▪Benutzerorientiert ▪Durchlaufzeit – Zeit zwischen Eingang und Abschluss eines Prozesses einschließlich der Wartezeit(en) → Stapelverarbeitung ▪Antwortzeit – Zeit zwischen Benutzereingabe und Antwort → interaktive Systeme ▪Termineinhaltung – Für die Interaktion mit äußeren physikalischen Prozessen sollten Termine eingehalten werden → Echtzeitsysteme ▪Vorhersagbarkeit –",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 31,
      "chunk_id": "p31c1",
      "title": "Ziele = Bewertungskriterien ▪Benutzerorientiert ▪Durchlaufzeit – Zeit zwischen Eingang und Abschluss",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "physikalischen Prozessen sollten Termine eingehalten werden → Echtzeitsysteme ▪Vorhersagbarkeit – Prozesse werden unabhängig von der Last immer gleich bearbeitet → harte Echtzeitsysteme MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 31,
      "chunk_id": "p31c2",
      "title": "Ziele = Bewertungskriterien ▪Benutzerorientiert ▪Durchlaufzeit – Zeit zwischen Eingang und Abschluss",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Ziele = Bewertungskriterien ▪Systemorientiert ▪Durchsatz – Möglichst viele Prozesse pro Zeiteinheit abarbeiten ▪CPUAuslastung – CPU sollte möglichst immer beschäftigt sein. Overhead (SchedulingEntscheidung, Kontextwechsel) vermeiden ▪Fairness – Kein Prozess soll benachteiligt werden (z.B. „Aushungern“) ▪Lastausgleich – Auch E/AGeräte sollen gleichmäßig ausgelastet werden MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 32,
      "chunk_id": "p32c1",
      "title": "Ziele = Bewertungskriterien ▪Systemorientiert ▪Durchsatz – Möglichst viele Prozesse pro Zeiteinheit ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Gegenüberstellung – quantitativ MOBS: 03Scheduling Aus William Stallings, „Betriebssysteme – Prinzipien und Umsetzung“",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 33,
      "chunk_id": "p33c1",
      "title": "Gegenüberstellung – quantitativ MOBS: 03Scheduling Aus William Stallings, „Betriebssysteme – Prinzip",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Gegenüberstellung – qualitativ MOBS: 03Scheduling In Anlehnung an William Stallings, „Betriebssysteme – Prinzipien und Umsetzung“",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 34,
      "chunk_id": "p34c1",
      "title": "Gegenüberstellung – qualitativ MOBS: 03Scheduling In Anlehnung an William Stallings, „Betriebssystem",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Abfertigungszustände und Zustandsübergänge ▪Klassische CPUZuteilungsstrategien ▪Bewertungskriterien und Vergleich ▪Beispiele ▪UNIX (4.3BSD) ▪NT MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 35,
      "chunk_id": "p35c1",
      "title": "Inhalt ▪Wiederholung ▪Abfertigungszustände und Zustandsübergänge ▪Klassische CPUZuteilungsstrategien",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX ▪Zweistufiges präemptives Verfahren mit dem Ziel, Antwortzeiten zu minimieren ▪Kein LongTerm Scheduling ▪highlevel: mittelfristig mit Ein/Auslagerung (swapping) arbeitend ▪lowlevel: kurzfristig präemptiv, MLFB, dynamische Prozessprioritäten ▪Einmal pro Sekunde: ▪Jeder ”Tick “ (1/10 s) verringert das Nutzungsrecht über die CPU durch Erhöhung von cpu_usage beim laufenden Prozess ▪hohe prio Zahl",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 36,
      "chunk_id": "p36c1",
      "title": "UNIX ▪Zweistufiges präemptives Verfahren mit dem Ziel, Antwortzeiten zu minimieren ▪Kein LongTerm Sc",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "das Nutzungsrecht über die CPU durch Erhöhung von cpu_usage beim laufenden Prozess ▪hohe prio Zahl = niedrige Priorität ▪Das Maß der CPUNutzung (cpu_usage) wird über die Zeit gedämpft ▪Die Dämpfungs/Glättungsfunktion variiert von UNIX zu UNIX MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 36,
      "chunk_id": "p36c2",
      "title": "UNIX ▪Zweistufiges präemptives Verfahren mit dem Ziel, Antwortzeiten zu minimieren ▪Kein LongTerm Sc",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "▪Jeden vierten Tick (40ms) erfolgt die Berechnung der Benutzerpriorität: ▪Pcpu nimmt mit jedem Tick um 1 zu und wird einmal pro Sekunde geglättet: ▪Glättung für erwachte Prozesse, die länger als eine Sekunde blockiert waren: UNIX – 4.3 BSD (1) MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 37,
      "chunk_id": "p37c1",
      "title": "▪Jeden vierten Tick (40ms) erfolgt die Berechnung der Benutzerpriorität: ▪Pcpu nimmt mit jedem Tick ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "▪Glättung (decay filter) bei einer angenommenen mittleren Auslastung (load) von 1 gilt Pcpu := 0.66 · Pcpu + Pnice . Ferner sei angenommen, ein Prozess sammelt Ti Ticks im Zeitintervall i an und Pnice = 0. Pcpu1 = 0.66 T0 Pcpu2 = 0.66 (T1 + 0.66 T0) = 0.66 T1 + 0.44 T0 Pcpu3 = 0.66 T2 + 0.44 T1 + 0.30 T0 Pcpu4 = 0.66 T3 + ... + 0.20 T0 Pcpu5 = 0.66 T4 + ..",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 38,
      "chunk_id": "p38c1",
      "title": "▪Glättung (decay filter) bei einer angenommenen mittleren Auslastung (load) von 1 gilt Pcpu := 0.66 ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". + 0.20 T0 Pcpu5 = 0.66 T4 + ... + 0.13 T0 ▪Nach 5 Sekunden gehen nur noch 13% „alte“ Auslastung ein UNIX – 4.3 BSD (2) MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 38,
      "chunk_id": "p38c2",
      "title": "▪Glättung (decay filter) bei einer angenommenen mittleren Auslastung (load) von 1 gilt Pcpu := 0.66 ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "▪Präemptive, prioritätsund zeitscheibenbasierte Einplanung von Fäden (Threads) ▪Verdrängung erfolgt auch dann, wenn der Faden sich im Kern befindet → nicht so bei UNIX & Co. ▪RR bei gleicher Priorität: ▪0 reserviert ▪115 variabel ▪1631 Echtzeit Windows NT – Prioritätsklassen MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 39,
      "chunk_id": "p39c1",
      "title": "▪Präemptive, prioritätsund zeitscheibenbasierte Einplanung von Fäden (Threads) ▪Verdrängung erfolgt ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "▪Die Art des Fadens (Vorder/Hintergrund) bestimmt das Zeitquantum eines Fadens → Quantum Stretching ▪Quantum (zwischen 6 und 36) vermindert sich mit jedem Tick (10 bzw",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 40,
      "chunk_id": "p40c1",
      "title": "▪Die Art des Fadens (Vorder/Hintergrund) bestimmt das Zeitquantum eines Fadens → Quantum Stretching ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". 15ms) um 3 oder um 1, falls der Faden in den Wartezustand geht ▪Die Zeitscheibenlänge variiert mit den Prozessen: 20180ms ▪Vordergrund/Hintergrund, Server/DesktopKonfiguration ▪Zudem variable Priorität: process_priority_class + relative_thread_priority + boost Windows NT – Prioritätsklassen MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 40,
      "chunk_id": "p40c2",
      "title": "▪Die Art des Fadens (Vorder/Hintergrund) bestimmt das Zeitquantum eines Fadens → Quantum Stretching ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "▪Fadenprioritäten werden in bestimmten Situationen dynamisch angehoben: Dynamic Boost ▪Abschluss von Ein/Ausgabe (Festplatten) +1 ▪Mausbewegung, Tastatureingabe +6 ▪Deblockierung, Betriebsmittelfreigabe (Semaphor, Event, Mutex) +1 ▪Andere Ereignisse (Netzwerk, Pipe, ...) +2 ▪Ereignis im Vordergrundprozess +2 ▪Die dynamic boosts werden mit jedem Tick wieder verbraucht ▪Fortschrittsgarantie",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 41,
      "chunk_id": "p41c1",
      "title": "▪Fadenprioritäten werden in bestimmten Situationen dynamisch angehoben: Dynamic Boost ▪Abschluss von",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "+2 ▪Die dynamic boosts werden mit jedem Tick wieder verbraucht ▪Fortschrittsgarantie ▪Verhindert das Aushungern von Threads ▪Alle 34 s erhalten bis zu 10 ”benachteiligte“ Fäden für zwei Zeitscheiben die Priorität 15 NT – Prioritätsanpassung MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 41,
      "chunk_id": "p41c2",
      "title": "▪Fadenprioritäten werden in bestimmten Situationen dynamisch angehoben: Dynamic Boost ▪Abschluss von",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "▪Betriebssysteme treffen CPUZuteilungsentscheidungen auf drei Ebenen: ▪LongTerm Scheduling: Zulassung von Prozessen zum System ▪MediumTerm Scheduling: Ausund Einlagerung von Prozessen ▪ShortTerm Scheduling: kurzfristige CPUZuteilung ▪Alle hier betrachteten Verfahren werden dem ShortTerm Scheduling zugerechnet ▪Es gibt diverse benutzerund systemorientierte Kriterien für die Beurteilung der",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 42,
      "chunk_id": "p42c1",
      "title": "▪Betriebssysteme treffen CPUZuteilungsentscheidungen auf drei Ebenen: ▪LongTerm Scheduling: Zulassun",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "zugerechnet ▪Es gibt diverse benutzerund systemorientierte Kriterien für die Beurteilung der Eigenschaften eines CPUZuteilungsverfahrens ▪Die Auswahl kommt einer Gratwanderung gleich ▪Das „beste“ Verfahren lässt sich nur nach einer Analyse des typischen Anwendungsprofils und aller Randbedingungen finden Zusammenfassung MOBS: 03Scheduling",
    "metadata": {
      "source": "MOBS_03_Scheduling.pdf",
      "page": 42,
      "chunk_id": "p42c2",
      "title": "▪Betriebssysteme treffen CPUZuteilungsentscheidungen auf drei Ebenen: ▪LongTerm Scheduling: Zulassun",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – Interprozesskommunikation mit Material von Olaf Spinczyk (Universität Osnabrück) und Horst Schirmeier (TU Dortmund)",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 1,
      "chunk_id": "p1c1",
      "title": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – Interprozesskommunikation mit Material von Olaf S",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Wiederholung Grundlagen der Interprozesskommunikation Lokale Interprozesskommunikation unter UNIX Rechnerübergreifende Interprozesskommunikation MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 2,
      "chunk_id": "p2c1",
      "title": "Inhalt Wiederholung Grundlagen der Interprozesskommunikation Lokale Interprozesskommunikation unt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Wiederholung Grundlagen der Interprozesskommunikation Lokale Interprozesskommunikation unter UNIX Rechnerübergreifende Interprozesskommunikation MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 3,
      "chunk_id": "p3c1",
      "title": "Inhalt Wiederholung Grundlagen der Interprozesskommunikation Lokale Interprozesskommunikation unt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Wiederholung Prozesse können miteinander interagieren Aufeinander warten (Synchronisation) Daten austauschen (Kommunikation) Wartemechanismen… sind notwendig für kontrollierte Kommunikation können zu Verklemmungen führen Datenaustausch wurde bisher nur am Rande betrachtet Leichtund federgewichtige Prozesse im selben Adressraum MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 4,
      "chunk_id": "p4c1",
      "title": "Wiederholung Prozesse können miteinander interagieren Aufeinander warten (Synchronisation) Daten ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Wiederholung Grundlagen der Interprozesskommunikation Lokale Interprozesskommunikation unter UNIX Rechnerübergreifende Interprozesskommunikation MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 5,
      "chunk_id": "p5c1",
      "title": "Inhalt Wiederholung Grundlagen der Interprozesskommunikation Lokale Interprozesskommunikation unt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Interprozesskommunikation InterProcessCommunication (IPC) Mehrere Prozesse bearbeiten eine Aufgabe gleichzeitiges Nutzung von zur Verfügung stehender Information durch mehrere Prozesse Verkürzung der Bearbeitungszeit durch Parallelisierung Verbergen von Bearbeitungszeiten durch Ausführung “im Hintergrund” 1) Kommunikation durch gemeinsamen Speicher Datenaustausch nebenläufiges Schreiben in",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 6,
      "chunk_id": "p6c1",
      "title": "Interprozesskommunikation InterProcessCommunication (IPC) Mehrere Prozesse bearbeiten eine Aufgabe ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Hintergrund” 1) Kommunikation durch gemeinsamen Speicher Datenaustausch nebenläufiges Schreiben in bzw",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 6,
      "chunk_id": "p6c2",
      "title": "Interprozesskommunikation InterProcessCommunication (IPC) Mehrere Prozesse bearbeiten eine Aufgabe ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Lesen aus einem gemeinsamen Speicher Dabei muss auf Synchronisation geachtet werden 2) Heute: Kommunikation durch Nachrichten Nachrichten werden zwischen Prozessen ausgetauscht Gemeinsamer Speicher ist nicht erforderlich MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 6,
      "chunk_id": "p6c3",
      "title": "Interprozesskommunikation InterProcessCommunication (IPC) Mehrere Prozesse bearbeiten eine Aufgabe ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Nachrichtenbasierte Kommunikation ... basiert auf zwei Primitiven: Unterschiede gibt es in ... Synchronisation Adressierung und diversen anderen Eigenschaften ;) MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 7,
      "chunk_id": "p7c1",
      "title": "Nachrichtenbasierte Kommunikation ... basiert auf zwei Primitiven: Unterschiede gibt es in ... Sy",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Synchronisation (bei nachrichtenbasierter Kommunikation) Synchronisation bei Senden / Empfangen Synchroner Nachrichtenaustausch (auch „Rendezvous “) Empfänger blockiert bis die Nachricht eingetroffen ist Sender blockiert bis die Ankunft der Nachricht bestätigt ist Asynchroner Nachrichtenaustausch Sender gibt die Nachricht dem Betriebssystem und arbeitet weiter Blockierung auf beiden Seiten",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 8,
      "chunk_id": "p8c1",
      "title": "Synchronisation (bei nachrichtenbasierter Kommunikation) Synchronisation bei Senden / Empfangen Sy",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Sender gibt die Nachricht dem Betriebssystem und arbeitet weiter Blockierung auf beiden Seiten optional Pufferung immer erforderlich Häufig anzutreffen: Asynchroner Nachrichtenaustausch mit potentiell blockierendem Senden und Empfangen MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 8,
      "chunk_id": "p8c2",
      "title": "Synchronisation (bei nachrichtenbasierter Kommunikation) Synchronisation bei Senden / Empfangen Sy",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Adressierung (bei nachrichtenbasierter Kommunikation) Direkte Adressierung ProzessID (Signale) Kommunikationsendpunkt eines Prozesses (Port, Socket) Indirekte Adressierung Kanäle (Pipes) Briefkästen (Mailboxes), Nachrichtenpuffer (Message Queues) Zusätzliche Dimension: Gruppenadressierung Unicast – an genau einen Multicast – an eine Auswahl Broadcast – an alle MOBS:",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 9,
      "chunk_id": "p9c1",
      "title": "Adressierung (bei nachrichtenbasierter Kommunikation) Direkte Adressierung ProzessID (Signale) Ko",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Unicast – an genau einen Multicast – an eine Auswahl Broadcast – an alle MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 9,
      "chunk_id": "p9c2",
      "title": "Adressierung (bei nachrichtenbasierter Kommunikation) Direkte Adressierung ProzessID (Signale) Ko",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diverse andere Eigenschaften (bei nachrichtenbasierter Kommunikation) Nachrichtenformat Stromorientiert / nachrichtenorientiert Fest Länge / variable Länge Typisiert / untypisiert Übertragung Unidirektional / Bidirektional (halbduplex, vollduplex) zuverlässig / unzuverlässig Reihenfolge bleibt erhalten / nicht erhalten MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 10,
      "chunk_id": "p10c1",
      "title": "Diverse andere Eigenschaften (bei nachrichtenbasierter Kommunikation) Nachrichtenformat Stromorien",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Wiederholung Grundlagen der Interprozesskommunikation Lokale Interprozesskommunikation unter UNIX Signale Pipes Message Queues Rechnerübergreifende Interprozesskommunikation MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 11,
      "chunk_id": "p11c1",
      "title": "Inhalt Wiederholung Grundlagen der Interprozesskommunikation Lokale Interprozesskommunikation unt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Signale Mit Hilfe von Signalen können Prozesse über Ausnahmesituation informiert werden ähnlich wie Hardwareunterbrechungen Beispiele: SIGINT Prozess abbrechen (z.B. bei CtrlC) SIGSTOP Prozess anhalten (z.B",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 12,
      "chunk_id": "p12c1",
      "title": "Signale Mit Hilfe von Signalen können Prozesse über Ausnahmesituation informiert werden ähnlich wi",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". bei CtrlC) SIGSTOP Prozess anhalten (z.B. bei CtrlZ) SIGWINCH Fenstergröße wurde geändert SIGSEGV Speicherschutzverletzung des Prozesses Die Standardbehandlung (terminieren, anhalten, ...) kann für die meisten Signale überdefiniert werden siehe signal (2) MOBS: 06Interprozesskommunikation SIGCHLD Kindprozess terminiert SIGKILL Prozess wird getötet …",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 12,
      "chunk_id": "p12c2",
      "title": "Signale Mit Hilfe von Signalen können Prozesse über Ausnahmesituation informiert werden ähnlich wi",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Signale: Logische Sicht HollywoodPrinzip: „Don‘t call us, we‘ll call you.“ MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 13,
      "chunk_id": "p13c1",
      "title": "UNIX Signale: Logische Sicht HollywoodPrinzip: „Don‘t call us, we‘ll call you.“ MOBS: 06Interprozess",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Signale: Technische Sicht Die Signalbehandlung erfolgt immer beim Übergang vom Kernel in der User Mode Was passiert also wirklich, wenn der Zielprozess gerade… 1. läuft, also RUNNING ist (z.B. Segmentation Fault, Bus Error)? Unmittelbarer Start der Behandlungsroutine 2. gerade nicht läuft, aber READY ist (z.B",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 14,
      "chunk_id": "p14c1",
      "title": "UNIX Signale: Technische Sicht Die Signalbehandlung erfolgt immer beim Übergang vom Kernel in der U",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". gerade nicht läuft, aber READY ist (z.B. Systemaufruf kill)? Im Prozesskontrollblock wird das Signal vermerkt Wenn der Prozess die CPU zugeteilt bekommt, erfolgt die Behandlung MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 14,
      "chunk_id": "p14c2",
      "title": "UNIX Signale: Technische Sicht Die Signalbehandlung erfolgt immer beim Übergang vom Kernel in der U",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Signale: Technische Sicht Was passiert also wirklich, wenn der Zielprozess gerade… 3. auf E/A wartet, also BLOCKED ist? Der E/A Systemaufruf (z.B. read) wird mit EINTR abgebrochen Der Prozesszustand wird auf READY gesetzt Danach wie bei 2. Ggf. wird der unterbrochene Systemaufruf neu ausgeführt (SA_RESTART) MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 15,
      "chunk_id": "p15c1",
      "title": "UNIX Signale: Technische Sicht Was passiert also wirklich, wenn der Zielprozess gerade… 3. auf E/A ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Signale: Beispiel Auszug aus dem Handbuch des Apache HTTP Servers MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 16,
      "chunk_id": "p16c1",
      "title": "UNIX Signale: Beispiel Auszug aus dem Handbuch des Apache HTTP Servers MOBS: 06Interprozesskommunik",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Pipes Kanal zwischen zwei Kommunikationspartnern unidirektional gepuffert (feste Puffergröße) zuverlässig stromorientiert Operationen: Schreiben und Lesen Ordnung der Zeichen bleibt erhalten (Zeichenstrom) Blockierung bei voller Pipe (Schreiben) und leerer Pipe (Lesen) MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 17,
      "chunk_id": "p17c1",
      "title": "UNIX Pipes Kanal zwischen zwei Kommunikationspartnern unidirektional gepuffert (feste Puffergröße",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Pipes : Programmierung Unbenannte Pipes Erzeugen einer Pipe: int pipe (int fdes[2]) Nach erfolgreichem Aufruf (Rückgabewert == 0) kann man… über fdes[0] aus der Pipe lesen (Systemaufruf read) über fdes[1] in die Pipe schreiben (Systemaufruf write) Nun muss man nur noch das eine Ende an einen anderen Prozess weitergeben (siehe übernächste Folie) MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 18,
      "chunk_id": "p18c1",
      "title": "UNIX Pipes : Programmierung Unbenannte Pipes Erzeugen einer Pipe: int pipe (int fdes[2]) Nach erf",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Pipes : Programmierung Benannte Pipes Pipes können auch als Spezialdateien ins Dateisystem gelegt werden: int mkfifo (<Dateiname>, mode_t mode) Standardfunktionen zum Öffnen, Lesen, Schreiben und Schließen können dann verwendet werden Normale Dateizugriffsrechte regeln, wer die Pipe benutzen darf MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 19,
      "chunk_id": "p19c1",
      "title": "UNIX Pipes : Programmierung Benannte Pipes Pipes können auch als Spezialdateien ins Dateisystem ge",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 20,
      "chunk_id": "p20c1",
      "title": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILENO DateideskriptorTabelle Puffer READ WRITE fd",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 21,
      "chunk_id": "p21c1",
      "title": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILE",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILENO fd[READ] fd[WRITE] DateideskriptorTabelle Puffer READ WRITE fd Pipe W R",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 22,
      "chunk_id": "p22c1",
      "title": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILE",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILENO fd[READ] fd[WRITE] DateideskriptorTabelle Puffer READ WRITE fd Pipe R STDIN_FILENO STDOUT_FILENO STDERR_FILENO fd[READ] fd[WRITE] Puffer READ WRITE fd W DateideskriptorTabelle",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 23,
      "chunk_id": "p23c1",
      "title": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILE",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILENO fd[WRITE] DateideskriptorTabelle Puffer READWRITE fd Pipe R STDIN_FILENO STDOUT_FILENO STDERR_FILENO fd[READ] fd[WRITE] Puffer READ WRITE fd W DateideskriptorTabelle",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 24,
      "chunk_id": "p24c1",
      "title": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILE",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILENO fd[WRITE] DateideskriptorTabelle READWRITE fd Pipe R STDIN_FILENO STDOUT_FILENO STDERR_FILENO fd[READ] fd[WRITE] Puffer READ WRITE fd W DateideskriptorTabelle",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 25,
      "chunk_id": "p25c1",
      "title": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILE",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILENO DateideskriptorTabelle READWRITEfd Pipe R STDIN_FILENO STDOUT_FILENO STDERR_FILENO fd[READ] fd[WRITE] Puffer READ WRITE fd W DateideskriptorTabelle",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 26,
      "chunk_id": "p26c1",
      "title": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILE",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILENO DateideskriptorTabelle READWRITEfd Pipe R STDIN_FILENO STDOUT_FILENO STDERR_FILENO fd[READ] fd[WRITE] Puffer READ WRITE fd W DateideskriptorTabelle",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 27,
      "chunk_id": "p27c1",
      "title": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILE",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILENO DateideskriptorTabelle READWRITEfd Pipe R STDIN_FILENO STDOUT_FILENO STDERR_FILENO fd[READ] Puffer READ WRITEfd W DateideskriptorTabelle",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 28,
      "chunk_id": "p28c1",
      "title": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILE",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILENO DateideskriptorTabelle READWRITEfd Pipe R STDIN_FILENO STDOUT_FILENO STDERR_FILENO fd[READ] Puffer READ WRITEfd W DateideskriptorTabelle",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 29,
      "chunk_id": "p29c1",
      "title": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILE",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILENO DateideskriptorTabelle READWRITEfd Pipe R STDIN_FILENO STDOUT_FILENO STDERR_FILENO Puffer READWRITEfd W DateideskriptorTabelle",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 30,
      "chunk_id": "p30c1",
      "title": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation STDIN_FILENO STDOUT_FILENO STDERR_FILE",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 31,
      "chunk_id": "p31c1",
      "title": "UNIX Pipes : Programmierung MOBS: 06Interprozesskommunikation",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Message Queues Rechnerweit eindeutige Adresse (Key) dient zur Identifikation Zugriffsrechte wie auf Dateien Prozesslokale Nummer (MsqID) wird bei allen Operationen benötigt ungerichtete M:N Kommunikation gepuffert einstellbare Größe pro Queue Nachrichten haben einen Typ (longWert) Operationen zum Senden und Empfangen einer Nachricht blockierend — nichtblockierend (aber nicht",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 32,
      "chunk_id": "p32c1",
      "title": "UNIX Message Queues Rechnerweit eindeutige Adresse (Key) dient zur Identifikation Zugriffsrechte w",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Operationen zum Senden und Empfangen einer Nachricht blockierend — nichtblockierend (aber nicht asynchron) Empfang aller Nachrichten — nur ein bestimmter Typ MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 32,
      "chunk_id": "p32c2",
      "title": "UNIX Message Queues Rechnerweit eindeutige Adresse (Key) dient zur Identifikation Zugriffsrechte w",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Message Queues Rechnerweit eindeutige Adresse (Key) dient zur Identifikation Zugriffsrechte wie auf Dateien Prozesslokale Nummer (MsqID) wird bei allen Operationen benötigt ungerichtete M:N Kommunikation gepuffert einstellbare Größe pro Queue Nachrichten haben einen Typ (longWert) Operationen zum Senden und Empfangen einer Nachricht blockierend — nichtblockierend (aber nicht",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 33,
      "chunk_id": "p33c1",
      "title": "UNIX Message Queues Rechnerweit eindeutige Adresse (Key) dient zur Identifikation Zugriffsrechte w",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Operationen zum Senden und Empfangen einer Nachricht blockierend — nichtblockierend (aber nicht asynchron) Empfang aller Nachrichten — nur ein bestimmter Typ MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 33,
      "chunk_id": "p33c2",
      "title": "UNIX Message Queues Rechnerweit eindeutige Adresse (Key) dient zur Identifikation Zugriffsrechte w",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Message Queues: Programmierung Erzeugen einer Message Queue und holen einer MsqID int msgget (key_t key, int msgflg); Alle kommunizierenden Prozesse müssen den Key kennen Keys sind eindeutig innerhalb eines (Betriebs)Systems Ist ein Key bereits vergeben, kann keine Message Queue mit gleichem Key erzeugt werden Es können Message Queues ohne Key erzeugt werden (private Queues,",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 34,
      "chunk_id": "p34c1",
      "title": "UNIX Message Queues: Programmierung Erzeugen einer Message Queue und holen einer MsqID int msgget ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "mit gleichem Key erzeugt werden Es können Message Queues ohne Key erzeugt werden (private Queues, key=IPC_PRIVATE) Nichtprivate Message Queues sind persistent Sie müssen explizit gelöscht werden (cmd=IPC_RMID): int msgctl (int msqid, int cmd struct msqid_ds *buf); MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 34,
      "chunk_id": "p34c2",
      "title": "UNIX Message Queues: Programmierung Erzeugen einer Message Queue und holen einer MsqID int msgget ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Message Queues: Programmierung Senden einer Nachricht int msgsnd (int msqid, const void *msgp, size_t msgsz, int msgflg); Empfangen einer Nachricht int msgrcv (int msqid, void *msgp, size_t msgsz, long msgtype, int msgflg); msgtype=0: erste Nachricht msgtype>0: erste Nachricht mit diesem Typ msgtype<0: Nachricht mit kleinstem Typ <= |msgtype| MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 35,
      "chunk_id": "p35c1",
      "title": "UNIX Message Queues: Programmierung Senden einer Nachricht int msgsnd (int msqid, const void *msgp,",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Message Queue: Kommandos Anzeigen aller Message Queues ipcsq Löschen von Message Queues ipcrmQ <key> MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 36,
      "chunk_id": "p36c1",
      "title": "UNIX Message Queue: Kommandos Anzeigen aller Message Queues ipcsq Löschen von Message Queues ipcrm",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX Message Queue: Beispiel [intentionally left blank] MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 37,
      "chunk_id": "p37c1",
      "title": "UNIX Message Queue: Beispiel [intentionally left blank] MOBS: 06Interprozesskommunikation",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Wiederholung Grundlagen der Interprozesskommunikation Lokale Interprozesskommunikation unter UNIX Rechnerübergreifende Interprozesskommunikation Sockets Entfernte Prozeduraufrufe (RPCs) MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 38,
      "chunk_id": "p38c1",
      "title": "Inhalt Wiederholung Grundlagen der Interprozesskommunikation Lokale Interprozesskommunikation unt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Sockets Allgemeine Kommunikationsendpunkte im Rechnernetz Bidirektional Gepuffert Abstrahiert von Details des Kommunikationssystems Beschrieben durch Domäne (Protokollfamilie), Typ und Protokoll MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 39,
      "chunk_id": "p39c1",
      "title": "Sockets Allgemeine Kommunikationsendpunkte im Rechnernetz Bidirektional Gepuffert Abstrahiert vo",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Sockets: Domänen UNIX Domain UNIX Domain Sockets verhalten sich wie bidirektionale Pipes Anlage als Spezialdatei im Dateisystem möglich Internet Domain Dienen der rechnerübergreifenden Kommunikation mit Internet Protokollen Appletalk Domain, DECnet Domain, ... Domänen bestimmen mögliche Protokolle z.B. Internet Domain: TCP/IP oder UDP/IP Domänen bestimmen die Adressfamilie z.B",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 40,
      "chunk_id": "p40c1",
      "title": "Sockets: Domänen UNIX Domain UNIX Domain Sockets verhalten sich wie bidirektionale Pipes Anlage a",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Internet Domain: TCP/IP oder UDP/IP Domänen bestimmen die Adressfamilie z.B. Internet Domain: IPAdresse und PortNummer MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 40,
      "chunk_id": "p40c2",
      "title": "Sockets: Domänen UNIX Domain UNIX Domain Sockets verhalten sich wie bidirektionale Pipes Anlage a",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Sockets: Typ und Protokoll Die wichtigsten Sockettypen: stromorientiert, verbindungsorientiert und gesichert nachrichtenorientiert und ungesichert nachrichtenorientiert und gesichert Protokolle der Internet Domain: UDP/IP Protokoll nachrichtenorientiert, verbindungslos, ungesichert Nachrichten können verloren oder dupliziert werden Reihenfolge kann durcheinander geraten Paketgrenzen",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 41,
      "chunk_id": "p41c1",
      "title": "Sockets: Typ und Protokoll Die wichtigsten Sockettypen: stromorientiert, verbindungsorientiert und",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "können verloren oder dupliziert werden Reihenfolge kann durcheinander geraten Paketgrenzen bleiben erhalten (DatagrammProtokoll)  Protokollangabe ist oft redundant MOBS: 06Interprozesskommunikation TCP/IP Protokoll stromund verbindungsorientiert, gesichert",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 41,
      "chunk_id": "p41c2",
      "title": "Sockets: Typ und Protokoll Die wichtigsten Sockettypen: stromorientiert, verbindungsorientiert und",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Sockets: Programmierung Anlegen von Sockets Generieren eines Sockets mit (Rückgabewert ist ein Filedeskriptor) int socket (int domain, int type, int proto); Adresszuteilung Sockets werden ohne Adresse generiert Adressenzuteilung erfolgt durch: int bind (int socket, const struct sockaddr *address, socklen_t address_len); struct sockaddr_in (für die InternetAdressfamilie) enthält: sin_family:",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 42,
      "chunk_id": "p42c1",
      "title": "Sockets: Programmierung Anlegen von Sockets Generieren eines Sockets mit (Rückgabewert ist ein Fil",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "socklen_t address_len); struct sockaddr_in (für die InternetAdressfamilie) enthält: sin_family: AF_INET sin_port: 16 Bit Portnummer sin_addr: Struktur mit der IPAdresse, z.B",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 42,
      "chunk_id": "p42c2",
      "title": "Sockets: Programmierung Anlegen von Sockets Generieren eines Sockets mit (Rückgabewert ist ein Fil",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". 192.168.2.1 MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 42,
      "chunk_id": "p42c3",
      "title": "Sockets: Programmierung Anlegen von Sockets Generieren eines Sockets mit (Rückgabewert ist ein Fil",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Sockets: Programmierung Datagram Sockets Kein Verbindungsaufbau notwendig Datagramm senden ssize_t sendto (int socket, const void *message, size_t length, int flags, const struct sockaddr *dest_addr, socklen_t dest_len); Datagramm empfangen ssize_t recvfrom (int socket, void *buffer, size_t length, int flags, struct sockaddr *address, socklen_t *address_len); MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 43,
      "chunk_id": "p43c1",
      "title": "Sockets: Programmierung Datagram Sockets Kein Verbindungsaufbau notwendig Datagramm senden ssize_",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Sockets: Programmierung Stream Sockets Verbindungsaufbau notwendig Client (Benutzer, Benutzerprogramm) will zu einem Server (Dienstanbieter) eine Kommunikationsverbindung aufbauen Client: Verbindungsaufbau bei stromorientierten Sockets Verbinden des Sockets mit int connect (int socket, const struct sockaddr *address, socklen_t address_len); Senden und Empfangen mit write und read (oder send",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 44,
      "chunk_id": "p44c1",
      "title": "Sockets: Programmierung Stream Sockets Verbindungsaufbau notwendig Client (Benutzer, Benutzerprog",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "sockaddr *address, socklen_t address_len); Senden und Empfangen mit write und read (oder send und recv) Beenden der Verbindung mit close (schließt den Socket) MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 44,
      "chunk_id": "p44c2",
      "title": "Sockets: Programmierung Stream Sockets Verbindungsaufbau notwendig Client (Benutzer, Benutzerprog",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Sockets: Programmierung Server: akzeptiert Anfragen/Aufträge bindet Socket an eine Adresse (sonst nicht erreichbar) bereitet Socket auf Verbindungsanforderungen vor durch int listen (int s, int queuelen); akzeptiert einzelne Verbindungsanforderungen durch int accept (int s, struct sockaddr *addr, socklen_t *addrlen); gibt einen neuen Socket zurück, der mit dem Client verbunden ist blockiert,",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 45,
      "chunk_id": "p45c1",
      "title": "Sockets: Programmierung Server: akzeptiert Anfragen/Aufträge bindet Socket an eine Adresse (sonst ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "socklen_t *addrlen); gibt einen neuen Socket zurück, der mit dem Client verbunden ist blockiert, falls kein Verbindungswunsch vorhanden liest Daten mit read und führt den angebotenen Dienst aus schickt das Ergebnis mit write zurück zum Sender schließt den neuen Socket mit close MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 45,
      "chunk_id": "p45c2",
      "title": "Sockets: Programmierung Server: akzeptiert Anfragen/Aufträge bindet Socket an eine Adresse (sonst ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Sockets: Programmierung Server: akzeptiert Anfragen/Aufträge bindet Socket an eine Adresse (sonst nicht erreichbar) bereitet Socket auf Verbindungsanforderungen vor durch int listen (int s, int queuelen); akzeptiert einzelne Verbindungsanforderungen durch int accept (int s, struct sockaddr *addr, socklen_t *addrlen); gibt einen neuen Socket zurück, der mit dem Client verbunden ist blockiert,",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 46,
      "chunk_id": "p46c1",
      "title": "Sockets: Programmierung Server: akzeptiert Anfragen/Aufträge bindet Socket an eine Adresse (sonst ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "socklen_t *addrlen); gibt einen neuen Socket zurück, der mit dem Client verbunden ist blockiert, falls kein Verbindungswunsch vorhanden liest Daten mit read und führt den angebotenen Dienst aus schickt das Ergebnis mit write zurück zum Sender schließt den neuen Socket mit close MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 46,
      "chunk_id": "p46c2",
      "title": "Sockets: Programmierung Server: akzeptiert Anfragen/Aufträge bindet Socket an eine Adresse (sonst ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Sockets: Programmierung Server: akzeptiert Anfragen/Aufträge bindet Socket an eine Adresse (sonst nicht erreichbar) bereitet Socket auf Verbindungsanforderungen vor durch int listen (int s, int queuelen); akzeptiert einzelne Verbindungsanforderungen durch int accept (int s, struct sockaddr *addr, socklen_t *addrlen); gibt einen neuen Socket zurück, der mit dem Client verbunden ist blockiert,",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 47,
      "chunk_id": "p47c1",
      "title": "Sockets: Programmierung Server: akzeptiert Anfragen/Aufträge bindet Socket an eine Adresse (sonst ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "socklen_t *addrlen); gibt einen neuen Socket zurück, der mit dem Client verbunden ist blockiert, falls kein Verbindungswunsch vorhanden liest Daten mit read und führt den angebotenen Dienst aus schickt das Ergebnis mit write zurück zum Sender schließt den neuen Socket mit close MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 47,
      "chunk_id": "p47c2",
      "title": "Sockets: Programmierung Server: akzeptiert Anfragen/Aufträge bindet Socket an eine Adresse (sonst ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Sockets: Beispiel HTTP Echo MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 48,
      "chunk_id": "p48c1",
      "title": "Sockets: Beispiel HTTP Echo MOBS: 06Interprozesskommunikation",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Fernaufruf (RPC) Funktionsaufruf über Prozessgrenzen hinweg (Remote Procedure Call) hoher Abstraktionsgrad selten wird Fernaufruf direkt vom System angeboten; benötigt Abbildung auf andere Kommunikationsformen (z.B",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 49,
      "chunk_id": "p49c1",
      "title": "Fernaufruf (RPC) Funktionsaufruf über Prozessgrenzen hinweg (Remote Procedure Call) hoher Abstrakt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". auf Nachrichten) Abbildung auf mehrere Nachrichten Auftragsnachricht transportiert Aufrufabsicht und Parameter Ergebnisnachricht transportiert Ergebnisse des Aufrufs Beispiele: NFS (ONC RPC), Linux DBUS MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 49,
      "chunk_id": "p49c2",
      "title": "Fernaufruf (RPC) Funktionsaufruf über Prozessgrenzen hinweg (Remote Procedure Call) hoher Abstrakt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Zusammenfassung Es gibt zwei Arten der Interprozesskommunikation nachrichtenbasiert die Daten werden kopiert geht auch über Rechnergrenzen über gemeinsamen Speicher kam heute nicht dran UNIXSysteme bieten verschiedene Abstraktionen Signale, Pipes, Sockets, Message Queues Insbesondere die Sockets werden häufig verwendet Ihre Schnittstelle wurde standardisiert Praktisch alle",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 50,
      "chunk_id": "p50c1",
      "title": "Zusammenfassung Es gibt zwei Arten der Interprozesskommunikation nachrichtenbasiert die Daten wer",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "die Sockets werden häufig verwendet Ihre Schnittstelle wurde standardisiert Praktisch alle Vielzweckbetriebssysteme implementieren heute Sockets MOBS: 06Interprozesskommunikation",
    "metadata": {
      "source": "MOBS_06_Interprozesskommunikation.pdf",
      "page": 50,
      "chunk_id": "p50c2",
      "title": "Zusammenfassung Es gibt zwei Arten der Interprozesskommunikation nachrichtenbasiert die Daten wer",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – Synchronisation mit Material von Olaf Spinczyk (Universität Osnabrück) und Horst Schirmeier (TU Dortmund)",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 1,
      "chunk_id": "p1c1",
      "title": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – Synchronisation mit Material von Olaf Spinczyk (U",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Wiederholung Problemszenario und Begriffe AdHoc Lösungsansätze Hardwareunterstützung Betriebssystemunterstützung Sprachunterstützung MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 2,
      "chunk_id": "p2c1",
      "title": "Inhalt Wiederholung Problemszenario und Begriffe AdHoc Lösungsansätze Hardwareunterstützung Bet",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Wiederholung Problemszenario und Begriffe AdHoc Lösungsansätze Hardwareunterstützung Betriebssystemunterstützung Sprachunterstützung MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 3,
      "chunk_id": "p3c1",
      "title": "Inhalt Wiederholung Problemszenario und Begriffe AdHoc Lösungsansätze Hardwareunterstützung Bet",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Wiederholung: Prozesse..",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 4,
      "chunk_id": "p4c1",
      "title": "Wiederholung: Prozesse... sind Programme in Ausführung (unter BSKontrolle) Die Abstraktion für Kon",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". sind Programme in Ausführung (unter BSKontrolle) Die Abstraktion für Kontrollflüsse in Rechnersystemen Konzeptionell unabhängig Technisch findet ein Multiplexing der CPU statt Das Betriebssystem bestimmt den Zeitpunkt der Verdrängung und die Ausführungsreihenfolge der rechenbereiten Prozesse haben einen Adressraum Die logischen Adressen in einem Prozess werden durch die Hardware auf",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 4,
      "chunk_id": "p4c2",
      "title": "Wiederholung: Prozesse... sind Programme in Ausführung (unter BSKontrolle) Die Abstraktion für Kon",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "haben einen Adressraum Die logischen Adressen in einem Prozess werden durch die Hardware auf physische Speicheradressen abgebildet MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 4,
      "chunk_id": "p4c3",
      "title": "Wiederholung: Prozesse... sind Programme in Ausführung (unter BSKontrolle) Die Abstraktion für Kon",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Wiederholung: Prozesse... können sich auch Codeund Datenbereiche teilen Leichtund Federgewichte Prozesse arbeiten im selben Adressraum Das Betriebssystem kann mit Hilfe der MMU auch einen Speicherbereich in mehrere Adressräume einblenden Die Daten des Betriebssystems werden ebenfalls (kontrolliert) geteilt MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 5,
      "chunk_id": "p5c1",
      "title": "Wiederholung: Prozesse... können sich auch Codeund Datenbereiche teilen Leichtund Federgewichte Pr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Wiederholung Problemszenario und Begriffe AdHoc Lösungsansätze Hardwareunterstützung Betriebssystemunterstützung Sprachunterstützung MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 6,
      "chunk_id": "p6c1",
      "title": "Inhalt Wiederholung Problemszenario und Begriffe AdHoc Lösungsansätze Hardwareunterstützung Bet",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Beispiel: Einfache verkettete Liste in C MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 7,
      "chunk_id": "p7c1",
      "title": "Beispiel: Einfache verkettete Liste in C MOBS: 04Synchronisation",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Beispiel: Einfache verkettete Liste in C MOBS: 04Synchronisation Szenario",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 8,
      "chunk_id": "p8c1",
      "title": "Beispiel: Einfache verkettete Liste in C MOBS: 04Synchronisation Szenario",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Beispiel: Einfache verkettete Liste in C MOBS: 04Synchronisation 1. Fall: Faden 2 nach Faden 1",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 9,
      "chunk_id": "p9c1",
      "title": "Beispiel: Einfache verkettete Liste in C MOBS: 04Synchronisation 1. Fall: Faden 2 nach Faden 1",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Beispiel: Einfache verkettete Liste in C MOBS: 04Synchronisation 1. Fall: Faden 2 überlappt Faden 1",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 10,
      "chunk_id": "p10c1",
      "title": "Beispiel: Einfache verkettete Liste in C MOBS: 04Synchronisation 1. Fall: Faden 2 überlappt Faden 1",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Wo kommt das sonst noch vor? Gemeinsamer Speicher, der zur Kommunikation von Prozessen verwendet wird Systeme mit „Shared Memory“ Dienst Leichtoder federgewichtige Prozesse Nebenläufiger Zugriff auf dieselben Variablen Betriebssystemdaten, die gebraucht werden, um den Zugriff von Prozessen auf unteilbare Betriebsmittel zu koordinieren Dateisystemstrukturen, Prozesstabelle,",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 11,
      "chunk_id": "p11c1",
      "title": "Wo kommt das sonst noch vor? Gemeinsamer Speicher, der zur Kommunikation von Prozessen verwendet wi",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "von Prozessen auf unteilbare Betriebsmittel zu koordinieren Dateisystemstrukturen, Prozesstabelle, Speicherverwaltung..",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 11,
      "chunk_id": "p11c2",
      "title": "Wo kommt das sonst noch vor? Gemeinsamer Speicher, der zur Kommunikation von Prozessen verwendet wi",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Geräte (Terminal, Drucker, Netzwerkschnittstellen, ...) Ähnlicher Sonderfall: Unterbrechungssynchronisation Vorsicht: Verfahren, die sich für die Synchronisation von Prozessen eignen, funktionieren nicht notwendigerweise bei Unterbrechungen! MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 11,
      "chunk_id": "p11c3",
      "title": "Wo kommt das sonst noch vor? Gemeinsamer Speicher, der zur Kommunikation von Prozessen verwendet wi",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Begriff: Race Condition (oder auch „Wettlaufsituation“) Eine Race Condition ist eine Situation, in der mehrere Prozesse konkurrierend auf gemeinsame Daten zugreifen und mindestens einer diese manipuliert. Der letztendliche Wert der gemeinsamen Daten hängt bei einer Race Condition davon ab, in welcher Reihenfolge die Prozesse darauf zugreifen",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 12,
      "chunk_id": "p12c1",
      "title": "Begriff: Race Condition (oder auch „Wettlaufsituation“) Eine Race Condition ist eine Situation, in ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Das Ergebnis ist also nicht vorhersagbar und kann im Fall von überlappenden Zugriffen sogar inkorrekt sein! Um Race Conditions zu vermeiden, müssen konkurrierende Prozesse synchronisiert werden MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 12,
      "chunk_id": "p12c2",
      "title": "Begriff: Race Condition (oder auch „Wettlaufsituation“) Eine Race Condition ist eine Situation, in ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Begriff: Synchronisation Die Koordination der Kooperation und Konkurrenz zwischen Prozessen wird Synchronisation (synchronization) genannt. Eine Synchronisation bringt die Aktivitäten verschiedener nebenläufiger Prozesse in eine Reihenfolge. Durch sie erreicht man also prozessübergreifend das, wofür innerhalb eines Prozesses die Sequentialität von Aktivitäten sorgt",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 13,
      "chunk_id": "p13c1",
      "title": "Begriff: Synchronisation Die Koordination der Kooperation und Konkurrenz zwischen Prozessen wird Syn",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". MOBS: 04Synchronisation Quelle: Herrtwich/Hommel (1989), Kooperation und Konkurrenz, S. 26",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 13,
      "chunk_id": "p13c2",
      "title": "Begriff: Synchronisation Die Koordination der Kooperation und Konkurrenz zwischen Prozessen wird Syn",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Begriff: Kritischer Abschnitt Im Fall von Race Conditions streiten sich N Prozesse um den Zugriff auf gemeinsame Daten. Die CodeFragmente, in denen auf diese kritischen Daten zugegriffen wird, werden kritische Abschnitte genannt Problem Es muss sichergestellt werden, dass sich immer nur ein Prozess in einem kritischen Abschnitt aufhalten kann MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 14,
      "chunk_id": "p14c1",
      "title": "Begriff: Kritischer Abschnitt Im Fall von Race Conditions streiten sich N Prozesse um den Zugriff a",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Lösungsansatz: Schlossvariablen MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 15,
      "chunk_id": "p15c1",
      "title": "Lösungsansatz: Schlossvariablen MOBS: 04Synchronisation",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Wiederholung Problemszenario und Begriffe AdHoc Lösungsansätze Aktives Warten – Busy Waiting Hardwareunterstützung Betriebssystemunterstützung Sprachunterstützung MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 16,
      "chunk_id": "p16c1",
      "title": "Inhalt Wiederholung Problemszenario und Begriffe AdHoc Lösungsansätze Aktives Warten – Busy Wait",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Naiver Lösungsansatz – falsch! MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 17,
      "chunk_id": "p17c1",
      "title": "Naiver Lösungsansatz – falsch! MOBS: 04Synchronisation",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Naiver Lösungsansatz – falsch! acquire soll einen kritischen Abschnitt schützen, ist dabei aber selbst kritisch! Problematisch ist der Moment nach dem Verlassen der Warteschleife und vor dem Setzen der Schlossvariablen Bei Verdrängung des laufenden Prozesses in diesem Moment könnte ein anderer Prozess den kritischen Abschnitt frei vorfinden und ebenfalls betreten MOBS: 04Synchronisation Im",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 18,
      "chunk_id": "p18c1",
      "title": "Naiver Lösungsansatz – falsch! acquire soll einen kritischen Abschnitt schützen, ist dabei aber sel",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prozess den kritischen Abschnitt frei vorfinden und ebenfalls betreten MOBS: 04Synchronisation Im weiteren Verlauf könnten (mindestens) zwei Prozesse den eigentlich durch acquire geschützten kritischen Abschnitt überlappt ausführen!",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 18,
      "chunk_id": "p18c2",
      "title": "Naiver Lösungsansatz – falsch! acquire soll einen kritischen Abschnitt schützen, ist dabei aber sel",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "So geht’s: der „BäckereiAlgorithmus“ (naja, in deutschen Bäckereien ist das eher unüblich) Bevor ein Prozess den kritischen Abschnitt betreten darf, bekommt er eine Wartenummer Die Zulassung erfolgt in der Reihenfolge der Nummern, d.h",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 19,
      "chunk_id": "p19c1",
      "title": "So geht’s: der „BäckereiAlgorithmus“ (naja, in deutschen Bäckereien ist das eher unüblich) Bevor ei",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". wenn der kritische Abschnitt frei ist, darf der Prozess mit der niedrigsten Nummer den kritischen Abschnitt betreten Beim Verlassen des kritischen Abschnitts verfällt seine Wartenummer Problem Der Algorithmus kann nicht garantieren, dass eine Wartenummer nur an einen Prozess vergeben wird In diesem Fall entscheidet eine ProzessID (0..N1) die Priorität MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 19,
      "chunk_id": "p19c2",
      "title": "So geht’s: der „BäckereiAlgorithmus“ (naja, in deutschen Bäckereien ist das eher unüblich) Bevor ei",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "So geht’s: der „BäckereiAlgorithmus“ MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 20,
      "chunk_id": "p20c1",
      "title": "So geht’s: der „BäckereiAlgorithmus“ MOBS: 04Synchronisation",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: BäckereiAlgorithmus Der Algorithmus ist eine nachweisbar korrekte Lösung für das Problem der kritischen Abschnitte, aber... i.d.R",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 21,
      "chunk_id": "p21c1",
      "title": "Diskussion: BäckereiAlgorithmus Der Algorithmus ist eine nachweisbar korrekte Lösung für das Problem",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". i.d.R. weiß man nicht vorab, wie viele Prozesse um den Eintritt in einen kritischen Abschnitt konkurrieren werden ProzessIDs liegen nicht im Wertebereich von 0 bis N1 die Funktion acquire hat eine große Laufzeit, auch wenn der kritische Abschnitt frei ist → O(N) MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 21,
      "chunk_id": "p21c2",
      "title": "Diskussion: BäckereiAlgorithmus Der Algorithmus ist eine nachweisbar korrekte Lösung für das Problem",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Wiederholung Problemszenario und Begriffe AdHoc Lösungsansätze Hardwareunterstützung Unterbrechungssperre Atomare Operationen Betriebssystemunterstützung Sprachunterstützung MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 22,
      "chunk_id": "p22c1",
      "title": "Inhalt Wiederholung Problemszenario und Begriffe AdHoc Lösungsansätze Hardwareunterstützung Unt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Unterbrechungen unterdrücken Nur durch den Unterbrechungsmechanismus der CPU kann es dazu kommen, dass einem Prozess innerhalb eines kritischen Abschnitts die CPU entzogen wird Durch diese Lösung werden alle Prozesse und das Betriebssystem selbst (Gerätetreiber) beeinträchtigt sti und cli dürfen daher nicht im UserMode benutzt werden MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 23,
      "chunk_id": "p23c1",
      "title": "Unterbrechungen unterdrücken Nur durch den Unterbrechungsmechanismus der CPU kann es dazu kommen, d",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Schloss mit atomaren Operationen Viele CPUs unterstützen unteilbare (atomare) Lese/Modifikations/Schreibzyklen, mit denen sich Schlossalgorithmen implementieren lassen: Motorola 68K: TAS (TestandSet) Setzt Bit 7 des Zieloperanden und liefert den vorherigen Zustand in Condition Code Bits Intel x86: XCHG (Exchange) Tauscht den Inhalt eines Registers mit dem einer Variablen im Speicher PowerPC:",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 24,
      "chunk_id": "p24c1",
      "title": "Schloss mit atomaren Operationen Viele CPUs unterstützen unteilbare (atomare) Lese/Modifikations/Sc",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "XCHG (Exchange) Tauscht den Inhalt eines Registers mit dem einer Variablen im Speicher PowerPC: LL/SC (Load Linked/Store Conditional) ..",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 24,
      "chunk_id": "p24c2",
      "title": "Schloss mit atomaren Operationen Viele CPUs unterstützen unteilbare (atomare) Lese/Modifikations/Sc",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 24,
      "chunk_id": "p24c3",
      "title": "Schloss mit atomaren Operationen Viele CPUs unterstützen unteilbare (atomare) Lese/Modifikations/Sc",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: Aktives Warten Unzulänglichkeit der bisher gezeigten Schlossalgorithmen: Der aktiv wartende Prozess… kann selbst keine Änderung der Bedingung herbeiführen, auf die er wartet behindert daher unnütz andere Prozesse, die sinnvolle Arbeit leisten könnten schadet damit letztlich auch sich selbst: Je länger der Prozess den Prozessor für sich behält, umso länger muss er darauf warten,",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 25,
      "chunk_id": "p25c1",
      "title": "Diskussion: Aktives Warten Unzulänglichkeit der bisher gezeigten Schlossalgorithmen: Der aktiv warte",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "selbst: Je länger der Prozess den Prozessor für sich behält, umso länger muss er darauf warten, dass andere Prozesse die Bedingung erfüllen, auf die er selbst wartet Nur bei Multiprozessorsystemen tritt dieses Problem nicht auf MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 25,
      "chunk_id": "p25c2",
      "title": "Diskussion: Aktives Warten Unzulänglichkeit der bisher gezeigten Schlossalgorithmen: Der aktiv warte",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Wiederholung Problemszenario und Begriffe AdHoc Lösungsansätze Hardwareunterstützung Betriebssystemunterstützung Semaphore Sprachunterstützung MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 26,
      "chunk_id": "p26c1",
      "title": "Inhalt Wiederholung Problemszenario und Begriffe AdHoc Lösungsansätze Hardwareunterstützung Bet",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: Passives Warten Prozesse geben die Kontrolle über die CPU ab, während sie auf Ereignisse warten im Synchronisationsfall „blockiert sich“ ein Prozess auf ein Ereignis PCB des Prozesses in eine Warteschlange eingereiht tritt das Ereignis ein, wird ein darauf wartender Prozess deblockiert die Wartephase eines Prozesses ist als Blockadephase („E/AStoß“) ausgelegt der Ablaufplan für",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 27,
      "chunk_id": "p27c1",
      "title": "Diskussion: Passives Warten Prozesse geben die Kontrolle über die CPU ab, während sie auf Ereigniss",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "die Wartephase eines Prozesses ist als Blockadephase („E/AStoß“) ausgelegt der Ablaufplan für die Prozesse aktualisiert (scheduling) ein anderer, lauffähiger Prozess wird plangemäß abgefertigt (dispatching) ist kein Prozess mehr lauffähig, läuft die CPU „leer“ (idle phase) mit Beginn der Blockadephase eines Prozesses endet auch sein CPUStoß MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 27,
      "chunk_id": "p27c2",
      "title": "Diskussion: Passives Warten Prozesse geben die Kontrolle über die CPU ab, während sie auf Ereigniss",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Semaphor (semaphore) Eine ”nichtnegative ganze Zahl“, für die zwei unteilbare Operationen definiert sind: P (hol. prolaag, „erniedrige“; auch down, wait) hat der Semaphor den Wert 0, wird der laufende Prozess blockiert ansonsten wird der Semaphor um 1 dekrementiert V (hol. verhoog, „erhöhe“; auch up, signal) auf den Semaphor ggf",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 28,
      "chunk_id": "p28c1",
      "title": "Semaphor (semaphore) Eine ”nichtnegative ganze Zahl“, für die zwei unteilbare Operationen definiert",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". verhoog, „erhöhe“; auch up, signal) auf den Semaphor ggf. blockierter Prozess wird deblockiert ansonsten wird der Semaphor um 1 inkrementiert Eine Betriebssystemabstraktion zum Austausch von Synchronisationssignalen zwischen nebenläufig arbeitenden Prozessen MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 28,
      "chunk_id": "p28c2",
      "title": "Semaphor (semaphore) Eine ”nichtnegative ganze Zahl“, für die zwei unteilbare Operationen definiert",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Semaphor (semaphore) MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 29,
      "chunk_id": "p29c1",
      "title": "Semaphor (semaphore) MOBS: 04Synchronisation",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Semaphor – Anwendung MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 30,
      "chunk_id": "p30c1",
      "title": "Semaphor – Anwendung MOBS: 04Synchronisation",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Semaphor – einfache Interaktionen “einseitige Synchronisation” “betriebsmittelorientierte Synchronisation” MOBS: 04Synchronisation sonst wie beim gegenseitigen Ausschluss",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 31,
      "chunk_id": "p31c1",
      "title": "Semaphor – einfache Interaktionen “einseitige Synchronisation” “betriebsmittelorientierte Synchron",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Semaphor – komplexere Interaktionen Beispiel: Das erste Leser/SchreiberProblem Wie beim gegenseitigen Ausschluss soll auch in diesem Beispiel ein kritischer Abschnitt geschützt werden",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 32,
      "chunk_id": "p32c1",
      "title": "Semaphor – komplexere Interaktionen Beispiel: Das erste Leser/SchreiberProblem Wie beim gegenseiti",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Es gibt allerdings zwei Klassen von konkurrierenden Prozessen: Schreiber: Sie ändern Daten und müssen daher gegenseitigen Ausschluss garantiert bekommen Leser: Da sie nur lesen, dürfen mehrere Leser auch gleichzeitig den kritischen Abschnitt betreten MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 32,
      "chunk_id": "p32c2",
      "title": "Semaphor – komplexere Interaktionen Beispiel: Das erste Leser/SchreiberProblem Wie beim gegenseiti",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Semaphor – komplexere Interaktionen Beispiel: Das erste Leser/SchreiberProblem MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 33,
      "chunk_id": "p33c1",
      "title": "Semaphor – komplexere Interaktionen Beispiel: Das erste Leser/SchreiberProblem MOBS: 04Synchronisat",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Semaphore – Diskussion Erweiterungen/Varianten Binäre Semaphore oder Mutex nichtblockierendes wait() Timeout Felder von Zählern Unterstützung durch die Programmiersprache MOBS: 04Synchronisation Fehlerquellen Gefahr von “Verklemmungen” → nächste Vorlesung Komplexere Synchronisationsmuster schwierig Abhängigkeit kooperierender Prozesse jeder muss die Protokolle exakt einhalten",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 34,
      "chunk_id": "p34c1",
      "title": "Semaphore – Diskussion Erweiterungen/Varianten Binäre Semaphore oder Mutex nichtblockierendes wai",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "schwierig Abhängigkeit kooperierender Prozesse jeder muss die Protokolle exakt einhalten Semaphorbenutzung wird nicht erzwungen",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 34,
      "chunk_id": "p34c2",
      "title": "Semaphore – Diskussion Erweiterungen/Varianten Binäre Semaphore oder Mutex nichtblockierendes wai",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Wiederholung Problemszenario und Begriffe AdHoc Lösungsansätze Hardwareunterstützung Betriebssystemunterstützung Sprachunterstützung Monitore MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 35,
      "chunk_id": "p35c1",
      "title": "Inhalt Wiederholung Problemszenario und Begriffe AdHoc Lösungsansätze Hardwareunterstützung Bet",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Monitor (Hoare 1974, Hansen 1975) Ein abstrakter Datentyp mit impliziten Synchronisationseigenschaften: mehrseitige Synchronisation an der Schnittstelle zum Monitor gegenseitiger Ausschluss der Ausführung aller Methoden einseitige Synchronisation innerhalb des Monitors mit Hilfe von Bedingungsvariablen (condition variables) wait blockiert einen Prozess auf das Eintreten eines Signals/einer",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 36,
      "chunk_id": "p36c1",
      "title": "Monitor (Hoare 1974, Hansen 1975) Ein abstrakter Datentyp mit impliziten Synchronisationseigenschaf",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "(condition variables) wait blockiert einen Prozess auf das Eintreten eines Signals/einer Bedingung und gibt den Monitor implizit wieder frei signal zeigt das Eintreten eines Signals/einer Bedingung an und deblockiert ggf",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 36,
      "chunk_id": "p36c2",
      "title": "Monitor (Hoare 1974, Hansen 1975) Ein abstrakter Datentyp mit impliziten Synchronisationseigenschaf",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". (genau einen oder alle) darauf blockierte Prozesse Sprachgestützter Mechanismus: Concurrent Pascal, PL/I, CHILL, . . . , Java MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 36,
      "chunk_id": "p36c3",
      "title": "Monitor (Hoare 1974, Hansen 1975) Ein abstrakter Datentyp mit impliziten Synchronisationseigenschaf",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Monitor – Beispielcode MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 37,
      "chunk_id": "p37c1",
      "title": "Monitor – Beispielcode MOBS: 04Synchronisation",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Monitor – Signalisierungssemantik Im Falle wartender Prozesse sind als Anforderungen zwingend zu erfüllen: Wenigstens ein Prozess deblockiert an der Bedingungsvariablen und höchstens ein Prozess rechnet nach der Operation im Monitor weiter Es gibt verschiedene Lösungsvarianten, jeweils mit unterschiedlicher Semantik Anzahl der befreiten Prozesse (d. h",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 38,
      "chunk_id": "p38c1",
      "title": "Monitor – Signalisierungssemantik Im Falle wartender Prozesse sind als Anforderungen zwingend zu er",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". h. alle oder nur einer) Wenn nur einer, dann welcher? Konflikte mit der CPUZuteilungsstrategie sind möglich Besitzwechsel des Monitors, kein Besitzwechsel (Besitzwahrung) Wenn kein sofortiger Besitzwechsel erfolgt, muss die Wartebedingung erneut überprüft werden MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 38,
      "chunk_id": "p38c2",
      "title": "Monitor – Signalisierungssemantik Im Falle wartender Prozesse sind als Anforderungen zwingend zu er",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Monitor – in Java Schlüsselwort synchronized für gegenseitigen Ausschluss Eine implizite Bedingungsvariable notify oder notifyAll statt signal, kein Besitzwechsel MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 39,
      "chunk_id": "p39c1",
      "title": "Monitor – in Java Schlüsselwort synchronized für gegenseitigen Ausschluss Eine implizite Bedingung",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Zusammenfassung Unkontrollierte nebenläufige Zugriffe führen zu Fehlern Synchronisationsverfahren sorgen für Koordination Grundsätzlich muss man bei der Implementierung aufpassen, dass die Auswahlstrategien nicht im Widerspruch zum Scheduler stehen Adhoc Verfahren: Aktives Warten Vorsicht! Verschwendung von Rechenzeit Aber: kurz aktiv Warten ist besser als blockieren, insbesondere in",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 40,
      "chunk_id": "p40c1",
      "title": "Zusammenfassung Unkontrollierte nebenläufige Zugriffe führen zu Fehlern Synchronisationsverfahren ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verschwendung von Rechenzeit Aber: kurz aktiv Warten ist besser als blockieren, insbesondere in Multiprozessorsystemen MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 40,
      "chunk_id": "p40c2",
      "title": "Zusammenfassung Unkontrollierte nebenläufige Zugriffe führen zu Fehlern Synchronisationsverfahren ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Zusammenfassung Betriebssystemunterstützte Verfahren: Semaphore Flexibel (erlaubt viele Synchronisationsmuster), aber fehlerträchtig Sprachunterstützte Verfahren: Monitore Weniger vielseitig als Semaphore Teuer durch viele Kontextwechsel Dafür aber sicher MOBS: 04Synchronisation",
    "metadata": {
      "source": "MOBS_04_Synchronisation.pdf",
      "page": 41,
      "chunk_id": "p41c1",
      "title": "Zusammenfassung Betriebssystemunterstützte Verfahren: Semaphore Flexibel (erlaubt viele Synchronis",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – Speicherverwaltung mit Material von Olaf Spinczyk (Universität Osnabrück) und Horst Schirmeier (TU Dortmund)",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 1,
      "chunk_id": "p1c1",
      "title": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – Speicherverwaltung mit Material von Olaf Spinczyk",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Grundlegende Aufgaben der Speicherverwaltung ▪Speichervergabe ▪Speicherverwaltung bei Mehrprogrammbetrieb ▪Segmentbasierte Adressabbildung ▪Seitenbasierte Adressabbildung MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 2,
      "chunk_id": "p2c1",
      "title": "Inhalt ▪Wiederholung ▪Grundlegende Aufgaben der Speicherverwaltung ▪Speichervergabe ▪Speicherverwalt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Grundlegende Aufgaben der Speicherverwaltung ▪Speichervergabe ▪Speicherverwaltung bei Mehrprogrammbetrieb ▪Segmentbasierte Adressabbildung ▪Seitenbasierte Adressabbildung MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 3,
      "chunk_id": "p3c1",
      "title": "Inhalt ▪Wiederholung ▪Grundlegende Aufgaben der Speicherverwaltung ▪Speichervergabe ▪Speicherverwalt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Wiederholung: Betriebsmittel ▪Das Betriebssystem hat folgende Aufgaben: ▪Verwaltung der Betriebsmittel des Rechners ▪Schaffung von Abstraktionen, die Anwendungen einen einfachen und effizienten Umgang mit Betriebsmitteln erlauben ▪Bisher: Prozesse ▪Konzept zur Abstraktion von der realen CPU ▪Nun: Speicher ▪Verwaltung von Hauptund Hintergrundspeicher MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 4,
      "chunk_id": "p4c1",
      "title": "Wiederholung: Betriebsmittel ▪Das Betriebssystem hat folgende Aufgaben: ▪Verwaltung der Betriebsmitt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Wiederholung: Mehrprogrammbetrieb ▪CPUAuslastung unter Annahme einer bestimmten E/AWartewahrscheinlichkeit: → Mehrprogrammbetrieb ist essentiell für eine hohe Auslastung der CPU ▪Beim Starten und Beenden der Prozesse muss dynamisch Speicher zugewiesen bzw. zurückgenommen werden! MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 5,
      "chunk_id": "p5c1",
      "title": "Wiederholung: Mehrprogrammbetrieb ▪CPUAuslastung unter Annahme einer bestimmten E/AWartewahrscheinli",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Grundlegende Aufgaben der Speicherverwaltung ▪Anforderungen ▪Strategien ▪Speichervergabe ▪Speicherverwaltung bei Mehrprogrammbetrieb ▪Segmentbasierte Adressabbildung ▪Seitenbasierte Adressabbildung MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 6,
      "chunk_id": "p6c1",
      "title": "Inhalt ▪Wiederholung ▪Grundlegende Aufgaben der Speicherverwaltung ▪Anforderungen ▪Strategien ▪Speic",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Anforderungen ▪Mehrere Prozesse benötigen Hauptspeicher ▪Prozesse liegen an verschiedenen Stellen im Hauptspeicher ▪Schutzbedürfnis des Betriebssystems und der Prozesse untereinander ▪Speicher reicht eventuell nicht für alle Prozesse → Freie Speicherbereiche kennen, verwalten und vergeben → Einund Auslagern von Prozessen → Relokation von Programmbefehlen → Hardwareunterstützung ausnutzen MOBS:",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 7,
      "chunk_id": "p7c1",
      "title": "Anforderungen ▪Mehrere Prozesse benötigen Hauptspeicher ▪Prozesse liegen an verschiedenen Stellen im",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Auslagern von Prozessen → Relokation von Programmbefehlen → Hardwareunterstützung ausnutzen MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 7,
      "chunk_id": "p7c2",
      "title": "Anforderungen ▪Mehrere Prozesse benötigen Hauptspeicher ▪Prozesse liegen an verschiedenen Stellen im",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Grundlegende Politiken/Strategien … auf jeder Ebene der Speicherhierarchie: ▪Platzierungsstrategie (placement policy) ▪Woher soll benötigter Speicher genommen werden? ▪Wo der Verschnitt am kleinsten/größten ist ▪Egal, weil Verschnitt zweitrangig ist ▪Ladestrategie (fetch policy) ▪Wann sind Speicherinhalte einzulagern? ▪Auf Anforderung oder im Voraus MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 8,
      "chunk_id": "p8c1",
      "title": "Grundlegende Politiken/Strategien … auf jeder Ebene der Speicherhierarchie: ▪Platzierungsstrategie (",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Grundlegende Politiken/Strategien … auf jeder Ebene der Speicherhierarchie: ▪Ersetzungsstrategie (replacement policy) ▪Welche Speicherinhalte sind ggf. zu verdrängen, falls der Speicher knapp wird? ▪Das älteste, am seltensten genutzte ▪Das am längsten ungenutzte MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 9,
      "chunk_id": "p9c1",
      "title": "Grundlegende Politiken/Strategien … auf jeder Ebene der Speicherhierarchie: ▪Ersetzungsstrategie (re",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Grundlegende Aufgaben der Speicherverwaltung ▪Speichervergabe ▪Platzierungsstrategien ▪Speicherverwaltung bei Mehrprogrammbetrieb ▪Segmentbasierte Adressabbildung ▪Seitenbasierte Adressabbildung MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 10,
      "chunk_id": "p10c1",
      "title": "Inhalt ▪Wiederholung ▪Grundlegende Aufgaben der Speicherverwaltung ▪Speichervergabe ▪Platzierungsstr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Speichervergabe: Problemstellung ▪Verfügbarer Speicher MOBS: 07Speicherverwaltung Speicherlandkarte (Memory Map) eines fiktiven 32 Bit Systems",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 11,
      "chunk_id": "p11c1",
      "title": "Speichervergabe: Problemstellung ▪Verfügbarer Speicher MOBS: 07Speicherverwaltung Speicherlandkarte ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Speichervergabe: Problemstellung Belegung des verfügbaren Hauptspeichers durch… ▪Benutzerprogramme ▪Programmbefehle (Text) ▪Programmdaten (Data) ▪Dynamische Speicheranforderungen (Stack, Heap) ▪Betriebssystem ▪Betriebssystemcode unddaten ▪Prozesskontrollblöcke ▪Datenpuffer für Ein/Ausgabe ▪... → Zuteilung des Speichers nötig MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 12,
      "chunk_id": "p12c1",
      "title": "Speichervergabe: Problemstellung Belegung des verfügbaren Hauptspeichers durch… ▪Benutzerprogramme ▪",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Statische Speicherzuteilung ▪Feste Bereiche für Betriebssystem und Benutzerprogramme ▪Probleme ▪Grad des Mehrprogrammbetriebs begrenzt ▪Begrenzung anderer Ressourcen (z.B. Bandbreite bei Ein/Ausgabe wegen zu kleiner Puffer) ▪Ungenutzter Speicher des Betriebssystems kann von Anwendungsprogrammen nicht genutzt werden und umgekehrt → Dynamische Speicherzuteilung einsetzen MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 13,
      "chunk_id": "p13c1",
      "title": "Statische Speicherzuteilung ▪Feste Bereiche für Betriebssystem und Benutzerprogramme ▪Probleme ▪Grad",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Dynamische Speicherzuteilung ▪Segmente ▪zusammenhängender Speicherbereich (Bereich mit aufeinanderfolgenden Adressen) ▪Allokation (Belegung) und Freigabe von Segmenten ▪Ein Anwendungsprogramm besitzt üblicherweise folgende Segmente: ▪Textsegment ▪Datensegment ▪Stapelsegment (lokale Variablen, Parameter, Rücksprungadressen, ...) ▪Suche nach geeigneten Speicherbereichen zur Zuteilung ▪insbesondere",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 14,
      "chunk_id": "p14c1",
      "title": "Dynamische Speicherzuteilung ▪Segmente ▪zusammenhängender Speicherbereich (Bereich mit aufeinanderfo",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Rücksprungadressen, ...) ▪Suche nach geeigneten Speicherbereichen zur Zuteilung ▪insbesondere beim Programmstart → Platzierungsstrategien nötig ▪Besonders wichtig dabei: Freispeicherverwaltung MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 14,
      "chunk_id": "p14c2",
      "title": "Dynamische Speicherzuteilung ▪Segmente ▪zusammenhängender Speicherbereich (Bereich mit aufeinanderfo",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Freispeicherverwaltung (1) ▪Freie (evtl. auch belegte) Segmente des Speichers müssen repräsentiert werden ▪Bitlisten ▪Probleme: Benötigt unter Umständen viel Speicher; bei der Freigabe muss man die Größe des freizugebenden Speichers kennen bzw. mit angeben. MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 15,
      "chunk_id": "p15c1",
      "title": "Freispeicherverwaltung (1) ▪Freie (evtl. auch belegte) Segmente des Speichers müssen repräsentiert w",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Freispeicherverwaltung (2) ▪Verkettete Liste MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 16,
      "chunk_id": "p16c1",
      "title": "Freispeicherverwaltung (2) ▪Verkettete Liste MOBS: 07Speicherverwaltung",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Freispeicherverwaltung (3) ▪Verkettete Liste im freien Speicher ▪Zur Effizienzsteigerung eventuell Rückwärtsverkettung nötig ▪Repräsentation letztlich auch von der Vergabestrategie abhängig MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 17,
      "chunk_id": "p17c1",
      "title": "Freispeicherverwaltung (3) ▪Verkettete Liste im freien Speicher ▪Zur Effizienzsteigerung eventuell R",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Speicherfreigabe ▪Verschmelzung von Lücken MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 18,
      "chunk_id": "p18c1",
      "title": "Speicherfreigabe ▪Verschmelzung von Lücken MOBS: 07Speicherverwaltung",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Platzierungsstrategien …auf der Basis von unterschiedlich sortierten Löcherlisten: ▪First Fit (Sortierung nach Speicheradresse) ▪erste passende Lücke wird verwendet ▪Rotating First Fit / Next Fit (Sortierung nach Speicheradresse) ▪wie First Fit, aber Start bei der zuletzt zugewiesenen Lücke ▪vermeidet viele kleine Lücken am Anfang der Liste (wie bei First Fit) MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 19,
      "chunk_id": "p19c1",
      "title": "Platzierungsstrategien …auf der Basis von unterschiedlich sortierten Löcherlisten: ▪First Fit (Sorti",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Platzierungsstrategien (2) …auf der Basis von unterschiedlich sortierten Löcherlisten: ▪Best Fit (Sortierung nach Lückengröße – kleinste zuerst) ▪kleinste passende Lücke wird gesucht ▪Worst Fit (Sortierung nach Lückengröße – größte zuerst) ▪größte passende Lücke wird gesucht ▪Probleme: ▪zu kleine Lücken, Speicherverschnitt MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 20,
      "chunk_id": "p20c1",
      "title": "Platzierungsstrategien (2) …auf der Basis von unterschiedlich sortierten Löcherlisten: ▪Best Fit (So",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Platzierungsstrategien (3) ▪Das BuddyVerfahren ▪Einteilung in dynamische Bereiche der Größe 2n MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 21,
      "chunk_id": "p21c1",
      "title": "Platzierungsstrategien (3) ▪Das BuddyVerfahren ▪Einteilung in dynamische Bereiche der Größe 2n MOBS:",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: Verschnitt ▪Externer Verschnitt ▪Außerhalb der zugeteilten Speicherbereich entstehen Speicherfragmente, die nicht mehr genutzt werden können. ▪Passiert bei den listenbasierten Strategien wie First Fit, Best Fit, … ▪Interner Verschnitt ▪Innerhalb der zugeteilten Speicherbereiche gibt es ungenutzten Speicher ▪Passiert z.B",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 22,
      "chunk_id": "p22c1",
      "title": "Diskussion: Verschnitt ▪Externer Verschnitt ▪Außerhalb der zugeteilten Speicherbereich entstehen Spe",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". bei Buddy, da die Anforderungen auf die nächstgrößere Zweierpotenz aufgerundet werden MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 22,
      "chunk_id": "p22c2",
      "title": "Diskussion: Verschnitt ▪Externer Verschnitt ▪Außerhalb der zugeteilten Speicherbereich entstehen Spe",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Zwischenfazit: Einsatz der Verfahren ▪Einsatz im Betriebssystem ▪Verwaltung des Systemspeichers ▪Zuteilung von Speicher an Prozesse und Betriebssystem ▪Einsatz innerhalb eines Prozesses ▪Verwaltung des Haldenspeichers (Heap) ▪erlaubt dynamische Allokation von Speicherbereichen durch den Prozess (malloc und free) ▪Einsatz für Bereiche des Sekundärspeichers ▪Verwaltung bestimmter Abschnitte des",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 23,
      "chunk_id": "p23c1",
      "title": "Zwischenfazit: Einsatz der Verfahren ▪Einsatz im Betriebssystem ▪Verwaltung des Systemspeichers ▪Zut",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "(malloc und free) ▪Einsatz für Bereiche des Sekundärspeichers ▪Verwaltung bestimmter Abschnitte des Sekundärspeichers, z.B",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 23,
      "chunk_id": "p23c2",
      "title": "Zwischenfazit: Einsatz der Verfahren ▪Einsatz im Betriebssystem ▪Verwaltung des Systemspeichers ▪Zut",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Speicherbereich für Prozessauslagerungen (swap space) MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 23,
      "chunk_id": "p23c3",
      "title": "Zwischenfazit: Einsatz der Verfahren ▪Einsatz im Betriebssystem ▪Verwaltung des Systemspeichers ▪Zut",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Grundlegende Aufgaben der Speicherverwaltung ▪Speichervergabe ▪Speicherverwaltung bei Mehrprogrammbetrieb ▪Ein/Auslagerung ▪Relokation ▪Segmentbasierte Adressabbildung ▪Seitenbasierte Adressabbildung MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 24,
      "chunk_id": "p24c1",
      "title": "Inhalt ▪Wiederholung ▪Grundlegende Aufgaben der Speicherverwaltung ▪Speichervergabe ▪Speicherverwalt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Ein/Auslagerung (swapping) ▪Segmente eines Prozesses werden auf Hintergrundspeicher ausgelagert und im Hauptspeicher freigegeben ▪z.B. zur Überbrückung von Wartezeiten bei E/A ▪Einlagern der Segmente in den Hauptspeicher am Ende der Wartezeit ▪Ein/Auslagerzeit ist hoch ▪Latenz der Festplatte (z.B. Positionierung des Schreib/Lesekopfes) ▪Übertragungszeit MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 25,
      "chunk_id": "p25c1",
      "title": "Ein/Auslagerung (swapping) ▪Segmente eines Prozesses werden auf Hintergrundspeicher ausgelagert und ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Ein/Auslagerung (2) ▪Adressen im Prozess sind normalerweise statisch gebunden ▪kann nur an gleiche Stelle im Hauptspeicher wieder eingelagert werden ▪Kollisionen mit eventuell neu im Hauptspeicher befindlichen Segmenten ▪Mögliche Lösung: Partitionierung des Hauptspeichers ▪In jeder Partition läuft nur ein Prozess ▪Einlagerung erfolgt wieder in die gleiche Partition ▪Speicher kann nicht optimal",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 26,
      "chunk_id": "p26c1",
      "title": "Ein/Auslagerung (2) ▪Adressen im Prozess sind normalerweise statisch gebunden ▪kann nur an gleiche S",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "nur ein Prozess ▪Einlagerung erfolgt wieder in die gleiche Partition ▪Speicher kann nicht optimal genutzt werden → Besser: Dynamische Belegung und Programmrelokation MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 26,
      "chunk_id": "p26c2",
      "title": "Ein/Auslagerung (2) ▪Adressen im Prozess sind normalerweise statisch gebunden ▪kann nur an gleiche S",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Adressbindung und Relokation ▪Problem: Maschinenbefehle benutzen Adressen ▪z.B",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 27,
      "chunk_id": "p27c1",
      "title": "Adressbindung und Relokation ▪Problem: Maschinenbefehle benutzen Adressen ▪z.B. ein Sprungbefehl in ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". ein Sprungbefehl in ein Unterprogramm oder ein Ladebefehl für eine Variable aus dem Datensegment ▪Es gibt verschiedene Möglichkeiten, die Adressbindung zwischen dem Befehl und seinem Operanden herzustellen… ▪Absolutes Binden (Compile/Link Time) ▪Adressen stehen fest → Programm kann nur an bestimmter Speicherstelle korrekt ablaufen MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 27,
      "chunk_id": "p27c2",
      "title": "Adressbindung und Relokation ▪Problem: Maschinenbefehle benutzen Adressen ▪z.B. ein Sprungbefehl in ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Adressbindung und Relokation (2) ▪Statisches Binden (Load Time) ▪Beim Laden (Starten) des Programms werden die absoluten Adressen angepasst (reloziert) → Relokationsinformation muss vom Compiler/Assembler geliefert wird ▪Dynamisches Binden (Execution Time) ▪Der Code greift grundsätzlich nur indirekt auf Operanden zu ▪Das Programm kann jederzeit im Speicher verschoben werden ▪Programme werden etwas",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 28,
      "chunk_id": "p28c1",
      "title": "Adressbindung und Relokation (2) ▪Statisches Binden (Load Time) ▪Beim Laden (Starten) des Programms ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "auf Operanden zu ▪Das Programm kann jederzeit im Speicher verschoben werden ▪Programme werden etwas größer und langsamer MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 28,
      "chunk_id": "p28c2",
      "title": "Adressbindung und Relokation (2) ▪Statisches Binden (Load Time) ▪Beim Laden (Starten) des Programms ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Adressbindung und Relokation (3) ▪Übersetzungsvorgang (Erzeugung der Relokationsinformationen) MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 29,
      "chunk_id": "p29c1",
      "title": "Adressbindung und Relokation (3) ▪Übersetzungsvorgang (Erzeugung der Relokationsinformationen) MOBS:",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Adressbindung und Relokation (4) ▪Bindeund Ladevorgang MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 30,
      "chunk_id": "p30c1",
      "title": "Adressbindung und Relokation (4) ▪Bindeund Ladevorgang MOBS: 07Speicherverwaltung",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Adressbindung und Relokation (5) MOBS: 07Speicherverwaltung ▪Relokationsinformation im Bindemodul ▪erlaubt das Binden von Modulen in beliebige Programme ▪Relokationsinformation im Lademodul ▪erlaubt das Laden des Programms an beliebige Speicherstellen ▪absolute Adressen werden erst beim Laden generiert ▪Dynamisches Binden mit CompilerUnterstützung ▪Programm benutzt keine absoluten Adressen und",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 31,
      "chunk_id": "p31c1",
      "title": "Adressbindung und Relokation (5) MOBS: 07Speicherverwaltung ▪Relokationsinformation im Bindemodul ▪e",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "▪Dynamisches Binden mit CompilerUnterstützung ▪Programm benutzt keine absoluten Adressen und kann daher immer an beliebige Speicherstellen geladen werden ▪„Position Independent Code“ ▪Dynamisches Binden mit MMUUnterstützung: ▪Abbildungsschritt von „logischen“ auf „physikalische“ Adressen ▪Relokation beim Binden reicht (außer für „Shared Libraries“)",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 31,
      "chunk_id": "p31c2",
      "title": "Adressbindung und Relokation (5) MOBS: 07Speicherverwaltung ▪Relokationsinformation im Bindemodul ▪e",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Grundlegende Aufgaben der Speicherverwaltung ▪Speichervergabe ▪Speicherverwaltung bei Mehrprogrammbetrieb ▪Segmentbasierte Adressabbildung ▪Seitenbasierte Adressabbildung MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 32,
      "chunk_id": "p32c1",
      "title": "Inhalt ▪Wiederholung ▪Grundlegende Aufgaben der Speicherverwaltung ▪Speichervergabe ▪Speicherverwalt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Segmentierung ▪Hardwareunterstützung: Abbildung logischer auf physikalische Adressen MOBS: 07Speicherverwaltung Das Segment des logischen Adressraums kann an jeder beliebigen Stelle im physikalischen Adressraum liegen. Das Betriebssystem bestimmt, wo ein Segment im physikalischen Adressraum tatsächlich liegen soll.",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 33,
      "chunk_id": "p33c1",
      "title": "Segmentierung ▪Hardwareunterstützung: Abbildung logischer auf physikalische Adressen MOBS: 07Speiche",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Segmentierung (2) ▪Realisierung mit Übersetzungstabelle (pro Prozess) MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 34,
      "chunk_id": "p34c1",
      "title": "Segmentierung (2) ▪Realisierung mit Übersetzungstabelle (pro Prozess) MOBS: 07Speicherverwaltung",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Segmentierung (3) MOBS: 07Speicherverwaltung ▪Hardware heißt MMU (Memory Management Unit) ▪Schutz vor Segmentübertretung ▪Rechte zum Lesen, Schreiben und Ausführen von Befehlen, die von der MMU geprüft werden ▪Trap zeigt Speicherverletzung an ▪Programme und Betriebssystem voreinander geschützt ▪Prozessumschaltung durch Austausch der Segmentbasis ▪jeder Prozess hat eigene Übersetzungstabelle",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 35,
      "chunk_id": "p35c1",
      "title": "Segmentierung (3) MOBS: 07Speicherverwaltung ▪Hardware heißt MMU (Memory Management Unit) ▪Schutz vo",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Segmentierung (4) MOBS: 07Speicherverwaltung ▪Einund Auslagerung vereinfacht ▪nach Einlagerung an beliebige Stelle muss lediglich die Übersetzungstabelle angepasst werden ▪Gemeinsame Segmente möglich ▪Befehlssegmente ▪Datensegmente (Shared Memory)",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 36,
      "chunk_id": "p36c1",
      "title": "Segmentierung (4) MOBS: 07Speicherverwaltung ▪Einund Auslagerung vereinfacht ▪nach Einlagerung an be",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Segmentierung (5) MOBS: 07Speicherverwaltung Probleme… ▪Fragmentierung des Speichers durch häufiges Ein/Auslagern oder Starten/Beenden von Prozessen ▪Es entstehen kleine, nicht nutzbare Lücken: externer Verschnitt ▪Kompaktifizieren hilft ▪Segmente werden verschoben, um Lücken zu schließen; Segmenttabelle wird jeweils angepasst ▪Kostet aber Zeit ▪Lange E/AZeiten für Einund Auslagerung ▪Nicht alle",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 37,
      "chunk_id": "p37c1",
      "title": "Segmentierung (5) MOBS: 07Speicherverwaltung Probleme… ▪Fragmentierung des Speichers durch häufiges ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "wird jeweils angepasst ▪Kostet aber Zeit ▪Lange E/AZeiten für Einund Auslagerung ▪Nicht alle Teile eines Segments werden gleich häufig genutzt",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 37,
      "chunk_id": "p37c2",
      "title": "Segmentierung (5) MOBS: 07Speicherverwaltung Probleme… ▪Fragmentierung des Speichers durch häufiges ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Kompaktifizieren MOBS: 07Speicherverwaltung ▪Verschieben von Segmenten ▪Erzeugen von weniger aber größeren Lücken ▪Verringern des Verschnitts ▪aufwendige Operation, abhängig von der Größe der verschobenen Segmente",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 38,
      "chunk_id": "p38c1",
      "title": "Kompaktifizieren MOBS: 07Speicherverwaltung ▪Verschieben von Segmenten ▪Erzeugen von weniger aber gr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Grundlegende Aufgaben der Speicherverwaltung ▪Speichervergabe ▪Speicherverwaltung bei Mehrprogrammbetrieb ▪Segmentbasierte Adressabbildung ▪Seitenbasierte Adressabbildung MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 39,
      "chunk_id": "p39c1",
      "title": "Inhalt ▪Wiederholung ▪Grundlegende Aufgaben der Speicherverwaltung ▪Speichervergabe ▪Speicherverwalt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Seitenadressierung (paging) ▪Einteilung des logischen Adressraums in gleichgroße Seiten, die an beliebigen Stellen im physikalischen Adressraum liegen können MOBS: 07Speicherverwaltung ▪Lösung des Fragmentierungsproblems ▪keine Kompaktifizierung mehr nötig ▪Vereinfacht Speicherbelegung und Ein/Auslagerungen",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 40,
      "chunk_id": "p40c1",
      "title": "Seitenadressierung (paging) ▪Einteilung des logischen Adressraums in gleichgroße Seiten, die an beli",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "MMU mit SeitenKacheltabelle ▪Tabelle setzt Seiten in Kacheln um MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 41,
      "chunk_id": "p41c1",
      "title": "MMU mit SeitenKacheltabelle ▪Tabelle setzt Seiten in Kacheln um MOBS: 07Speicherverwaltung",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "▪Seitenadressierung erzeugt internen Verschnitt ▪letzte Seite eventuell nicht vollständig genutzt ▪Seitengröße ▪kleine Seiten verringern internen Verschnitt, vergrößern aber die SeitenKacheltabelle (und umgekehrt) ▪übliche Größen: 512 Bytes — 8192 Bytes ▪große Tabelle, die im Speicher gehalten werden muss ▪viele implizite Speicherzugriffe nötig ▪nur ein „Segment“ pro Kontext ▪sinngemäße Nutzung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 42,
      "chunk_id": "p42c1",
      "title": "▪Seitenadressierung erzeugt internen Verschnitt ▪letzte Seite eventuell nicht vollständig genutzt ▪S",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "muss ▪viele implizite Speicherzugriffe nötig ▪nur ein „Segment“ pro Kontext ▪sinngemäße Nutzung des Speichers schwerer zu kontrollieren (push/pop nur auf „Stack“, Ausführung nur von „Text“, ...) → Kombination mit Segmentierung MMU mit SeitenKacheltabelle (2) MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 42,
      "chunk_id": "p42c2",
      "title": "▪Seitenadressierung erzeugt internen Verschnitt ▪letzte Seite eventuell nicht vollständig genutzt ▪S",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Segmentierung und Seitenadressierung MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 43,
      "chunk_id": "p43c1",
      "title": "Segmentierung und Seitenadressierung MOBS: 07Speicherverwaltung",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Segmentierung und Seitenadressierung (2) ▪Noch mehr implizite Speicherzugriffe ▪Große Tabellen im Speicher ▪Vermischung der Konzepte ▪Noch immer Ein/Auslagerung kompletter Segmente → Mehrstufige Seitenadressierung mit Einund Auslagerung MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 44,
      "chunk_id": "p44c1",
      "title": "Segmentierung und Seitenadressierung (2) ▪Noch mehr implizite Speicherzugriffe ▪Große Tabellen im Sp",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Ein/Auslagerung von Seiten ▪Es ist nicht nötig ein gesamtes Segment ausbzw",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 45,
      "chunk_id": "p45c1",
      "title": "Ein/Auslagerung von Seiten ▪Es ist nicht nötig ein gesamtes Segment ausbzw. einzulagern ▪Seiten könn",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". einzulagern ▪Seiten können einzeln einund ausgelagert werden ▪HardwareUnterstützung ▪Ist das Präsenzbit gesetzt, bleibt alles wie bisher ▪Ist das Präsenzbit gelöscht, wird ein Trap ausgelöst (page fault) ▪Die TrapBehandlung kann nun für das Laden der Seite vom Hintergrundspeicher sorgen und den Speicherzugriff danach wiederholen (benötigt HWSupport in der CPU) MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 45,
      "chunk_id": "p45c2",
      "title": "Ein/Auslagerung von Seiten ▪Es ist nicht nötig ein gesamtes Segment ausbzw. einzulagern ▪Seiten könn",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Mehrstufige Seitenadressierung ▪Beispiel: zweifach indirekte Seitenadressierung ▪Präsenzbit auch für jeden Eintrag in den höheren Stufen ▪Tabellen werden ausund einlagerbar MOBS: 07Speicherverwaltung ▪Tabelle können bei Zugriff (=Bedarf) erzeugt werden (spart Speicher!) ▪Aber: Noch mehr implizite Speicherzugriffe",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 46,
      "chunk_id": "p46c1",
      "title": "Mehrstufige Seitenadressierung ▪Beispiel: zweifach indirekte Seitenadressierung ▪Präsenzbit auch für",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "▪Schneller Registersatz wird konsultiert bevor auf die SKT zugegriffen wird: Translation LookAside Buffer (TLB) MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 47,
      "chunk_id": "p47c1",
      "title": "▪Schneller Registersatz wird konsultiert bevor auf die SKT zugegriffen wird: Translation LookAside B",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "▪Schneller Zugriff auf Seitenabbildung, falls Information im vollassoziativen Speicher des TLB ▪keine impliziten Speicherzugriffe nötig ▪Bei Kontextwechseln muss TLB gelöscht werden (flush) ▪Bei Zugriffen auf eine nicht im TLB enthaltene Seite wird die entsprechende Zugriffsinformation in den TLB eingetragen ▪Ein alter Eintrag muss zur Ersetzung ausgesucht werden ▪TLB Größe ▪Intel Core i7: 512",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 48,
      "chunk_id": "p48c1",
      "title": "▪Schneller Zugriff auf Seitenabbildung, falls Information im vollassoziativen Speicher des TLB ▪kein",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "eingetragen ▪Ein alter Eintrag muss zur Ersetzung ausgesucht werden ▪TLB Größe ▪Intel Core i7: 512 Einträge, Seitengröße 4K ▪UltraSPARC T2: Daten TLB = 128, Code TLB = 64, Seitengröße 8K ▪Größere TLBs bei den üblichen Taktraten zur Zeit nicht möglich Translation LookAside Buffer (2) MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 48,
      "chunk_id": "p48c2",
      "title": "▪Schneller Zugriff auf Seitenabbildung, falls Information im vollassoziativen Speicher des TLB ▪kein",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "▪Bei großen logischen Adressräumen (z.B. 64 Bit): ▪Klassische SeitenKacheltabellen sehr groß (oder…) ▪Sehr viele Abbildungsstufen ▪Tabellen sehr dünn besetzt → Invertierte SeitenKacheltabelle (Inverted Page Table) Invertierte SeitenKacheltabelle MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 49,
      "chunk_id": "p49c1",
      "title": "▪Bei großen logischen Adressräumen (z.B. 64 Bit): ▪Klassische SeitenKacheltabellen sehr groß (oder…)",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Invertierte SeitenKacheltabelle (2) MOBS: 07Speicherverwaltung ▪Vorteile ▪wenig Platz zur Speicherung der Abbildung notwendig ▪Tabelle kann immer im Hauptspeicher gehalten werden ▪Nachteile ▪Sharing von Kacheln schwer zu realisieren ▪prozesslokale Datenstrukturen zusätzlich nötig für Seiten, die ausgelagert sind ▪Suche in der KST ist aufwendig ▪Einsatz von Assoziativspeichern und Hashfunktionen",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 50,
      "chunk_id": "p50c1",
      "title": "Invertierte SeitenKacheltabelle (2) MOBS: 07Speicherverwaltung ▪Vorteile ▪wenig Platz zur Speicherun",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "sind ▪Suche in der KST ist aufwendig ▪Einsatz von Assoziativspeichern und Hashfunktionen ▪Trotz der Nachteile setzen heute viele Prozessorhersteller bei 64BitArchitekturen auf diese Form der Adressumsetzung ▪UltraSparc, PowerPC, IA64, (Alpha), …",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 50,
      "chunk_id": "p50c2",
      "title": "Invertierte SeitenKacheltabelle (2) MOBS: 07Speicherverwaltung ▪Vorteile ▪wenig Platz zur Speicherun",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Zusammenfassung ▪Bei der Speicherverwaltung arbeitet das Betriebssystem sehr eng mit der Hardware zusammen ▪Segmentierung und/oder Seitenadressierung ▪Durch die implizite Indirektion beim Speicherzugriff können Programme und Daten unter der Kontrolle des Betriebssystems im laufenden Betrieb beliebig verschoben werden ▪Zusätzlich sind diverse strategische Entscheidungen zu treffen",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 51,
      "chunk_id": "p51c1",
      "title": "Zusammenfassung ▪Bei der Speicherverwaltung arbeitet das Betriebssystem sehr eng mit der Hardware zu",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Betrieb beliebig verschoben werden ▪Zusätzlich sind diverse strategische Entscheidungen zu treffen ▪Platzierungsstrategie (First Fit, Best Fit, Buddy, …) ▪Unterscheiden sich bzgl",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 51,
      "chunk_id": "p51c2",
      "title": "Zusammenfassung ▪Bei der Speicherverwaltung arbeitet das Betriebssystem sehr eng mit der Hardware zu",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Verschnitt sowie Belegungsund Freigabeaufwand ▪Strategieauswahl hängt vom erwarteten Anwendungsprofil ab ▪Bei Ein/Auslagerung von Segmenten oder Seiten: ▪Ladestrategie ▪Ersetzungsstrategie MOBS: 07Speicherverwaltung",
    "metadata": {
      "source": "MOBS_07_Speicherverwaltung.pdf",
      "page": 51,
      "chunk_id": "p51c3",
      "title": "Zusammenfassung ▪Bei der Speicherverwaltung arbeitet das Betriebssystem sehr eng mit der Hardware zu",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – Einund Ausgabe mit Material von Olaf Spinczyk (Universität Osnabrück) und Horst Schirmeier (TU Dortmund)",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 1,
      "chunk_id": "p1c1",
      "title": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – Einund Ausgabe mit Material von Olaf Spinczyk (Un",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Ein/AusgabeHardware ▪Geräteprogrammierung ▪Aufgaben des Betriebssystems MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 2,
      "chunk_id": "p2c1",
      "title": "Inhalt ▪Wiederholung ▪Ein/AusgabeHardware ▪Geräteprogrammierung ▪Aufgaben des Betriebssystems MOBS: ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Ein/AusgabeHardware ▪Geräteprogrammierung ▪Aufgaben des Betriebssystems MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 3,
      "chunk_id": "p3c1",
      "title": "Inhalt ▪Wiederholung ▪Ein/AusgabeHardware ▪Geräteprogrammierung ▪Aufgaben des Betriebssystems MOBS: ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Ein/AusgabeHardware ▪Geräteprogrammierung ▪Aufgaben des Betriebssystems MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 4,
      "chunk_id": "p4c1",
      "title": "Inhalt ▪Wiederholung ▪Ein/AusgabeHardware ▪Geräteprogrammierung ▪Aufgaben des Betriebssystems MOBS: ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Wiederholung ▪In den bisherigen Vorlesungen ▪CPU ▪Hauptspeicher ▪In der kommenden Vorlesung ▪Hintergrundspeicher ▪Heute: E/AGeräte MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 5,
      "chunk_id": "p5c1",
      "title": "Wiederholung ▪In den bisherigen Vorlesungen ▪CPU ▪Hauptspeicher ▪In der kommenden Vorlesung ▪Hinterg",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Ein/AusgabeHardware ▪Geräteprogrammierung ▪Aufgaben des Betriebssystems MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 6,
      "chunk_id": "p6c1",
      "title": "Inhalt ▪Wiederholung ▪Ein/AusgabeHardware ▪Geräteprogrammierung ▪Aufgaben des Betriebssystems MOBS: ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Anbindung von E/AGeräten MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 7,
      "chunk_id": "p7c1",
      "title": "Anbindung von E/AGeräten MOBS: 09 – Einund Ausgabe",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Beispiel: PC Tastatur ▪Serielle zeichenweise Kommunikation ▪Tastatur ist „intelligent“ (besitzt eigenen Prozessor) MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 8,
      "chunk_id": "p8c1",
      "title": "Beispiel: PC Tastatur ▪Serielle zeichenweise Kommunikation ▪Tastatur ist „intelligent“ (besitzt eige",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Beispiel: CGA Videocontroller ▪Kommunikation über Videosignal ▪Umwandlung des Bildschirmspeicherinhalts in ein Bild (80x25 Z.) MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 9,
      "chunk_id": "p9c1",
      "title": "Beispiel: CGA Videocontroller ▪Kommunikation über Videosignal ▪Umwandlung des Bildschirmspeicherinha",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Beispiel: IDE Plattencontroller ▪Kommunikation über ATBefehle ▪Blockweiser wahlfreier Zugriff auf Datenblöcke MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 10,
      "chunk_id": "p10c1",
      "title": "Beispiel: IDE Plattencontroller ▪Kommunikation über ATBefehle ▪Blockweiser wahlfreier Zugriff auf Da",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Beispiel: Ethernet Controller ▪Serielle paketbasierte Buskommunikation ▪Pakete haben eine variable Größe und enthalten Adressen MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 11,
      "chunk_id": "p11c1",
      "title": "Beispiel: Ethernet Controller ▪Serielle paketbasierte Buskommunikation ▪Pakete haben eine variable G",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Geräteklassen ▪Zeichenorientierte Geräte ▪Tastatur, Drucker, Modem, Maus, … ▪Meist rein sequentieller Zugriff, selten wahlfreie Positionierung ▪Blockorientierte Geräte ▪Festplatte, Diskette, CDROM, DVD, Bandlaufwerke, … ▪Meist wahlfreier blockweiser Zugriff (random access) MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 12,
      "chunk_id": "p12c1",
      "title": "Geräteklassen ▪Zeichenorientierte Geräte ▪Tastatur, Drucker, Modem, Maus, … ▪Meist rein sequentielle",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Geräteklassen ▪Andere Geräte passen weniger leicht in dieses Schema ▪Grafikkarten (insbesondere 3DBeschleunigung) ▪Netzwerkkarten (Protokolle, Adressierung, Broadcast/Multicast, Nachrichtenfilterung, …) ▪Zeitgeberbaustein (Einmalige oder periodische Unterbrechungen) ▪… MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 13,
      "chunk_id": "p13c1",
      "title": "Geräteklassen ▪Andere Geräte passen weniger leicht in dieses Schema ▪Grafikkarten (insbesondere 3DBe",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Unterbrechungen… ▪signalisieren, dass die Software aktiv werden muss MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 14,
      "chunk_id": "p14c1",
      "title": "Unterbrechungen… ▪signalisieren, dass die Software aktiv werden muss MOBS: 09 – Einund Ausgabe",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Direct Memory Access (DMA) … ▪wird von komplexen Controllern benutzt, um Daten unabhängig von der CPU in den bzw. aus dem Hauptspeicher zu transferieren MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 15,
      "chunk_id": "p15c1",
      "title": "Direct Memory Access (DMA) … ▪wird von komplexen Controllern benutzt, um Daten unabhängig von der CP",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Ein/AusgabeHardware ▪Geräteprogrammierung ▪Aufgaben des Betriebssystems MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 16,
      "chunk_id": "p16c1",
      "title": "Inhalt ▪Wiederholung ▪Ein/AusgabeHardware ▪Geräteprogrammierung ▪Aufgaben des Betriebssystems MOBS: ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Ein/Ausgabeadressraum ▪Zugriff auf ControllerRegister und ControllerSpeicher erfolgt je nach Systemarchitektur … MOBS: 09 – Einund Ausgabe ▪(a) Separater E/AAdressraum ▪anzusprechen über spezielle Maschineninstruktionen ▪(b) Gemeinsamer Adressraum (MemoryMapped I/O) ▪(c) Hybride Architektur",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 17,
      "chunk_id": "p17c1",
      "title": "Ein/Ausgabeadressraum ▪Zugriff auf ControllerRegister und ControllerSpeicher erfolgt je nach Systema",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Arbeitsweise von Gerätetreibern ▪Je nach Fähigkeiten des Geräts erfolgt E/A mittels … ▪Polling (oder „Programmierte E/A“), ▪Unterbrechungen oder ▪DMA ▪Beispiel: Drucken einer Textzeile MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 18,
      "chunk_id": "p18c1",
      "title": "Arbeitsweise von Gerätetreibern ▪Je nach Fähigkeiten des Geräts erfolgt E/A mittels … ▪Polling (oder",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Polling (oder „Programmierte E/A“) ▪… bedeutet aktives Warten auf ein Ein/Ausgabegerät MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 19,
      "chunk_id": "p19c1",
      "title": "Polling (oder „Programmierte E/A“) ▪… bedeutet aktives Warten auf ein Ein/Ausgabegerät MOBS: 09 – Ei",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Unterbrechungsgetriebene E/A ▪… bedeutet, dass die CPU während der Wartezeit einem anderen Prozess zugeteilt werden kann MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 20,
      "chunk_id": "p20c1",
      "title": "Unterbrechungsgetriebene E/A ▪… bedeutet, dass die CPU während der Wartezeit einem anderen Prozess z",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "DMAgetriebene E/A ▪… bedeutet, dass die Software nicht mehr für den Datentransfer zwischen Controller und Hauptspeicher zuständig ist ▪Die CPU wird weiter entlastet MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 21,
      "chunk_id": "p21c1",
      "title": "DMAgetriebene E/A ▪… bedeutet, dass die Software nicht mehr für den Datentransfer zwischen Controlle",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: Unterbrechungen ▪Kontextsicherung ▪Wird teilweise von der CPU selbst erledigt ▪z.B. Statusregister und Rücksprungadresse, aber nur das Minimum ▪Alle veränderten Register müssen gesichert und am Ende der Behandlung wiederhergestellt werden ▪Behandlungsroutine möglichst kurz: ▪Während der Unterbrechungsbehandlung werden i.d.R",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 22,
      "chunk_id": "p22c1",
      "title": "Diskussion: Unterbrechungen ▪Kontextsicherung ▪Wird teilweise von der CPU selbst erledigt ▪z.B. Stat",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". weitere Unterbrechungen unterdrückt ▪Es droht der Verlust von Unterbrechungen ▪Möglichst nur den Prozess wecken, der auf E/ABeendigung wartet MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 22,
      "chunk_id": "p22c2",
      "title": "Diskussion: Unterbrechungen ▪Kontextsicherung ▪Wird teilweise von der CPU selbst erledigt ▪z.B. Stat",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: Direct Memory Access ▪Caches ▪Heutige Prozessoren arbeiten mit DatenCaches; DMA läuft am Cache vorbei! ▪Vor dem Aufsetzen eines DMAVorgangs muss der CacheInhalt in den Hauptspeicher zurückgeschrieben und invalidiert werden bzw",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 23,
      "chunk_id": "p23c1",
      "title": "Diskussion: Direct Memory Access ▪Caches ▪Heutige Prozessoren arbeiten mit DatenCaches; DMA läuft am",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". der Cache darf für die entsprechende Speicherregion nicht eingesetzt werden ▪Speicherschutz ▪Heutige Prozessoren verwenden eine MMU zur Isolation von Prozessen und zum Schutz des Betriebssystems; DMA läuft am Speicherschutz vorbei! ▪Fehler beim Aufsetzen von DMAVorgängen sind extrem kritisch ▪Anwendungsprozesse dürfen DMAController nie direkt programmieren! MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 23,
      "chunk_id": "p23c2",
      "title": "Diskussion: Direct Memory Access ▪Caches ▪Heutige Prozessoren arbeiten mit DatenCaches; DMA läuft am",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Ein/AusgabeHardware ▪Geräteprogrammierung ▪Aufgaben des Betriebssystems MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 24,
      "chunk_id": "p24c1",
      "title": "Inhalt ▪Wiederholung ▪Ein/AusgabeHardware ▪Geräteprogrammierung ▪Aufgaben des Betriebssystems MOBS: ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Aufgaben des Betriebssystems ▪Geräteabstraktionen schaffen ▪Einheitlich, einfach, aber vielseitig ▪Ein/Ausgabenprimitiven bereitstellen ▪Synchron und/oder asynchron ▪Pufferung ▪Falls das Gerät bzw. der Empfängerprozess noch nicht bereit ist ▪Geräteansteuerung ▪Möglichst effizient unter Beachtung mechanischer Eigenschaften MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 25,
      "chunk_id": "p25c1",
      "title": "Aufgaben des Betriebssystems ▪Geräteabstraktionen schaffen ▪Einheitlich, einfach, aber vielseitig ▪E",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Weitere Aufgaben des Betriebssystems ▪Ressourcenzuordnung verwalten ▪Bei teilbaren Geräte: Welcher Prozess darf wo lesen/schreiben? ▪Bei unteilbaren Geräte: Zeitweise Reservierungen ▪Stromsparzustände verwalten ▪Plug&Play unterstützen ▪… MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 26,
      "chunk_id": "p26c1",
      "title": "Weitere Aufgaben des Betriebssystems ▪Ressourcenzuordnung verwalten ▪Bei teilbaren Geräte: Welcher P",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX: Geräteabstraktionen ▪Periphere Geräte werden als Spezialdateien repräsentiert ▪Geräte können wie Dateien mit Leseund Schreiboperationen angesprochen werden ▪Öffnen der Spezialdateien schafft eine Verbindung zum Gerät, die durch einen Treiber hergestellt wird ▪Direkter Durchgriff vom Anwender auf den Treiber ▪Blockorientierte Spezialdateien (block devices) ▪Plattenlaufwerke, Bandlaufwerke,",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 27,
      "chunk_id": "p27c1",
      "title": "UNIX: Geräteabstraktionen ▪Periphere Geräte werden als Spezialdateien repräsentiert ▪Geräte können w",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "auf den Treiber ▪Blockorientierte Spezialdateien (block devices) ▪Plattenlaufwerke, Bandlaufwerke, Floppy Disks, CDROMs ▪Zeichenorientierte Spezialdateien (character devices) ▪Serielle Schnittstellen, Drucker, Audiokanäle etc",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 27,
      "chunk_id": "p27c2",
      "title": "UNIX: Geräteabstraktionen ▪Periphere Geräte werden als Spezialdateien repräsentiert ▪Geräte können w",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 27,
      "chunk_id": "p27c3",
      "title": "UNIX: Geräteabstraktionen ▪Periphere Geräte werden als Spezialdateien repräsentiert ▪Geräte können w",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX: Geräteabstraktionen ▪Eindeutige Beschreibung der Geräte durch ein 3Tupel: (Gerätetyp, Major Number, Minor Number) ▪Gerätetyp: Block Device, Character Device ▪Major Number: Auswahlnummer für einen Treiber ▪Minor Number: Auswahl eines Gerätes innerhalb eines Treibers MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 28,
      "chunk_id": "p28c1",
      "title": "UNIX: Geräteabstraktionen ▪Eindeutige Beschreibung der Geräte durch ein 3Tupel: (Gerätetyp, Major Nu",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX: Geräteabstraktionen ▪Auszug aus dem Listing des /dev Verzeichnisses MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 29,
      "chunk_id": "p29c1",
      "title": "UNIX: Geräteabstraktionen ▪Auszug aus dem Listing des /dev Verzeichnisses MOBS: 09 – Einund Ausgabe",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX: Zugriffsprimitiven Das Wichtigste in Kürze … (siehe man 2 …) ▪int open(const char *devname, int flags) ▪„Öffnen“ eines Geräts. Liefert Dateideskriptor als Rückgabewert ▪off_t lseek(int fd, off_t offset, int whence) ▪Positioniert den Schreib/Lesezeiger – natürlich nur bei Geräten mit wahlfreiem Zugriff ▪ssize_t read(int fd, void *buf, size_t count) ▪Einlesen von max",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 30,
      "chunk_id": "p30c1",
      "title": "UNIX: Zugriffsprimitiven Das Wichtigste in Kürze … (siehe man 2 …) ▪int open(const char *devname, in",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". count Bytes in Puffer buf von Deskriptor fd MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 30,
      "chunk_id": "p30c2",
      "title": "UNIX: Zugriffsprimitiven Das Wichtigste in Kürze … (siehe man 2 …) ▪int open(const char *devname, in",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX: Zugriffsprimitiven Das Wichtigste in Kürze … (siehe man 2 …) ▪ssize_t write(int fd, const void *buf, size_t count) ▪Schreiben von count Bytes aus Puffer buf auf Deskriptor fd ▪int close(int fd) ▪„Schließen“ eines Geräts. Dateideskriptor fd kann danach nicht mehr benutzt werden MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 31,
      "chunk_id": "p31c1",
      "title": "UNIX: Zugriffsprimitiven Das Wichtigste in Kürze … (siehe man 2 …) ▪ssize_t write(int fd, const void",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Pufferung bei E/AOperationen MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 32,
      "chunk_id": "p32c1",
      "title": "Pufferung bei E/AOperationen MOBS: 09 – Einund Ausgabe",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Pufferung bei E/AOperationen ▪Probleme ohne Datenpuffer im Betriebssystem: ▪Daten, die eintreffen bevor read ausgeführt wurde (z.B",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 33,
      "chunk_id": "p33c1",
      "title": "Pufferung bei E/AOperationen ▪Probleme ohne Datenpuffer im Betriebssystem: ▪Daten, die eintreffen be",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". von der Tastatur), müssten verloren gehen ▪Wenn ein Ausgabegerät beschäftigt ist, müsste write scheitern oder den Prozess blockieren, bis das Gerät wieder bereit ist ▪Ein Prozess, der eine E/AOperation durchführt, kann nicht ausgelagert werden MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 33,
      "chunk_id": "p33c2",
      "title": "Pufferung bei E/AOperationen ▪Probleme ohne Datenpuffer im Betriebssystem: ▪Daten, die eintreffen be",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "E/AEinzelpuffer MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 34,
      "chunk_id": "p34c1",
      "title": "E/AEinzelpuffer MOBS: 09 – Einund Ausgabe",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "E/AEinzelpuffer ▪Einlesen ▪Daten können vom System entgegengenommen werden, auch wenn der Leserprozess noch nicht read aufgerufen hat ▪Bei Blockgeräten kann der nächste Block vorausschauend gelesen werden, während der vorherige verarbeitet wird ▪Prozess kann problemlos ausgelagert werden. DMA erfolgt in Puffer ▪Schreiben ▪Daten werden kopiert. Aufrufer blockiert nicht",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 35,
      "chunk_id": "p35c1",
      "title": "E/AEinzelpuffer ▪Einlesen ▪Daten können vom System entgegengenommen werden, auch wenn der Leserproze",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". DMA erfolgt in Puffer ▪Schreiben ▪Daten werden kopiert. Aufrufer blockiert nicht. Datenpuffer im Benutzeradressraum kann sofort wiederverwendet werden MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 35,
      "chunk_id": "p35c2",
      "title": "E/AEinzelpuffer ▪Einlesen ▪Daten können vom System entgegengenommen werden, auch wenn der Leserproze",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "E/AWechselpuffer MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 36,
      "chunk_id": "p36c1",
      "title": "E/AWechselpuffer MOBS: 09 – Einund Ausgabe",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "E/AWechselpuffer ▪Einlesen ▪Während Daten vom E/AGerät in den einen Puffer transferiert werden, kann der andere Pufferinhalt in den Empfängeradressraum kopiert werden ▪Schreiben ▪Während Daten aus einem Puffer zum E/AGerät transferiert werden, kann der andere Puffer bereits mit neuen Daten aus dem Senderadressraum gefüllt werden MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 37,
      "chunk_id": "p37c1",
      "title": "E/AWechselpuffer ▪Einlesen ▪Während Daten vom E/AGerät in den einen Puffer transferiert werden, kann",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "E/ARingpuffer MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 38,
      "chunk_id": "p38c1",
      "title": "E/ARingpuffer MOBS: 09 – Einund Ausgabe",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "E/ARingpuffer ▪Einlesen ▪Viele Daten können gepuffert werden, auch wenn der Leserprozess nicht schnell genug readAufrufe tätigt ▪Schreiben ▪Ein Schreiberprozess kann mehrfach writeAufrufe tätigen, ohne blockiert werden zu müssen MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 39,
      "chunk_id": "p39c1",
      "title": "E/ARingpuffer ▪Einlesen ▪Viele Daten können gepuffert werden, auch wenn der Leserprozess nicht schne",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: E/APuffer ▪E/APuffer entkoppeln die E/AOperationen der Nutzerprozesse vom Gerätetreiber ▪Kurzfristig lässt sich eine erhöhte Ankunftsrate an E/AAufträgen bewältigen ▪Langfristig bleibt auch bei noch so vielen Puffern ein Blockieren von Prozessen (oder Verlust von Daten) nicht aus MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 40,
      "chunk_id": "p40c1",
      "title": "Diskussion: E/APuffer ▪E/APuffer entkoppeln die E/AOperationen der Nutzerprozesse vom Gerätetreiber ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: E/APuffer ▪Puffer haben ihren Preis ▪Verwaltung der Pufferstruktur ▪Speicherplatz ▪Zeit für das Kopieren ▪In komplexen Systemen wird teilweise mehrfach gepuffert ▪Beispiel: Schichten von Netzwerkprotokollen ▪Nach Möglichkeit vermeiden! MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 41,
      "chunk_id": "p41c1",
      "title": "Diskussion: E/APuffer ▪Puffer haben ihren Preis ▪Verwaltung der Pufferstruktur ▪Speicherplatz ▪Zeit ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Geräteansteuerung: Bsp. Platte ▪Treiber muss mechanische Eigenschaften beachten! ▪Plattentreiber hat in der Regel mehrere Aufträge in seiner Warteschlange ▪Eine bestimmte Ordnung der Ausführung kann Effizienz steigern ▪Zusammensetzung der Bearbeitungszeit eines Auftrags: ▪Positionierungszeit: abhängig von akt",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 42,
      "chunk_id": "p42c1",
      "title": "Geräteansteuerung: Bsp. Platte ▪Treiber muss mechanische Eigenschaften beachten! ▪Plattentreiber hat",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Stellung des Plattenarms ▪Rotationsverzögerung: Zeit bis der Magnetkopf den Sektor bestreicht ▪Übertragungszeit: Zeit zur Übertragung der eigentlichen Daten ▪Ansatzpunkt: Positionierungszeit MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 42,
      "chunk_id": "p42c2",
      "title": "Geräteansteuerung: Bsp. Platte ▪Treiber muss mechanische Eigenschaften beachten! ▪Plattentreiber hat",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Geräteansteuerung: Bsp. Platte MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 43,
      "chunk_id": "p43c1",
      "title": "Geräteansteuerung: Bsp. Platte MOBS: 09 – Einund Ausgabe",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "E/AScheduling: FIFO ▪Bearbeitung gemäß Ankunft des Auftrags (First In First Out) ▪Referenzfolge (Folge von Spurnummern): 98, 183, 37, 122, 14, 124, 65, 67 ▪Aktuelle Spur: 53 ▪Weite Bewegungen des Schwenkarms: mittlere Bearbeitungsdauer lang! MOBS: 09 – Einund Ausgabe ▪Gesamtzahl der Spurwechsel: 640",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 44,
      "chunk_id": "p44c1",
      "title": "E/AScheduling: FIFO ▪Bearbeitung gemäß Ankunft des Auftrags (First In First Out) ▪Referenzfolge (Fol",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "E/AScheduling: SSTF ▪Es wird der Auftrag mit der kürzesten Positionierzeit vorgezogen (Shortest Seek Time First) ▪Gleiche Referenzfolge ▪(Annahme: Positionierungszeit proportional zum Spurabstand) ▪ Gesamtzahl der Spurwechsel: 236 ▪ähnlich wie SJF kann auch SSTF zur Aushungerung führen! ▪ noch nicht optimal MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 45,
      "chunk_id": "p45c1",
      "title": "E/AScheduling: SSTF ▪Es wird der Auftrag mit der kürzesten Positionierzeit vorgezogen (Shortest Seek",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "E/AScheduling: Elevator ▪Bewegung des Plattenarms in eine Richtung bis keine Aufträge mehr vorhanden sind (Fahrstuhlstrategie) ▪Gleiche Referenzfolge (Annahme: bisherige Kopfbewegung Richtung 0) ▪Gesamtzahl der Spurwechsel: 208 ▪Neue Aufträge werden miterledigt ohne zusätzliche Positionierungszeit ▪Keine Aushungerung, lange Wartezeiten aber nicht ausgeschlossen MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 46,
      "chunk_id": "p46c1",
      "title": "E/AScheduling: Elevator ▪Bewegung des Plattenarms in eine Richtung bis keine Aufträge mehr vorhanden",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: E/AScheduling heute ▪Platten sind intelligente Geräte ▪Physikalische Eigenschaften werden verborgen (Logische Blöcke) ▪Platten weisen riesige Caches auf ▪Solid State Disks enthalten keine Mechanik mehr → E/AScheduling verliert langsam an Bedeutung → Erfolg einer Strategie ist schwerer vorherzusagen MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 47,
      "chunk_id": "p47c1",
      "title": "Diskussion: E/AScheduling heute ▪Platten sind intelligente Geräte ▪Physikalische Eigenschaften werde",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: E/AScheduling heute ▪Trotzdem ist E/AScheduling noch immer sehr wichtig ▪CPUs werden immer schneller, Platten kaum ▪Linux implementiert zur Zeit zwei verschiedene Varianten der Fahrstuhlstrategie (+ FIFO für „Platten“ ohne Positionierungszeit): ▪DEADLINE: Bevorzugung von Leseanforderungen (kürzere Deadlines) ▪COMPLETE FAIR: Prozesse erhalten gleichen Anteil an E/ABandbreite MOBS: 09 –",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 48,
      "chunk_id": "p48c1",
      "title": "Diskussion: E/AScheduling heute ▪Trotzdem ist E/AScheduling noch immer sehr wichtig ▪CPUs werden imm",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "(kürzere Deadlines) ▪COMPLETE FAIR: Prozesse erhalten gleichen Anteil an E/ABandbreite MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 48,
      "chunk_id": "p48c2",
      "title": "Diskussion: E/AScheduling heute ▪Trotzdem ist E/AScheduling noch immer sehr wichtig ▪CPUs werden imm",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Zusammenfassung ▪E/AHardware ist sehr unterschiedlich ▪teilweise auch „hässlich“ zu programmieren ▪Die Kunst des Betriebssystembaus besteht darin, … ▪trotzdem einheitliche und einfache Schnittstellen zu definieren ▪effizient mit der Hardware umzugehen ▪CPU und E/AGeräteauslastung zu maximieren ▪Gerätetreibervielfalt ist für den Erfolg eines Betriebssystems extrem wichtig ▪Bei Systemen wie Linux",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 49,
      "chunk_id": "p49c1",
      "title": "Zusammenfassung ▪E/AHardware ist sehr unterschiedlich ▪teilweise auch „hässlich“ zu programmieren ▪D",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "ist für den Erfolg eines Betriebssystems extrem wichtig ▪Bei Systemen wie Linux und Windows sind die Gerätetreiber das weitaus größte Subsystem MOBS: 09 – Einund Ausgabe",
    "metadata": {
      "source": "MOBS_09_Ein_und_Ausgabe.pdf",
      "page": 49,
      "chunk_id": "p49c2",
      "title": "Zusammenfassung ▪E/AHardware ist sehr unterschiedlich ▪teilweise auch „hässlich“ zu programmieren ▪D",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – Dateisysteme mit Material von Olaf Spinczyk (Universität Osnabrück) und Horst Schirmeier (TU Dortmund)",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 1,
      "chunk_id": "p1c1",
      "title": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – Dateisysteme mit Material von Olaf Spinczyk (Univ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Dateien ▪Freispeicherverwaltung ▪Verzeichnisse ▪Dateisysteme ▪Virtuelle Dateisysteme MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 2,
      "chunk_id": "p2c1",
      "title": "Inhalt ▪Wiederholung ▪Dateien ▪Freispeicherverwaltung ▪Verzeichnisse ▪Dateisysteme ▪Virtuelle Dateis",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Dateien ▪Freispeicherverwaltung ▪Verzeichnisse ▪Dateisysteme ▪Virtuelle Dateisysteme MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 3,
      "chunk_id": "p3c1",
      "title": "Inhalt ▪Wiederholung ▪Dateien ▪Freispeicherverwaltung ▪Verzeichnisse ▪Dateisysteme ▪Virtuelle Dateis",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Wiederholung ▪In den bisherigen Vorlesungen ▪CPU ▪Hauptspeicher ▪In der letzten Vorlesung ▪E/AGeräte, insbesondere auch Zugriff auf blockorientierte Geräte ▪Heute: Dateisysteme MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 4,
      "chunk_id": "p4c1",
      "title": "Wiederholung ▪In den bisherigen Vorlesungen ▪CPU ▪Hauptspeicher ▪In der letzten Vorlesung ▪E/AGeräte",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Hintergrundspeicher MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 5,
      "chunk_id": "p5c1",
      "title": "Hintergrundspeicher MOBS: 10Dateisysteme",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Dateien ▪Freispeicherverwaltung ▪Verzeichnisse ▪Dateisysteme ▪Virtuelle Dateisysteme MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 6,
      "chunk_id": "p6c1",
      "title": "Inhalt ▪Wiederholung ▪Dateien ▪Freispeicherverwaltung ▪Verzeichnisse ▪Dateisysteme ▪Virtuelle Dateis",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Speicherung von Dateien ▪Dateien benötigen oft mehr als einen Block auf der Festplatte ▪Welche Blöcke werden für die Speicherung einer Datei verwendet? MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 7,
      "chunk_id": "p7c1",
      "title": "Speicherung von Dateien ▪Dateien benötigen oft mehr als einen Block auf der Festplatte ▪Welche Blöck",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Kontinuierliche Speicherung ▪Datei wird in Blöcken mit aufsteigenden Blocknummern gespeichert ▪Nummer des ersten Blocks und Anzahl der Folgeblöcke muss gespeichert werden, z.B. Start: Block 4; Länge: 3 ▪Vorteile ▪Zugriff auf alle Blöcke mit minimaler Positionierzeit des Schwenkarms ▪Schneller direkter Zugriff auf bestimmte Dateiposition ▪Einsatz z.B",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 8,
      "chunk_id": "p8c1",
      "title": "Kontinuierliche Speicherung ▪Datei wird in Blöcken mit aufsteigenden Blocknummern gespeichert ▪Numme",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". bei nicht modifizierbaren Dateisystemen wie auf CDs/DVDs MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 8,
      "chunk_id": "p8c2",
      "title": "Kontinuierliche Speicherung ▪Datei wird in Blöcken mit aufsteigenden Blocknummern gespeichert ▪Numme",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Kontinuierliche Speicherung: Probleme ▪Finden des freien Platzes auf der Festplatte ▪(Menge aufeinanderfolgender und freier Plattenblöcke) ▪Fragmentierungsproblem ▪(Verschnitt: nicht nutzbare Plattenblöcke; siehe auch Speicherverwaltung) ▪Größe bei neuen Dateien oft nicht im Voraus bekannt ▪Erweitern ist problematisch ▪Umkopieren, falls kein freier angrenzender Block mehr verfügbar MOBS:",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 9,
      "chunk_id": "p9c1",
      "title": "Kontinuierliche Speicherung: Probleme ▪Finden des freien Platzes auf der Festplatte ▪(Menge aufeinan",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "▪Erweitern ist problematisch ▪Umkopieren, falls kein freier angrenzender Block mehr verfügbar MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 9,
      "chunk_id": "p9c2",
      "title": "Kontinuierliche Speicherung: Probleme ▪Finden des freien Platzes auf der Festplatte ▪(Menge aufeinan",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verkettete Speicherung ▪Blöcke einer Datei sind verkettet ▪z.B. Commodore Systeme (CBM 64 etc.) ▪Blockgröße 256 Bytes ▪die ersten zwei Bytes bezeichnen Spur/Sektor des nächsten Blocks ▪wenn Spurnummer gleich Null: letzter Block ▪254 Bytes Nutzdaten ▪Datei kann vergrößert und verkleinert werden MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 10,
      "chunk_id": "p10c1",
      "title": "Verkettete Speicherung ▪Blöcke einer Datei sind verkettet ▪z.B. Commodore Systeme (CBM 64 etc.) ▪Blo",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verkettete Speicherung: Probleme ▪Speicher für Verzeigerung geht von Nutzdaten im Block ab ▪Ungünstig im Zusammenhang mit Paging: Seite würde immer aus Teilen von zwei Plattenblöcken bestehen ▪Fehleranfälligkeit: Datei ist nicht restaurierbar, falls einmal Verzeigerung fehlerhaft ▪Schlechter direkter Zugriff auf bestimmte Dateiposition ▪Häufiges Positionieren des Schreib, Lesekopfs bei verstreuten",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 11,
      "chunk_id": "p11c1",
      "title": "Verkettete Speicherung: Probleme ▪Speicher für Verzeigerung geht von Nutzdaten im Block ab ▪Ungünsti",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Zugriff auf bestimmte Dateiposition ▪Häufiges Positionieren des Schreib, Lesekopfs bei verstreuten Datenblöcken MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 11,
      "chunk_id": "p11c2",
      "title": "Verkettete Speicherung: Probleme ▪Speicher für Verzeigerung geht von Nutzdaten im Block ab ▪Ungünsti",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verkettete Speicherung: FAT ▪Verkettung wird in separaten Plattenblöcken gespeichert ▪FATAnsatz (FAT: File Allocation Table), z.B. MSDOS, Windows 95 ▪Vorteile ▪kompletter Inhalt des Datenblocks ist nutzbar ▪mehrfache Speicherung der FAT möglich: Einschränkung der Fehleranfälligkeit MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 12,
      "chunk_id": "p12c1",
      "title": "Verkettete Speicherung: FAT ▪Verkettung wird in separaten Plattenblöcken gespeichert ▪FATAnsatz (FAT",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verkettete Speicherung: Probleme (2) ▪Zusätzliches Laden mindestens eines Blocks (Caching der FAT zur Effizienzsteigerung nötig) ▪Laden unbenötigter Informationen: FAT enthält Verkettungen für alle Dateien ▪Aufwändige Suche nach dem zugehörigen Datenblock bei bekannter Position in der Datei ▪Häufiges Positionieren des Schreib, Lesekopfs bei verstreuten Datenblöcken MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 13,
      "chunk_id": "p13c1",
      "title": "Verkettete Speicherung: Probleme (2) ▪Zusätzliches Laden mindestens eines Blocks (Caching der FAT zu",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: Chunks/Extents/Clusters ▪Variation ▪Unterteilen einer Datei in kontinuierlich gespeicherte Folgen von Blöcken (Chunk, Extent oder Cluster genannt) ▪Reduziert die Zahl der Positionierungsvorgänge ▪Blocksuche wird linear in Abhängigkeit von der ChunkGröße beschleunigt MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 14,
      "chunk_id": "p14c1",
      "title": "Diskussion: Chunks/Extents/Clusters ▪Variation ▪Unterteilen einer Datei in kontinuierlich gespeicher",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: Chunks/Extents/Clusters ▪Probleme ▪Zusätzliche Verwaltungsinformationen ▪Verschnitt ▪Feste Größe: innerhalb einer Folge (interner Verschnitt) ▪Variable Größe: außerhalb der Folgen (externer Verschnitt) → Wird eingesetzt, bringt aber keinen fundamentalen Fortschritt MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 15,
      "chunk_id": "p15c1",
      "title": "Diskussion: Chunks/Extents/Clusters ▪Probleme ▪Zusätzliche Verwaltungsinformationen ▪Verschnitt ▪Fes",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Indiziertes Speichern ▪Spezieller Plattenblock enthält Blocknummern der Datenblocks einer Datei ▪Problem ▪Feste Anzahl von Blöcken im Indexblock ▪Verschnitt bei kleinen Dateien ▪Erweiterung nötig für große Dateien MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 16,
      "chunk_id": "p16c1",
      "title": "Indiziertes Speichern ▪Spezieller Plattenblock enthält Blocknummern der Datenblocks einer Datei ▪Pro",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Indiziertes Speichern: UNIXInode MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 17,
      "chunk_id": "p17c1",
      "title": "Indiziertes Speichern: UNIXInode MOBS: 10Dateisysteme",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Indiziertes Speichern: Diskussion ▪Einsatz von mehreren Stufen der Indizierung ▪Inode benötigt sowieso einen Block auf der Platte (Verschnitt unproblematisch bei kleinen Dateien) ▪durch mehrere Stufen der Indizierung auch große Dateien adressierbar ▪Nachteil ▪mehrere Blöcke müssen geladen werden (nur bei langen Dateien) MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 18,
      "chunk_id": "p18c1",
      "title": "Indiziertes Speichern: Diskussion ▪Einsatz von mehreren Stufen der Indizierung ▪Inode benötigt sowie",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Baumsequentielle Speicherung ▪Wird bei Datenbanken zum effizienten Auffinden eines Datensatzes mit Hilfe eines Schlüssels eingesetzt ▪Schlüsselraum darf spärlich besetzt sein ▪Kann auch verwendet werden, um DateiChunks mit bestimmtem DateiOffset aufzufinden ▪z.B. NTFS, Reiser FS, Btrfs, IBM JFS2 Dateisystem (B+Baum) MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 19,
      "chunk_id": "p19c1",
      "title": "Baumsequentielle Speicherung ▪Wird bei Datenbanken zum effizienten Auffinden eines Datensatzes mit H",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Baumsequentielle Speicherung MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 20,
      "chunk_id": "p20c1",
      "title": "Baumsequentielle Speicherung MOBS: 10Dateisysteme",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Dateien ▪Freispeicherverwaltung ▪Verzeichnisse ▪Dateisysteme ▪Virtuelle Dateisysteme MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 21,
      "chunk_id": "p21c1",
      "title": "Inhalt ▪Wiederholung ▪Dateien ▪Freispeicherverwaltung ▪Verzeichnisse ▪Dateisysteme ▪Virtuelle Dateis",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Freispeicherverwaltung Ähnlich wie Verwaltung von freiem Hauptspeicher ▪Bitvektoren zeigen für jeden Block Belegung an ▪Verkettete Listen repräsentieren freie Blöcke ▪Verkettung kann in den freien Blöcken vorgenommen werden ▪Optimierung: aufeinanderfolgende Blöcke werden nicht einzeln aufgenommen, sondern als Stück verwaltet ▪Optimierung: ein freier Block enthält viele Blocknummern weiterer freier",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 22,
      "chunk_id": "p22c1",
      "title": "Freispeicherverwaltung Ähnlich wie Verwaltung von freiem Hauptspeicher ▪Bitvektoren zeigen für jeden",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "als Stück verwaltet ▪Optimierung: ein freier Block enthält viele Blocknummern weiterer freier Blöcke und evtl",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 22,
      "chunk_id": "p22c2",
      "title": "Freispeicherverwaltung Ähnlich wie Verwaltung von freiem Hauptspeicher ▪Bitvektoren zeigen für jeden",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". die Blocknummer eines weiteren Blocks mit den Nummern freier Blöcke MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 22,
      "chunk_id": "p22c3",
      "title": "Freispeicherverwaltung Ähnlich wie Verwaltung von freiem Hauptspeicher ▪Bitvektoren zeigen für jeden",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Freispeicherverwaltung ▪Baumsequentielle Speicherung freier Blockfolgen ▪Erlaubt schnelle Suche nach freier Blockfolge bestimmter Größe ▪Anwendung z.B. im SGI XFS MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 23,
      "chunk_id": "p23c1",
      "title": "Freispeicherverwaltung ▪Baumsequentielle Speicherung freier Blockfolgen ▪Erlaubt schnelle Suche nach",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Dateien ▪Freispeicherverwaltung ▪Verzeichnisse ▪Dateisysteme ▪Virtuelle Dateisysteme MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 24,
      "chunk_id": "p24c1",
      "title": "Inhalt ▪Wiederholung ▪Dateien ▪Freispeicherverwaltung ▪Verzeichnisse ▪Dateisysteme ▪Virtuelle Dateis",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verzeichnis als Liste ▪Einträge gleicher Länge hintereinander in einer Liste, z.B. ▪FAT File systems ▪für VFAT werden mehrere Einträge zusammen verwendet, um den langen Namen aufzunehmen ▪UNIX System V.3 MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 25,
      "chunk_id": "p25c1",
      "title": "Verzeichnis als Liste ▪Einträge gleicher Länge hintereinander in einer Liste, z.B. ▪FAT File systems",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verzeichnis als Liste ▪Problem ▪Suche nach bestimmtem Eintrag muss linear erfolgen ▪Bei Sortierung der Liste: Schnelles Suchen, Aufwand beim Einfügen MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 26,
      "chunk_id": "p26c1",
      "title": "Verzeichnis als Liste ▪Problem ▪Suche nach bestimmtem Eintrag muss linear erfolgen ▪Bei Sortierung d",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Einsatz von HashFunktionen ▪Einfaches (aber schlechtes) Beispiel: (∑ Zeichen) mod N ▪Probleme ▪Kollisionen (mehrere Dateinamen werden auf gleichen Eintrag abgebildet) ▪Anpassung der Listengröße, wenn Liste voll MOBS: 10Dateisysteme ▪Funktion bildet Dateinamen auf einen Index in die Katalogliste ab. → Schnellerer Zugriff auf den Eintrag möglich (kein lineares Suchen)",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 27,
      "chunk_id": "p27c1",
      "title": "Einsatz von HashFunktionen ▪Einfaches (aber schlechtes) Beispiel: (∑ Zeichen) mod N ▪Probleme ▪Kolli",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Variabel lange Listenelemente ▪Beispiel 4.2 BSD, System V Rel. 4, u.a. ▪Probleme ▪Verwaltung von freien Einträgen in der Liste ▪Speicherverschnitt (Kompaktifizieren, etc.) MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 28,
      "chunk_id": "p28c1",
      "title": "Variabel lange Listenelemente ▪Beispiel 4.2 BSD, System V Rel. 4, u.a. ▪Probleme ▪Verwaltung von fre",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Dateien ▪Freispeicherverwaltung ▪Verzeichnisse ▪Dateisysteme ▪Virtuelle Dateisysteme MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 29,
      "chunk_id": "p29c1",
      "title": "Inhalt ▪Wiederholung ▪Dateien ▪Freispeicherverwaltung ▪Verzeichnisse ▪Dateisysteme ▪Virtuelle Dateis",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "UNIX System V File System ▪Blockorganisation ▪Boot Block enthält Informationen zum Laden des Betriebssystems ▪Super Block enthält Verwaltungsinformation für ein Dateisystem ▪Anzahl der Blöcke, Anzahl der Inodes ▪Anzahl und Liste freier Blöcke und freier Inodes ▪Attribute (z.B. Modified flag) MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 30,
      "chunk_id": "p30c1",
      "title": "UNIX System V File System ▪Blockorganisation ▪Boot Block enthält Informationen zum Laden des Betrieb",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "BSD 4.2 (Berkeley Fast File System) ▪Blockorganisation ▪Kopie des Super Blocks in jeder Zylindergruppe ▪Eine Datei wird möglichst innerhalb einer Zylindergruppe gespeichert ▪Verzeichnisse werden verteilt, Dateien eines V. bleiben zusammen ▪Vorteil: kürzere Positionierungszeiten MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 31,
      "chunk_id": "p31c1",
      "title": "BSD 4.2 (Berkeley Fast File System) ▪Blockorganisation ▪Kopie des Super Blocks in jeder Zylindergrup",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Linux Ext2/3/4 File System ▪Blockorganisation ▪Ähnliches Layout wie BSD FFS ▪Blockgruppen unabhängig von Zylindern MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 32,
      "chunk_id": "p32c1",
      "title": "Linux Ext2/3/4 File System ▪Blockorganisation ▪Ähnliches Layout wie BSD FFS ▪Blockgruppen unabhängig",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Dateien ▪Freispeicherverwaltung ▪Verzeichnisse ▪Dateisysteme ▪Virtuelle Dateisysteme MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 33,
      "chunk_id": "p33c1",
      "title": "Inhalt ▪Wiederholung ▪Dateien ▪Freispeicherverwaltung ▪Verzeichnisse ▪Dateisysteme ▪Virtuelle Dateis",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Virtuelle Dateisysteme: Beispiel UNIX ▪Systemübergreifender Namensraum für Dateien MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 34,
      "chunk_id": "p34c1",
      "title": "Virtuelle Dateisysteme: Beispiel UNIX ▪Systemübergreifender Namensraum für Dateien MOBS: 10Dateisyst",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Virtuelle Dateisysteme: (De)Montieren MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 35,
      "chunk_id": "p35c1",
      "title": "Virtuelle Dateisysteme: (De)Montieren MOBS: 10Dateisysteme",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Fazit: Dateisysteme ▪... sind eine Betriebssystemabstraktion ▪Speicherung logisch zusammenhängender Informationen als Datei ▪Meist hierarchische Verzeichnisstruktur, um Dateien zu ordnen ▪... werden durch die Hardware beeinflusst ▪Minimierung der Positionierungszeiten bei Platten ▪Gleichmäßige „Abnutzung“ bei FLASHSpeicher MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 36,
      "chunk_id": "p36c1",
      "title": "Fazit: Dateisysteme ▪... sind eine Betriebssystemabstraktion ▪Speicherung logisch zusammenhängender ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Fazit: Dateisysteme ▪… werden durch das Anwendungsprofil beeinflusst ▪Blockgröße ▪zu klein → Verwaltungsstrukturen können zu PerformanceVerlust führen ▪zu groß → Verschnitt führt zu Plattenplatzverschwendung ▪Aufbau von Verzeichnissen ▪keine HashFunktion → langwierige Suche ▪mit HashFunktion → mehr Aufwand bei der Verwaltung MOBS: 10Dateisysteme",
    "metadata": {
      "source": "MOBS_10_Dateisysteme.pdf",
      "page": 37,
      "chunk_id": "p37c1",
      "title": "Fazit: Dateisysteme ▪… werden durch das Anwendungsprofil beeinflusst ▪Blockgröße ▪zu klein → Verwalt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – Virtueller Speicher mit Material von Olaf Spinczyk (Universität Osnabrück) und Horst Schirmeier (TU Dortmund)",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 1,
      "chunk_id": "p1c1",
      "title": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – Virtueller Speicher mit Material von Olaf Spinczy",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Motivation ▪Demand Paging ▪Seitenersetzung ▪Kachelzuordnung ▪Ladestrategie MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 2,
      "chunk_id": "p2c1",
      "title": "Inhalt ▪Wiederholung ▪Motivation ▪Demand Paging ▪Seitenersetzung ▪Kachelzuordnung ▪Ladestrategie MOB",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Motivation ▪Demand Paging ▪Seitenersetzung ▪Kachelzuordnung ▪Ladestrategie MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 3,
      "chunk_id": "p3c1",
      "title": "Inhalt ▪Wiederholung ▪Motivation ▪Demand Paging ▪Seitenersetzung ▪Kachelzuordnung ▪Ladestrategie MOB",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Wiederholung ▪Bei der Speicherverwaltung arbeitet das Betriebssystem sehr eng mit der Hardware zusammen ▪Segmentierung und/oder Seitenadressierung ▪Durch die implizite Indirektion beim Speicherzugriff können Programme und Daten unter der Kontrolle des Betriebssystems im laufenden Betrieb beliebig verschoben werden ▪Zusätzlich sind diverse strategische Entscheidungen zu treffen",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 4,
      "chunk_id": "p4c1",
      "title": "Wiederholung ▪Bei der Speicherverwaltung arbeitet das Betriebssystem sehr eng mit der Hardware zusam",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Betrieb beliebig verschoben werden ▪Zusätzlich sind diverse strategische Entscheidungen zu treffen ▪Platzierungsstrategie (First Fit, Best Fit, Buddy, …) ▪Unterscheiden sich bzgl",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 4,
      "chunk_id": "p4c2",
      "title": "Wiederholung ▪Bei der Speicherverwaltung arbeitet das Betriebssystem sehr eng mit der Hardware zusam",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Verschnitt sowie Belegungsund Freigabeaufwand ▪Strategieauswahl hängt vom erwarteten Anwendungsprofil ab ▪Bei Ein/Auslagerung von Segmenten oder Seiten: ▪Ladestrategie ▪Ersetzungsstrategie MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 4,
      "chunk_id": "p4c3",
      "title": "Wiederholung ▪Bei der Speicherverwaltung arbeitet das Betriebssystem sehr eng mit der Hardware zusam",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Motivation ▪Demand Paging ▪Seitenersetzung ▪Kachelzuordnung ▪Ladestrategie MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 5,
      "chunk_id": "p5c1",
      "title": "Inhalt ▪Wiederholung ▪Motivation ▪Demand Paging ▪Seitenersetzung ▪Kachelzuordnung ▪Ladestrategie MOB",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Lokalität der Speicherzugriffe ▪Einzelne Instruktionen benötigen nur wenige Speicherseiten ▪Auch über längere Zeiträume zeigt sich starke Lokalität ▪Instruktionen werden z.B. eine nach der anderen ausgeführt → Die Lokalität kann ausgenutzt werden, wenn der Speicher nicht reicht ▪z.B. „OverlayTechnik“ MOBS: 08Virtueller Speicher Quelle: Silberschatz, „Operating System Concepts“",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 6,
      "chunk_id": "p6c1",
      "title": "Lokalität der Speicherzugriffe ▪Einzelne Instruktionen benötigen nur wenige Speicherseiten ▪Auch übe",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Die Idee des „Virtuellen Speichers“ ▪Entkopplung des Speicherbedarfs vom verfügbaren Hauptspeicher ▪Prozesse benötigen nicht alle Speicherstellen gleich häufig: ▪bestimmte Befehle werden selten oder gar nicht benutzt (z.B. Fehlerbehandlungen) ▪bestimmte Datenstrukturen werden nicht voll belegt ▪Prozesse benötigen evtl. mehr Speicher als Hauptspeicher vorhanden MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 7,
      "chunk_id": "p7c1",
      "title": "Die Idee des „Virtuellen Speichers“ ▪Entkopplung des Speicherbedarfs vom verfügbaren Hauptspeicher ▪",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Die Idee des „Virtuellen Speichers“ ▪Idee ▪Vortäuschen eines großen Hauptspeichers ▪Einblenden aktuell benötigter Speicherbereiche ▪Abfangen von Zugriffen auf nicht eingeblendete Bereiche ▪Bereitstellen der benötigen Bereiche auf Anforderung ▪Auslagern nicht benötigter Bereiche MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 8,
      "chunk_id": "p8c1",
      "title": "Die Idee des „Virtuellen Speichers“ ▪Idee ▪Vortäuschen eines großen Hauptspeichers ▪Einblenden aktue",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Motivation ▪Demand Paging ▪Seitenersetzung ▪Kachelzuordnung ▪Ladestrategie MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 9,
      "chunk_id": "p9c1",
      "title": "Inhalt ▪Wiederholung ▪Motivation ▪Demand Paging ▪Seitenersetzung ▪Kachelzuordnung ▪Ladestrategie MOB",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Demand Paging ▪Bereitstellung von Seiten auf Anforderung MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 10,
      "chunk_id": "p10c1",
      "title": "Demand Paging ▪Bereitstellung von Seiten auf Anforderung MOBS: 08Virtueller Speicher",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Demand Paging ▪Reaktion auf Seitenfehler (page fault) MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 11,
      "chunk_id": "p11c1",
      "title": "Demand Paging ▪Reaktion auf Seitenfehler (page fault) MOBS: 08Virtueller Speicher",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Demand Paging ▪Reaktion auf Seitenfehler (page fault) MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 12,
      "chunk_id": "p12c1",
      "title": "Demand Paging ▪Reaktion auf Seitenfehler (page fault) MOBS: 08Virtueller Speicher",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Demand Paging ▪Reaktion auf Seitenfehler (page fault) MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 13,
      "chunk_id": "p13c1",
      "title": "Demand Paging ▪Reaktion auf Seitenfehler (page fault) MOBS: 08Virtueller Speicher",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Demand Paging ▪Reaktion auf Seitenfehler (page fault) MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 14,
      "chunk_id": "p14c1",
      "title": "Demand Paging ▪Reaktion auf Seitenfehler (page fault) MOBS: 08Virtueller Speicher",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: PagingZeitverhalten ▪Performanz von Demand Paging ▪Ohne Seitenfehler ▪Effektive Zugriffszeit zwischen 10 und 200 Nanosekunden ▪Mit Seitenfehler ▪p sei Wahrscheinlichkeit für Seitenfehler ▪Annahme: Zeit zum Einlagern einer Seite vom Hintergrundspeicher gleich 25 Millisekunden (8 ms Latenz, 15 ms Positionierzeit, 1 ms Übertragungszeit) ▪Annahme: normale Zugriffszeit 100 ns ▪Effektive",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 15,
      "chunk_id": "p15c1",
      "title": "Diskussion: PagingZeitverhalten ▪Performanz von Demand Paging ▪Ohne Seitenfehler ▪Effektive Zugriffs",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "15 ms Positionierzeit, 1 ms Übertragungszeit) ▪Annahme: normale Zugriffszeit 100 ns ▪Effektive Zugriffszeit: ( 1 – p ) · 100 + p · 25000000 = 100 + 24999900 · p → Seitenfehlerrate muss extrem niedrig sein ▪p nahe Null MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 15,
      "chunk_id": "p15c2",
      "title": "Diskussion: PagingZeitverhalten ▪Performanz von Demand Paging ▪Ohne Seitenfehler ▪Effektive Zugriffs",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: Weitere Eigenschaften ▪Prozesserzeugung ▪CopyonWrite ▪Auch bei Paging MMU leicht zu realisieren ▪Feinere Granularität als bei Segmentierung ▪Programmausführung und Laden erfolgen verschränkt: ▪Benötigte Seiten werden erst nach und nach geladen ▪Sperren von Seiten ▪Notwendig bei Ein/Ausgabeoperationen MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 16,
      "chunk_id": "p16c1",
      "title": "Diskussion: Weitere Eigenschaften ▪Prozesserzeugung ▪CopyonWrite ▪Auch bei Paging MMU leicht zu real",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: Demand Segmentation Prinzipiell möglich, hat aber Nachteile… ▪Grobe Granularität ▪z.B. Code, Daten, StackSegment ▪Schwierigere Hauptspeicherverwaltung ▪Alle freien Kacheln sind gleich gut für ausgelagerte Seiten",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 17,
      "chunk_id": "p17c1",
      "title": "Diskussion: Demand Segmentation Prinzipiell möglich, hat aber Nachteile… ▪Grobe Granularität ▪z.B. C",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Bei der Einlagerung von Segmenten ist die Speichersuche schwieriger ▪Schwierigere Hintergrundspeicherverwaltung ▪Hintergrundspeicher wie Kacheln in Blöcke strukturiert (2er Potenzen) ▪In der Praxis hat sich Demand Paging durchgesetzt MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 17,
      "chunk_id": "p17c2",
      "title": "Diskussion: Demand Segmentation Prinzipiell möglich, hat aber Nachteile… ▪Grobe Granularität ▪z.B. C",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Motivation ▪Demand Paging ▪Seitenersetzung ▪Kachelzuordnung ▪Ladestrategie MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 18,
      "chunk_id": "p18c1",
      "title": "Inhalt ▪Wiederholung ▪Motivation ▪Demand Paging ▪Seitenersetzung ▪Kachelzuordnung ▪Ladestrategie MOB",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Seitenersetzung ▪Was tun, wenn keine freie Kachel vorhanden? ▪Eine Seite muss verdrängt werden, um Platz für neue Seite zu schaffen! ▪Auswahl von Seiten, die nicht geändert wurden (dirty bit in der SKT) ▪Verdrängung erfordert Auslagerung, falls Seite geändert wurde ▪Vorgang: ▪Seitenfehler (page fault): Trap in das Betriebssystem ▪Auslagern einer Seite, falls keine freie Kachel verfügbar ▪Einlagern",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 19,
      "chunk_id": "p19c1",
      "title": "Seitenersetzung ▪Was tun, wenn keine freie Kachel vorhanden? ▪Eine Seite muss verdrängt werden, um P",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Trap in das Betriebssystem ▪Auslagern einer Seite, falls keine freie Kachel verfügbar ▪Einlagern der benötigten Seite ▪Wiederholung des Zugriffs ▪Problem ▪Welche Seite soll ausgewählt werden (das „Opfer“)? MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 19,
      "chunk_id": "p19c2",
      "title": "Seitenersetzung ▪Was tun, wenn keine freie Kachel vorhanden? ▪Eine Seite muss verdrängt werden, um P",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Ersetzungsstrategien ▪Betrachtung von Ersetzungsstrategien und deren Wirkung auf Referenzfolgen ▪Referenzfolge ▪Folge von Seitennummern, die das Speicherzugriffsverhalten eines Prozesses abbildet ▪Ermittlung von Referenzfolgen z.B",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 20,
      "chunk_id": "p20c1",
      "title": "Ersetzungsstrategien ▪Betrachtung von Ersetzungsstrategien und deren Wirkung auf Referenzfolgen ▪Ref",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". durch Aufzeichnung der zugegriffenen Adressen ▪Reduktion der aufgezeichneten Sequenz auf Seitennummern ▪Zusammenfassung von unmittelbar hintereinanderstehenden Zugriffen auf die gleiche Seite ▪Beispiel für eine Referenzfolge: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5 MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 20,
      "chunk_id": "p20c2",
      "title": "Ersetzungsstrategien ▪Betrachtung von Ersetzungsstrategien und deren Wirkung auf Referenzfolgen ▪Ref",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "FirstIn, FirstOut ▪Älteste Seite wird ersetzt ▪Notwendige Zustände: ▪Alter bzw. Einlagerungszeitpunkt für jede Kachel ▪Ablauf der Ersetzungen (9 Einlagerungen) MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 21,
      "chunk_id": "p21c1",
      "title": "FirstIn, FirstOut ▪Älteste Seite wird ersetzt ▪Notwendige Zustände: ▪Alter bzw. Einlagerungszeitpunk",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "FirstIn, FirstOut ▪Größerer Hauptspeicher mit 4 Kacheln (10 Einlagerungen) ▪FIFOAnomalie (Bélády's Anomalie, 1969) MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 22,
      "chunk_id": "p22c1",
      "title": "FirstIn, FirstOut ▪Größerer Hauptspeicher mit 4 Kacheln (10 Einlagerungen) ▪FIFOAnomalie (Bélády's A",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Optimale Ersetzungsstrategie ▪Vorwärtsabstand ▪Zeitdauer bis zum nächsten Zugriff auf die entsprechende Seite ▪Strategie OPT (oder MIN) ist optimal (bei fester Kachelmenge): minimale MOBS: 08Virtueller Speicher Anzahl von Einlagerungen/Ersetzungen (hier 7) ▪„Ersetze immer die Seite mit dem größten Vorwärtsabstand!“",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 23,
      "chunk_id": "p23c1",
      "title": "Optimale Ersetzungsstrategie ▪Vorwärtsabstand ▪Zeitdauer bis zum nächsten Zugriff auf die entspreche",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Optimale Ersetzungsstrategie ▪Vergrößerung des Hauptspeichers (4 Kacheln): 6 Einlagerungen ▪keine Anomalie MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 24,
      "chunk_id": "p24c1",
      "title": "Optimale Ersetzungsstrategie ▪Vergrößerung des Hauptspeichers (4 Kacheln): 6 Einlagerungen ▪keine An",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Optimale Ersetzungsstrategie ▪Implementierung von OPT praktisch unmöglich ▪Referenzfolge müsste vorher bekannt sein ▪OPT ist nur zum Vergleich von Strategien brauchbar ▪Suche nach Strategien, die möglichst nahe an OPT kommen ▪z.B. Least Recently Used (LRU) MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 25,
      "chunk_id": "p25c1",
      "title": "Optimale Ersetzungsstrategie ▪Implementierung von OPT praktisch unmöglich ▪Referenzfolge müsste vorh",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Least Recently Used (LRU) ▪Rückwärtsabstand ▪Zeitdauer, seit dem letzten Zugriff auf die Seite ▪LRU Strategie (10 Einlagerungen) ▪„Ersetze die Seite mit dem größten Rückwärtsabstand!“ MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 26,
      "chunk_id": "p26c1",
      "title": "Least Recently Used (LRU) ▪Rückwärtsabstand ▪Zeitdauer, seit dem letzten Zugriff auf die Seite ▪LRU ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Least Recently Used (LRU) ▪Vergrößerung des Hauptspeichers (4 Kacheln): 8 Einlagerungen MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 27,
      "chunk_id": "p27c1",
      "title": "Least Recently Used (LRU) ▪Vergrößerung des Hauptspeichers (4 Kacheln): 8 Einlagerungen MOBS: 08Virt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Least Recently Used (LRU) ▪Keine Anomalie ▪Allgemein gilt: Es gibt eine Klasse von Algorithmen (StackAlgorithmen), bei denen keine Anomalie auftritt: ▪Bei StackAlgorithmen ist bei k Kacheln zu jedem Zeitpunkt eine Teilmenge der Seiten eingelagert, die bei k+1 Kacheln zum gleichen Zeitpunkt eingelagert wären! ▪LRU: Es sind immer die letzten k benutzten Seiten eingelagert ▪OPT: Es sind die k bereits",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 28,
      "chunk_id": "p28c1",
      "title": "Least Recently Used (LRU) ▪Keine Anomalie ▪Allgemein gilt: Es gibt eine Klasse von Algorithmen (Stac",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "wären! ▪LRU: Es sind immer die letzten k benutzten Seiten eingelagert ▪OPT: Es sind die k bereits benutzten Seiten eingelagert, die als nächstes zugegriffen werden ▪Problem ▪Implementierung von LRU nicht ohne Hardwareunterstützung möglich ▪Es muss jeder Speicherzugriff berücksichtigt werden MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 28,
      "chunk_id": "p28c2",
      "title": "Least Recently Used (LRU) ▪Keine Anomalie ▪Allgemein gilt: Es gibt eine Klasse von Algorithmen (Stac",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Least Recently Used (LRU) ▪Naive Idee: Hardwareunterstützung durch Zähler ▪CPU besitzt einen Zähler, der bei jedem Speicherzugriff erhöht wird (inkrementiert wird) ▪bei jedem Zugriff wird der aktuelle Zählerwert in den jeweiligen Seitendeskriptor geschrieben ▪Auswahl der Seite mit dem kleinsten Zählerstand (Suche!) ▪Aufwändige Implementierung ▪viele zusätzliche Speicherzugriffe ▪hoher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 29,
      "chunk_id": "p29c1",
      "title": "Least Recently Used (LRU) ▪Naive Idee: Hardwareunterstützung durch Zähler ▪CPU besitzt einen Zähler,",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Zählerstand (Suche!) ▪Aufwändige Implementierung ▪viele zusätzliche Speicherzugriffe ▪hoher Speicherplatzbedarf ▪MinimumSuche in der SeitenfehlerBehandlung MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 29,
      "chunk_id": "p29c2",
      "title": "Least Recently Used (LRU) ▪Naive Idee: Hardwareunterstützung durch Zähler ▪CPU besitzt einen Zähler,",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Second Chance (Clock) ▪So wird’s gemacht: Einsatz von Referenzbits ▪Referenzbit im Seitendeskriptor wird automatisch durch Hardware gesetzt, wenn die Seite zugegriffen wird ▪einfacher zu implementieren ▪weniger zusätzliche Speicherzugriffe ▪moderne Prozessoren bzw. MMUs unterstützen Referenzbits (z.B. x86: access bit) MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 30,
      "chunk_id": "p30c1",
      "title": "Second Chance (Clock) ▪So wird’s gemacht: Einsatz von Referenzbits ▪Referenzbit im Seitendeskriptor ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Second Chance (Clock) ▪Ziel: Annäherung von LRU ▪bei einer frisch eingelagerten Seite wird das Referenzbit zunächst auf 1 gesetzt ▪wird eine Opferseite gesucht, so werden die Bits reihum inspiziert ▪ist das Referenzbit 1, so wird es auf 0 gesetzt (zweite Chance) ▪ist das Referenzbit 0, so wird die Seite ersetzt MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 31,
      "chunk_id": "p31c1",
      "title": "Second Chance (Clock) ▪Ziel: Annäherung von LRU ▪bei einer frisch eingelagerten Seite wird das Refer",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Second Chance (Clock) ▪Implementierung mit umlaufendem Zeiger (Clock) ▪an der Zeigerposition wird Referenzbit getestet ▪falls Referenzbit 1, wird Bit gelöscht MOBS: 08Virtueller Speicher ▪falls Referenzbit gleich 0, wurde ersetzbare Seite gefunden ▪Zeiger wird weitergestellt; falls keine Seite gefunden: Wiederholung ▪falls alle Referenzbits auf 1 stehen, wird Second Chance zu FIFO",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 32,
      "chunk_id": "p32c1",
      "title": "Second Chance (Clock) ▪Implementierung mit umlaufendem Zeiger (Clock) ▪an der Zeigerposition wird Re",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Second Chance (Clock) ▪Ablauf bei drei Kacheln (9 Einlagerungen) MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 33,
      "chunk_id": "p33c1",
      "title": "Second Chance (Clock) ▪Ablauf bei drei Kacheln (9 Einlagerungen) MOBS: 08Virtueller Speicher",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Second Chance (Clock) ▪Vergrößerung des Hauptspeichers (4 Kacheln): 10 Einlagerungen MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 34,
      "chunk_id": "p34c1",
      "title": "Second Chance (Clock) ▪Vergrößerung des Hauptspeichers (4 Kacheln): 10 Einlagerungen MOBS: 08Virtuel",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Second Chance (Clock) ▪Bei Second Chance kann es auch zur FIFOAnomalie kommen ▪Wenn alle Referenzbits gleich 1, wird nach FIFO entschieden ▪Im Normalfall kommt man aber LRU nahe ▪Erweiterung ▪Modifikationsbit kann zusätzlich berücksichtigt werden (Dirty Bit) ▪Drei Klassen: (0,0), (1,0) und (1,1) mit (Referenzbit, Modifikationsbit) ▪Suche nach der niedrigsten Klasse (Einsatz im MacOS) MOBS:",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 35,
      "chunk_id": "p35c1",
      "title": "Second Chance (Clock) ▪Bei Second Chance kann es auch zur FIFOAnomalie kommen ▪Wenn alle Referenzbit",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "mit (Referenzbit, Modifikationsbit) ▪Suche nach der niedrigsten Klasse (Einsatz im MacOS) MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 35,
      "chunk_id": "p35c2",
      "title": "Second Chance (Clock) ▪Bei Second Chance kann es auch zur FIFOAnomalie kommen ▪Wenn alle Referenzbit",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: Freiseitenpuffer … beschleunigt die Seitenfehlerbehandlung ▪Statt eine Seite zu ersetzen, wird permanent eine Menge freier Seiten gehalten ▪Auslagerung geschieht im „Voraus“ ▪Effizienter: Ersetzungszeit besteht im Wesentlichen nur aus Einlagerungszeit ▪Behalten der Seitenzuordnung auch nach der Auslagerung ▪Wird die Seite doch noch benutzt bevor sie durch eine andere ersetzt wird, kann",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 36,
      "chunk_id": "p36c1",
      "title": "Diskussion: Freiseitenpuffer … beschleunigt die Seitenfehlerbehandlung ▪Statt eine Seite zu ersetzen",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "der Auslagerung ▪Wird die Seite doch noch benutzt bevor sie durch eine andere ersetzt wird, kann sie mit hoher Effizienz wiederverwendet werden ▪Seite wird aus Freiseitenpuffer ausgetragen und wieder dem entsprechenden Prozess zugeordnet MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 36,
      "chunk_id": "p36c2",
      "title": "Diskussion: Freiseitenpuffer … beschleunigt die Seitenfehlerbehandlung ▪Statt eine Seite zu ersetzen",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Motivation ▪Demand Paging ▪Seitenersetzung ▪Kachelzuordnung ▪Ladestrategie MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 37,
      "chunk_id": "p37c1",
      "title": "Inhalt ▪Wiederholung ▪Motivation ▪Demand Paging ▪Seitenersetzung ▪Kachelzuordnung ▪Ladestrategie MOB",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Kachelzuordnung ▪Problem: Aufteilung der Kacheln auf die Prozesse ▪Wie viele eingelagerte Seiten soll man einem Prozess zugestehen? ▪Maximum: begrenzt durch Anzahl der Kacheln ▪Minimum: abhängig von der Prozessorarchitektur ▪Mindestens die Anzahl von Seiten nötig, die theoretisch bei einem Maschinenbefehl benötigt werden (z.B",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 38,
      "chunk_id": "p38c1",
      "title": "Kachelzuordnung ▪Problem: Aufteilung der Kacheln auf die Prozesse ▪Wie viele eingelagerte Seiten sol",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". zwei Seiten für den Befehl, vier Seiten für die adressierten Daten) ▪Gleiche Zuordnung ▪Anzahl der Prozesse bestimmt die Kachelmenge, die ein Prozess bekommt ▪Größenabhängige Zuordnung ▪Größe des Programms fließt in die zugeteilte Kachelmenge ein MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 38,
      "chunk_id": "p38c2",
      "title": "Kachelzuordnung ▪Problem: Aufteilung der Kacheln auf die Prozesse ▪Wie viele eingelagerte Seiten sol",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Kachelzuordnung ▪Globale und lokale Anforderung von Seiten ▪lokal: Prozess ersetzt nur immer seine eigenen Seiten ▪SeitenfehlerVerhalten liegt nur in der Verantwortung des Prozesses ▪global: Prozess ersetzt auch Seiten anderer Prozesse ▪bessere Effizienz, da ungenutzte Seiten von anderen Prozessen verwendet werden können MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 39,
      "chunk_id": "p39c1",
      "title": "Kachelzuordnung ▪Globale und lokale Anforderung von Seiten ▪lokal: Prozess ersetzt nur immer seine e",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Seitenflattern (Thrashing) ▪Ausgelagerte Seite wird gleich wieder angesprochen ▪Prozess verbringt mehr Zeit mit dem Warten auf das Beheben von Seitenfehlern als mit der eigentlichen Ausführung MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 40,
      "chunk_id": "p40c1",
      "title": "Seitenflattern (Thrashing) ▪Ausgelagerte Seite wird gleich wieder angesprochen ▪Prozess verbringt me",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Seitenflattern (Thrashing) ▪Ursachen ▪Prozess ist nahe am Seitenminimum ▪Zu viele Prozesse gleichzeitig im System ▪Schlechte Ersetzungsstrategie → Lokale Seitenanforderung behebt Thrashing zwischen Prozessen → Zuteilung einer genügend großen Zahl von Kacheln behebt Thrashing innerhalb der Prozessseiten ▪Begrenzung der Prozessanzahl MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 41,
      "chunk_id": "p41c1",
      "title": "Seitenflattern (Thrashing) ▪Ursachen ▪Prozess ist nahe am Seitenminimum ▪Zu viele Prozesse gleichzei",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Lösung 1: Auslagerung von Prozessen ▪inaktiver Prozess benötigt keine Kacheln ▪Kacheln teilen sich auf weniger Prozesse auf ▪Verbindung mit dem Scheduling nötig ▪Verhindern von Aushungerung ▪Erzielen kurzer Reaktionszeiten MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 42,
      "chunk_id": "p42c1",
      "title": "Lösung 1: Auslagerung von Prozessen ▪inaktiver Prozess benötigt keine Kacheln ▪Kacheln teilen sich a",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Lösung 2: Arbeitsmengenmodell ▪Seitenmenge, die ein Prozess wirklich braucht (Working Set) ▪Kann nur angenähert werden, da üblicherweise nicht vorhersehbar ▪Annäherung durch Betrachten der letzten ∆ Seiten, die angesprochen wurden ▪geeignete Wahl von ∆ ▪zu groß: Überlappung von lokalen Zugriffsmustern ▪zu klein: Arbeitsmenge enthält nicht alle nötigen Seiten ▪Hinweis: ∆ > Arbeitsmenge, da Seiten",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 43,
      "chunk_id": "p43c1",
      "title": "Lösung 2: Arbeitsmengenmodell ▪Seitenmenge, die ein Prozess wirklich braucht (Working Set) ▪Kann nur",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "▪zu klein: Arbeitsmenge enthält nicht alle nötigen Seiten ▪Hinweis: ∆ > Arbeitsmenge, da Seiten in der Regel mehrfach hintereinander angesprochen werden MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 43,
      "chunk_id": "p43c2",
      "title": "Lösung 2: Arbeitsmengenmodell ▪Seitenmenge, die ein Prozess wirklich braucht (Working Set) ▪Kann nur",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Arbeitsmengenmodell ▪Beispiel: Arbeitsmengen bei verschiedenen ∆ MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 44,
      "chunk_id": "p44c1",
      "title": "Arbeitsmengenmodell ▪Beispiel: Arbeitsmengen bei verschiedenen ∆ MOBS: 08Virtueller Speicher",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Arbeitsmengenmodell ▪Annäherung der Zugriffe durch die Zeit ▪Bestimmtes Zeitintervall ist ungefähr proportional zu Anzahl von Speicherzugriffen ▪Virtuelle Zeit des Prozesses muss gemessen werden ▪Nur die Zeit relevant, in der der Prozess im Zustand RUNNING ist ▪Verwalten virtueller Uhren pro Prozess MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 45,
      "chunk_id": "p45c1",
      "title": "Arbeitsmengenmodell ▪Annäherung der Zugriffe durch die Zeit ▪Bestimmtes Zeitintervall ist ungefähr p",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Arbeitsmengenbestimmung mit Zeitgeber ▪Naive Idee: Annäherung der Arbeitsmenge mit ▪Referenzbit ▪Altersangabe pro Seite (Zeitintervall ohne Benutzung) ▪TimerInterrupt (durch Zeitgeber) ▪Algorithmus ▪durch regelmäßigen Interrupt wird mittels Referenzbit die Altersangabe fortgeschrieben: ▪ist Referenzbit gesetzt (Seite wurde benutzt), wird das Alter auf Null gesetzt; ▪ansonsten wird Altersangabe",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 46,
      "chunk_id": "p46c1",
      "title": "Arbeitsmengenbestimmung mit Zeitgeber ▪Naive Idee: Annäherung der Arbeitsmenge mit ▪Referenzbit ▪Alt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "gesetzt (Seite wurde benutzt), wird das Alter auf Null gesetzt; ▪ansonsten wird Altersangabe erhöht ▪Es werden nur die Seiten des gerade laufenden Prozesses „gealtert“ ▪Seiten mit Alter > ∆ sind nicht mehr in der Arbeitsmenge des jeweiligen Prozesses MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 46,
      "chunk_id": "p46c2",
      "title": "Arbeitsmengenbestimmung mit Zeitgeber ▪Naive Idee: Annäherung der Arbeitsmenge mit ▪Referenzbit ▪Alt",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Arbeitsmengenbestimmung mit Zeitgeber ▪Ungenau ▪Verringerung der Zeitintervalle: höherer Aufwand, genauere Messung ▪System ist aber nicht empfindlich auf diese Ungenauigkeit ▪Ineffizient ▪große Menge von Seiten zu betrachten MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 47,
      "chunk_id": "p47c1",
      "title": "Arbeitsmengenbestimmung mit Zeitgeber ▪Ungenau ▪Verringerung der Zeitintervalle: höherer Aufwand, ge",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Arbeitsmengenbestimmung mit WSClock ▪So wird’s gemacht: Algorithmus WSClock (working set clock) ▪Arbeitet wie Clock ▪Seite wird nur dann ersetzt, wenn sie nicht zur Arbeitsmenge ihres Prozesses gehört oder der Prozess deaktiviert ist ▪Bei Zurücksetzen des Referenzbits wird die virtuelle Zeit des jeweiligen Prozesses eingetragen, die z.B",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 48,
      "chunk_id": "p48c1",
      "title": "Arbeitsmengenbestimmung mit WSClock ▪So wird’s gemacht: Algorithmus WSClock (working set clock) ▪Arb",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". im PCB gehalten und fortgeschrieben wird ▪Bestimmung der Arbeitsmenge erfolgt durch Differenzbildung von virtueller Zeit des Prozesses und Zeitstempel in der Kachel MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 48,
      "chunk_id": "p48c2",
      "title": "Arbeitsmengenbestimmung mit WSClock ▪So wird’s gemacht: Algorithmus WSClock (working set clock) ▪Arb",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Arbeitsmengenbestimmung mit WSClock ▪WSClock Algorithmus MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 49,
      "chunk_id": "p49c1",
      "title": "Arbeitsmengenbestimmung mit WSClock ▪WSClock Algorithmus MOBS: 08Virtueller Speicher",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: Arbeitsmengenprobleme ▪Speicherplatzbedarf für Zeitstempel ▪Zuordnung zu einem Prozess nicht immer möglich ▪gemeinsam genutzte Seiten in modernen Betriebssystemen eher die Regel als die Ausnahme ▪Shared Libraries ▪Gemeinsame Seiten im Datensegment (Shared Memory) → Lösung 3: Thrashing kann durch direkte Steuerung der Seitenfehlerrate leichter vermieden werden ▪Messung pro Prozess ▪Rate",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 50,
      "chunk_id": "p50c1",
      "title": "Diskussion: Arbeitsmengenprobleme ▪Speicherplatzbedarf für Zeitstempel ▪Zuordnung zu einem Prozess n",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "durch direkte Steuerung der Seitenfehlerrate leichter vermieden werden ▪Messung pro Prozess ▪Rate < Schwellwert: Kachelmenge verkleinern ▪Rate > Schwellwert: Kachelmenge vergrößern MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 50,
      "chunk_id": "p50c2",
      "title": "Diskussion: Arbeitsmengenprobleme ▪Speicherplatzbedarf für Zeitstempel ▪Zuordnung zu einem Prozess n",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt ▪Wiederholung ▪Motivation ▪Demand Paging ▪Seitenersetzung ▪Kachelzuordnung ▪Ladestrategie MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 51,
      "chunk_id": "p51c1",
      "title": "Inhalt ▪Wiederholung ▪Motivation ▪Demand Paging ▪Seitenersetzung ▪Kachelzuordnung ▪Ladestrategie MOB",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Ladestrategie ▪Auf Anforderung laden ▪Damit ist man auf der sicheren Seite ▪Im Voraus laden ▪Schwierig: Ausgelagerte Seiten werden eigentlich nicht gebraucht ▪Oftmals löst eine Maschineninstruktion mehrere PageFaults aus ▪Durch Interpretation des Befehls beim ersten Page Fault können die benötigten anderen Seiten im Voraus eingelagert werden",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 52,
      "chunk_id": "p52c1",
      "title": "Ladestrategie ▪Auf Anforderung laden ▪Damit ist man auf der sicheren Seite ▪Im Voraus laden ▪Schwier",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Weitere Page Faults werden verhindert ▪Komplettes Working Set bei Prozesseinlagerung im Voraus laden ▪Sequentielle Zugriffsmuster erkennen und Folgeseiten vorab laden MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 52,
      "chunk_id": "p52c2",
      "title": "Ladestrategie ▪Auf Anforderung laden ▪Damit ist man auf der sicheren Seite ▪Im Voraus laden ▪Schwier",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Zusammenfassung ▪Virtueller Speicher ermöglicht die Nutzung großer logischer Adressräume trotz Speicherbeschränkung ▪Komfort hat aber seinen Preis ▪Aufwand in der Hardware ▪Komplexe Algorithmen im Betriebssystem ▪„Erstaunliche“ Effekte (wie „Thrashing“) ▪Zeitverhalten nicht vorhersagbar → Einfache (Spezialzweck)Systeme, die diesen „Luxus“ nicht unbedingt benötigen, sollten besser darauf verzichten",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 53,
      "chunk_id": "p53c1",
      "title": "Zusammenfassung ▪Virtueller Speicher ermöglicht die Nutzung großer logischer Adressräume trotz Speic",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "die diesen „Luxus“ nicht unbedingt benötigen, sollten besser darauf verzichten MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 53,
      "chunk_id": "p53c2",
      "title": "Zusammenfassung ▪Virtueller Speicher ermöglicht die Nutzung großer logischer Adressräume trotz Speic",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Evaluation ▪https://evasysonline.unihamburg.de/evasys/online.php?pswd=YPKDL MOBS: 08Virtueller Speicher",
    "metadata": {
      "source": "MOBS_08_Virtueller_Speicher.pdf",
      "page": 54,
      "chunk_id": "p54c1",
      "title": "Evaluation ▪https://evasysonline.unihamburg.de/evasys/online.php?pswd=YPKDL MOBS: 08Virtueller Speic",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 CProgrammierung und Terminal (14 Punkte) Aufgabe 1 Schreibe eine CFunktion mit dem Namen algo, die zwei Zeiger auf IntegerVariablen (Typ int*) entgegennimmt und einen Wert des Typs int zurückgibt. Die Funktion soll den Wert einer der beiden Integer zurückgeben, die sie als Parameter erhalten hat",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 1,
      "chunk_id": "p1c1",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 CProgrammierung und Terminal (14 Punkte) Aufgabe 1",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Dabei soll derjenige Wert zurückgegeben werden, der an der höheren Speicheradresse positioniert ist. Vorsicht: Es soll nicht die Speicheradresse und kein Zeiger, sondern der Wert der Variablen zurückgegeben werden. [3 Punkte] Aufgabe 2 Auf den sogenannten Manpages (Dokumentation/Handbuch) in Linux wird die Benutzung einzelner Kommandos erklärt",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 1,
      "chunk_id": "p1c2",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 CProgrammierung und Terminal (14 Punkte) Aufgabe 1",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Nutze eine Kombination aus Kommandozeilenbefehlen, um herauszufinden, in wie vielen Zeilen der Manpage für den Befehl ps das Wort \"display\" (auch Kombinationen wie \"displays\" oder \"displayed\") auftaucht. Notiere hier diese Kombination von Befehlen. Das Ergebnis soll die Anzahl der Zeilen anzeigen, in denen der Ausdruck \"display\" mindestens einmal vorkommt",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 1,
      "chunk_id": "p1c3",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 CProgrammierung und Terminal (14 Punkte) Aufgabe 1",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". [3 Punkte] Aufgabe 3 Schreibe ein CProgramm, das es dem Benutzer erlaubt, eine ganze Zahl einzugeben. Nach der Eingabe startet das Programm einen Thread, der als Countdown fungiert und die eingegebene Zahl in Sekunden herunterzählt. Wenn der Countdown bei 0 angekommen ist, wird das Wort „ALARM“ auf der Konsole angegeben. Der Benutzter kann parallel beliebig viele Countdowns starten",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 1,
      "chunk_id": "p1c4",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 CProgrammierung und Terminal (14 Punkte) Aufgabe 1",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Der Benutzter kann parallel beliebig viele Countdowns starten. [6 Punkte] Hinweise: • Auch #include Befehle müssen angegeben werden. • Plattformspezifische Befehle sollte für Linux ausgewählt werden. • Das Programm muss nicht robust auf Fehleingaben programmiert werden. • Mit dem Klick auf \"Prüfen\" wird der Code kompiliert und gestartet. Allerdings unterstützt Moodle keine interaktive Eingabe",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 1,
      "chunk_id": "p1c5",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 CProgrammierung und Terminal (14 Punkte) Aufgabe 1",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Allerdings unterstützt Moodle keine interaktive Eingabe. In diesem Beispiel sind die Benutzereingaben 3 und 1 hinterlegt. Bei dem ersten Zugriff auf das Standardeingabegeräte wird die Zahl 3 eingelesen, beim zweiten Zugriff die Zahl 1. Wird das Lesen von der Tastatur in Dauerschleife aufgerufen, wird danach jeweils 0 eingelesen. • Der angezeigte Output kann demnach etwas wild aussehen",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 1,
      "chunk_id": "p1c6",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 CProgrammierung und Terminal (14 Punkte) Aufgabe 1",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". • Der angezeigte Output kann demnach etwas wild aussehen. Dies bedeutet aber nicht zwangsläufig, dass der Code falsch ist. • Um zu überprüfen, ob der Code in einem interaktiven System funktioniert, kannst Du ihn in Deiner eigenen LinuxTestumgebung oder in einem COnline Compiler testen, z.B.: https://www.onlinegdb.com/online_c_compiler • Die Prüfung ist lediglich eine Hilfestellung",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 1,
      "chunk_id": "p1c7",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 CProgrammierung und Terminal (14 Punkte) Aufgabe 1",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Das Ergebnis der Prüfung ist unabhängig von der Bewertung.",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 1,
      "chunk_id": "p1c8",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 CProgrammierung und Terminal (14 Punkte) Aufgabe 1",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Aufgabe 4 Schaue Dir den unten abgebildeten Code an, der Teil einer beliebigen CFunktion sein könnte. Wäre es möglich, über eine der Variablen a, b, c, oder d auf den ursprünglichen Wert der Variable a (42) zuzugreifen, nachdem der Code in Zeile 6 ausgeführt wurde? Begründe Deine Antwort. [2 Punkte]",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 2,
      "chunk_id": "p2c1",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Aufgabe 4 Schaue Dir den unten abgebildeten Code a",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Prozesse (9 Punkte) Aufgabe 5 Erläutere kurz, wie ein Computer mit nur einem Prozessorkern mehrere Anwendungen für den Nutzer scheinbar gleichzeitig ausführen kann. [1 Punkt] Aufgabe 6 Vereinfacht gesehen, gibt es zwischen den drei Prozesszuständen RUNNING, READY und BLOCKED vier mögliche Übergänge",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 3,
      "chunk_id": "p3c1",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Prozesse (9 Punkte) Aufgabe 5 Erläutere kurz, wie ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Erkläre für die beiden anderen Übergänge, warum ihr Auftreten unmöglich ist. [2 Punkte] Aufgabe 7, 8, 9 In dem untenstehenden Code wird ein Prozess durch den Aufruf der Funktion fork dupliziert. a) Was gibt der Code zur Laufzeit auf der Konsole aus? [3 Punkte] b) Ist die Antwort aus der vorherigen Teilaufgabe deterministisch? Begründe Deine Antwort",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 3,
      "chunk_id": "p3c2",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Prozesse (9 Punkte) Aufgabe 5 Erläutere kurz, wie ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". [1 Punkt] c) Angenommen, Zeile 23 würde ersetzt werden durch den folgenden Befehl: Würde dort in beiden Prozessen (Elternprozess und Kindprozess) die gleiche Adresse stehen? Begründe kurz Deine Antwort und erkläre kurz den Zusammenhang zwischen der angezeigten Speicheradresse und dem physikalischen Hauptspeicher. [2 Punkte]",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 3,
      "chunk_id": "p3c3",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Prozesse (9 Punkte) Aufgabe 5 Erläutere kurz, wie ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Scheduling (6 Punkte) Aufgabe 10 Beschreibe kurz warum es in Stapelverarbeitungssytemen und Systemen mit Dialogbetrieb unterschiedliche SchedulingZiele gibt",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 4,
      "chunk_id": "p4c1",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Scheduling (6 Punkte) Aufgabe 10 Beschreibe kurz w",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". [2 Punkte] Aufgabe 11 Nimm Stellung zu der folgenden Aussage: \"Der Vorteil der Schedulingstrategie FirstComeFirstServed (FCFS) ist, dass der Prozessor niemals in einen Leerlauf gelangen kann.\" [1 Punkt] Aufgabe 12, 13 Beim Scheduling von Prozessen auf die CPU müssen bei einigen Verfahren (wie beispielsweise Shortest Process Next – SPN) die Dauer für den jeweils nächsten CPUStoß vorausgesagt",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 4,
      "chunk_id": "p4c2",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Scheduling (6 Punkte) Aufgabe 10 Beschreibe kurz w",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "beispielsweise Shortest Process Next – SPN) die Dauer für den jeweils nächsten CPUStoß vorausgesagt werden",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 4,
      "chunk_id": "p4c3",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Scheduling (6 Punkte) Aufgabe 10 Beschreibe kurz w",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Dazu wird häufig das Verfahren der exponentiellen Glättung verwendet und jüngere CPUStöße stärker gewichtet als ältere. a) Beschreibe in Deinen eigenen Worten, warum dieses Verfahren vorteilhaft sein kann. [2 Punkte] b) Beschreibe kurz, was passiert, wenn der Gewichtungsfaktor α erhöht, bzw. erniedrigt wird. [1 Punkt]",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 4,
      "chunk_id": "p4c4",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Scheduling (6 Punkte) Aufgabe 10 Beschreibe kurz w",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Synchronisation (12 Punkte) Aufgabe 14 In Systemen mit nur einem Prozessor können kritische Abschnitte geschützt werden, indem Unterbrechungen gesperrt werden und so kein Kontextwechseln innerhalb eines kritischen Abschnitts erfolgen kann",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 5,
      "chunk_id": "p5c1",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Synchronisation (12 Punkte) Aufgabe 14 In Systemen",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Warum ist dieses Vorgehen bei Mehrkernprozessoren nicht möglich? [2 Punkte] Aufgabe 15, (16) Welche Aussage(n) triff/treffen auf den Synchronisationsalgorithmus beim ersten Leser/SchreiberProblem zu? [4 Punkte] Vorsicht: Die Reihenfolge im elektronischen Format kann von der hier angegebenen Reihenfolge abweichen",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 5,
      "chunk_id": "p5c2",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Synchronisation (12 Punkte) Aufgabe 14 In Systemen",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". A) Sobald ein Schreiber auf den kritischen Abschnitt wartet, kann kein weiterer Leser den Abschnitt betreten. B) Nachdem ein Schreiber den kritischen Abschnitt verlässt und dabei bereits ein Leser und ein Schreiber auf den Zutritt zum kritischen Abschnitt warten, bekommt in jedem Fall zunächst der Leser Zutritt zum kritischen Abschnitt",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 5,
      "chunk_id": "p5c3",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Synchronisation (12 Punkte) Aufgabe 14 In Systemen",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". C) Es können sich mehrere Leser gleichzeitig im kritischen Abschnitt befinden. D) Es können sich mehrere Schreiber gleichzeitig im kritischen Abschnitt befinden. Aufgabe 17, 18 Im folgenden Codeabschnitt greifen mehrere Threads in einem Prozess auf eine Ressource zu, die nur in einem begrenzten Umfang zur Verfügung steht",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 5,
      "chunk_id": "p5c4",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Synchronisation (12 Punkte) Aufgabe 14 In Systemen",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Die Variable counter gibt an, wie viele Einheiten der Ressource momentan zur Verfügung stehen. Ein Thread, der hier nicht gezeigt ist, erzeugt die Ressource und inkrementiert die Variable counter sobald eine Einheit der Ressource erzeugt wurde. Die Ressource wird in der Funktion use_resource() konsumiert",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 5,
      "chunk_id": "p5c5",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Synchronisation (12 Punkte) Aufgabe 14 In Systemen",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Die Ressource wird in der Funktion use_resource() konsumiert. Dadurch, dass die Variable counter von mehreren Prozessen manipuliert werden kann, ist sie durch die Mutexvariable lock geschützt.",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 5,
      "chunk_id": "p5c6",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Synchronisation (12 Punkte) Aufgabe 14 In Systemen",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 a) Welche zwei Effizienzprobleme lassen sich in der gezeigten Implementierung identifizieren? [4 Punkte] b) Beschreibe kurz, wie das gleiche Verhalten wie im abgebildeten Codeabschnitt effizient implementiert werden kann? (Hier ist es nicht notwendig, Code zu schreiben.) [2 Punkte]",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 6,
      "chunk_id": "p6c1",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 a) Welche zwei Effizienzprobleme lassen sich in de",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Speicherverwaltung (23 Punkte) Aufgabe 19 Wie viel Speicher wird mit dem folgenden Befehl in C allokiert? [2 Punkte] Aufgabe 20 Erkläre kurz, wie bei der segmentbasierten Adressabbildung Speicherschutzverletzungen erkannt werden",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 7,
      "chunk_id": "p7c1",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Speicherverwaltung (23 Punkte) Aufgabe 19 Wie viel",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". [2 Punkte] Aufgabe 21, (22) Welche Aussage(n) über Platzierungsstrategien ist/sind wahr? [4 Punkte] Vorsicht: Die Reihenfolge im elektronischen Format kann von der hier angegebenen Reihenfolge abweichen. A) Das BuddyVerfahren erzeugt keinen internen Verschnitt. B) Wenn beim BuddyVerfahren zwei gleichgroße Speicherbereiche (z.B",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 7,
      "chunk_id": "p7c2",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Speicherverwaltung (23 Punkte) Aufgabe 19 Wie viel",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". B) Wenn beim BuddyVerfahren zwei gleichgroße Speicherbereiche (z.B. je 4096 Bytes) frei werden, so werden sie stets zu einem großen Speicherbereich (hier 8192 Bytes) zusammengefasst. C) Wenn bei Worst Fit ein Speicherbereich belegt wird, ist möglicherweise ein Umsortieren der Liste der freien Speicherbereiche notwendig. D) Der externe Verschnitt wird durch First Fit minimiert",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 7,
      "chunk_id": "p7c3",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Speicherverwaltung (23 Punkte) Aufgabe 19 Wie viel",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Aufgabe 23 Ein Prozess greift nacheinander auf die folgenden Seiten zu: 3, 1, 2, 3, 5, 4, 1, 3, 5, 1, 2, 4 Wie viele Seitenersetzungen sind in einem System mit einem Hauptspeicher von drei Kacheln mindestens notwendig? Gib dazu die Anzahl der Seitenersetzungen an und notiere die Belegung im Hauptspeicher in folgendem Format: Hinweis: Zu Zwecken der Übersichtlichkeit empfiehlt es sich, die",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 7,
      "chunk_id": "p7c4",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Speicherverwaltung (23 Punkte) Aufgabe 19 Wie viel",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Hauptspeicher in folgendem Format: Hinweis: Zu Zwecken der Übersichtlichkeit empfiehlt es sich, die Speicherbelegung zunächst in einem Tabellenkalkulationsprogramm oder auf Papier) zu bestimmen",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 7,
      "chunk_id": "p7c5",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Speicherverwaltung (23 Punkte) Aufgabe 19 Wie viel",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Die Angabe der Kontrollzustände ist nicht erforderlich. [5 Punkte] Aufgabe 24 Erkläre kurz den Tradeoff, der sich bei der Wahl der Seitengröße bei der Speicherverwaltung ergibt. Mit anderen Worten: Nenne einen Vorteil und einen Nachteil von kleinen Seiten. [2 Punkte]",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 7,
      "chunk_id": "p7c6",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Speicherverwaltung (23 Punkte) Aufgabe 19 Wie viel",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Aufgabe 25 Bei der listenbasierten Platzierungsstrategie Worst Fit wird der aktuell größte freie Speicherbereich verwendet. Angenommen, in einem System gibt es die folgenden Speicherlücken: 102 KB, 18 KB, 22 KB, 64 KB, 40 KB, 14 KB Nacheinander kommen nun die folgenden Speicheranforderungen: 80 KB, 10 KB, 16 KB, 34 KB, 6 KB, 20 KB",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 8,
      "chunk_id": "p8c1",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Aufgabe 25 Bei der listenbasierten Platzierungsstr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Gib an, in welche Lücke die angefragte Speicherbereiche platziert werden. Gib zudem an, wie groß die verbleibende Speicherlücke ist, z.B.: 90, Rest 10 (falls von einem 90 KB großen Bereich, 80 KB belegt werden). [3 Punkte] Aufgabe 26 In einem System wird Seitenadressierung (Paging) mit einer Seitengröße von 4096 Bytes verwendet",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 8,
      "chunk_id": "p8c2",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Aufgabe 25 Bei der listenbasierten Platzierungsstr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Berechne die logische Adresse bestehend aus der virtuelle Seitennummer und dem Offset für die folgenden dezimalen Adressen: 40000, 14156, 28701 [3 Punkte] Aufgabe 27 Wenn beim Scheduling einem Prozess der Zugriff auf die CPU entzogen wird und ein anderer Prozess ausgeführt wird, findet ein Kontextwechsel statt",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 8,
      "chunk_id": "p8c3",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Aufgabe 25 Bei der listenbasierten Platzierungsstr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Erkläre kurz, wie dieser Kontextwechsel die mehrstufige Seitenadressierung mit Translation LookAside Buffer (TLB) beeinflusst. [2 Punkte]",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 8,
      "chunk_id": "p8c4",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Aufgabe 25 Bei der listenbasierten Platzierungsstr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Interprozesskommunikation (7 Punkte) Aufgabe 28 Vier Prozesse sollen über Pipes miteinander kommunizieren können. Jeder Prozess soll dabei an jeden anderen Prozess Daten senden können sowie Daten empfangen können. Wie viele Pipes werden dazu benötigt? Begründe kurz Deine Antwort",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 9,
      "chunk_id": "p9c1",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Interprozesskommunikation (7 Punkte) Aufgabe 28 Vi",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Wie viele Pipes werden dazu benötigt? Begründe kurz Deine Antwort. [2 Punkte] Aufgabe 29, 30 Bei der Kommunikation über das Internetprotokoll, bei der entweder UDP oder TCP verwendet wird, erfolgt die Adressierung des Kommunikationspartners über zwei Komponenten, nämlich IPAdresse und Port. a) Erkläre kurz wofür jede dieser beiden Komponenten genutzt wird",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 9,
      "chunk_id": "p9c2",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Interprozesskommunikation (7 Punkte) Aufgabe 28 Vi",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". a) Erkläre kurz wofür jede dieser beiden Komponenten genutzt wird. [2 Punkte] b) Warum wird als Adressierung nicht eine Kombination aus IPAdresse und ProzessID genutzt? [1 Punkt] Aufgabe 31 Erkläre kurz, wie die Verwendung von mehreren Threads die Effizienz eines Webservers steigern kann. [2 Punkte]",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 9,
      "chunk_id": "p9c3",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Interprozesskommunikation (7 Punkte) Aufgabe 28 Vi",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Einund Ausgabe (9 Punkte) Aufgabe 32 Erkläre kurz die Rolle von Direct Memory Access (DMA) wenn eine Datei vom Hintergrundspeicher in den Hauptspeicher geladen wird",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 10,
      "chunk_id": "p10c1",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Einund Ausgabe (9 Punkte) Aufgabe 32 Erkläre kurz ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Welcher Vorteil ergibt sich daraus? [3 Punkte] Aufgabe 33, 34, 35 Bei der Gerätesteuerung einer Festplatte mit rotierenden Scheiben wird versucht, die Anzahl der Spurwechsel zu minimieren. Gegeben sei die folgende Referenzfolge: 102, 32, 85, 29, 117, 50, 13, 163 Die aktuelle Spur ist 106 und die aktuelle Bewegungsrichtung ist nach rechts (aufsteigend)",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 10,
      "chunk_id": "p10c2",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Einund Ausgabe (9 Punkte) Aufgabe 32 Erkläre kurz ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". a) Wie viele Spurwechsel würde die Strategie der kürzesten Positionierzeit (Shortest Seek Time First – SSFT) benötigen? Gib zusätzlich die Reihenfolge an, in der die Aufträge abgearbeitet werden. [4 Punkte] b) Beschreibe an diesem Beispiel das Problem des Aushungerns, das bei diesem Algorithmus auftreten kann",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 10,
      "chunk_id": "p10c3",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Einund Ausgabe (9 Punkte) Aufgabe 32 Erkläre kurz ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". [1 Punkt] c) Mit dem ElevatorAlgorithmus kann das Problem des Aushungerns vermieden werden. Erkläre kurz, warum bei modernen Solid State Disks (SSDs) auf den Einsatz des ElevatorAlgorithmus verzichtet wird. [1 Punkt]",
    "metadata": {
      "source": "Klausur_2021_Ersttermin.pdf",
      "page": 10,
      "chunk_id": "p10c4",
      "title": "Moderne Betriebssysteme – Termin 1 13. Juli, 2021 Einund Ausgabe (9 Punkte) Aufgabe 32 Erkläre kurz ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – Deadlocks mit Material von Olaf Spinczyk (Universität Osnabrück) und Horst Schirmeier (TU Dortmund)",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 1,
      "chunk_id": "p1c1",
      "title": "Prof. Dr. Janick Edinger Moderne Betriebssysteme – Deadlocks mit Material von Olaf Spinczyk (Univers",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Wiederholung Ursachenforschung Verklemmungen von Prozessen Ein klassisches Verklemmungsproblem Gegenmaßnahmen, Verklemmungsbekämpfung MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 2,
      "chunk_id": "p2c1",
      "title": "Inhalt Wiederholung Ursachenforschung Verklemmungen von Prozessen Ein klassisches Verklemmungspr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Wiederholung Ursachenforschung Verklemmungen von Prozessen Ein klassisches Verklemmungsproblem Gegenmaßnahmen, Verklemmungsbekämpfung MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 3,
      "chunk_id": "p3c1",
      "title": "Inhalt Wiederholung Ursachenforschung Verklemmungen von Prozessen Ein klassisches Verklemmungspr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Wiederholung Prozesse in einem Rechner arbeiten nebenläufig Zur Koordination von Prozessen werden Synchronisationsprimitiven eingesetzt Grundidee ist das passive Warten Der Semaphor erlaubt... gegenseitigen Ausschluss einseitige Synchronisation betriebsmittelorientierte Synchronisation Wartemechanismen führen zu Verklemmungsproblemen MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 4,
      "chunk_id": "p4c1",
      "title": "Wiederholung Prozesse in einem Rechner arbeiten nebenläufig Zur Koordination von Prozessen werden ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verklemmung auf der Straße MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 5,
      "chunk_id": "p5c1",
      "title": "Verklemmung auf der Straße MOBS: 05Deadlocks",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Wiederholung Ursachenforschung Verklemmungen von Prozessen Ein klassisches Verklemmungsproblem Gegenmaßnahmen, Verklemmungsbekämpfung MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 6,
      "chunk_id": "p6c1",
      "title": "Inhalt Wiederholung Ursachenforschung Verklemmungen von Prozessen Ein klassisches Verklemmungspr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Ursachenforschung …am Beispiel MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 7,
      "chunk_id": "p7c1",
      "title": "Ursachenforschung …am Beispiel MOBS: 05Deadlocks",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Ursachenforschung …abstrakt MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 8,
      "chunk_id": "p8c1",
      "title": "Ursachenforschung …abstrakt MOBS: 05Deadlocks",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Ursachenforschung …abstrakt MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 9,
      "chunk_id": "p9c1",
      "title": "Ursachenforschung …abstrakt MOBS: 05Deadlocks",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Wiederholung Ursachenforschung Verklemmungen von Prozessen Konsumierbare und nichtkonsumierbare Betriebsmittel Modellierung durch Betriebsmittelbelegungsgraphen Ein klassisches Verklemmungsproblem Gegenmaßnahmen, Verklemmungsbekämpfung MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 10,
      "chunk_id": "p10c1",
      "title": "Inhalt Wiederholung Ursachenforschung Verklemmungen von Prozessen Konsumierbare und nichtkonsumi",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verklemmung von Prozessen Der Begriﬀ bezeichnet (in der Informatik) „[…] einen Zustand, in dem die beteiligten Prozesse wechselseitig auf den Eintritt von Bedingungen warten, die nur durch andere Prozesse in dieser Gruppe selbst hergestellt werden können.“Jürgen Nehmer und Peter Sturm. Systemsoftware: Grundlagen moderner Betriebssysteme. dpunkt.Verlag GmbH, zweite Ausgabe, 2001 MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 11,
      "chunk_id": "p11c1",
      "title": "Verklemmung von Prozessen Der Begriﬀ bezeichnet (in der Informatik) „[…] einen Zustand, in dem die b",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verklemmung von Prozessen 1. Variante: Deadlock Passives Warten Prozesszustand BLOCKED 2",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 12,
      "chunk_id": "p12c1",
      "title": "Verklemmung von Prozessen 1. Variante: Deadlock Passives Warten Prozesszustand BLOCKED 2. Varian",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Variante: Deadlock Passives Warten Prozesszustand BLOCKED 2. Variante: Livelock Aktives Warten (busy waiting oder „lazy“ busy waiting) Prozesszustand beliebig (auch RUNNING), aber kein Fortschritt Deadlocks sind das vergleichsweise geringere Übel Zustand eindeutig erkennbar → Basis zur „Auflösung“ gegeben Extrem hohe Systembelastung durch aktives Warten MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 12,
      "chunk_id": "p12c2",
      "title": "Verklemmung von Prozessen 1. Variante: Deadlock Passives Warten Prozesszustand BLOCKED 2. Varian",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Bedingungen für eine Verklemmung Damit es zu einer Verklemmung kommen kann, müssen alle folgenden Bedingungen erfüllt sein: („notwendige Bedingungen“) 1. Exklusive Belegung von Betriebsmitteln („mutual exclusion“ ) die umstrittenen Betriebsmittel sind nur unteilbar nutzbar 2. Nachforderung von Betriebsmitteln („hold and wait“ ) die umstrittenen Betriebsmittel sind nur schrittweise belegbar 3",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 13,
      "chunk_id": "p13c1",
      "title": "Bedingungen für eine Verklemmung Damit es zu einer Verklemmung kommen kann, müssen alle folgenden B",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Kein Entzug von Betriebsmitteln („no preemption“ ) die umstrittenen Betriebsmittel sind nicht zurückforderbar MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 13,
      "chunk_id": "p13c2",
      "title": "Bedingungen für eine Verklemmung Damit es zu einer Verklemmung kommen kann, müssen alle folgenden B",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Bedingungen für eine Verklemmung Erst wenn zur Laufzeit eine weitere Bedingung eintritt, liegt tatsächlich eine Verklemmung vor: 4. Zirkuläres Warten („circular wait“ ) Eine geschlossene Kette wechselseitig wartender Prozesse MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 14,
      "chunk_id": "p14c1",
      "title": "Bedingungen für eine Verklemmung Erst wenn zur Laufzeit eine weitere Bedingung eintritt, liegt tats",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Betriebsmittel… werden vom Betriebssystem verwaltet und den Prozessen zugänglich gemacht",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 15,
      "chunk_id": "p15c1",
      "title": "Betriebsmittel… werden vom Betriebssystem verwaltet und den Prozessen zugänglich gemacht. Man unter",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Man unterscheidet zwei Arten: Wiederverwendbare Betriebsmittel Werden von Prozessen für eine bestimmte Zeit belegt und anschließend wieder freigegeben Beispiele: CPU, Hauptund Hintergrundspeicher, E/AGeräte, Systemdatenstrukturen wie Dateien, Prozesstabelleneinträge,… Typische Zugriffssynchronisation: Gegenseitiger Ausschluss Konsumierbare Betriebsmittel Werden im laufenden System erzeugt",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 15,
      "chunk_id": "p15c2",
      "title": "Betriebsmittel… werden vom Betriebssystem verwaltet und den Prozessen zugänglich gemacht. Man unter",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Gegenseitiger Ausschluss Konsumierbare Betriebsmittel Werden im laufenden System erzeugt (produziert) und zerstört (konsumiert) Beispiele: Unterbrechungsanforderungen, Signale, Nachrichten, Daten von Eingabegeräten Typische Zugriffssynchronisation: Einseitige Synchronisation MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 15,
      "chunk_id": "p15c3",
      "title": "Betriebsmittel… werden vom Betriebssystem verwaltet und den Prozessen zugänglich gemacht. Man unter",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Wiederverwendbare Betriebsmittel Es kommt zu einer Verklemmung, wenn zwei Prozesse ein wiederwendbares Betriebsmittel belegt haben, dass vom jeweils anderen hinzugefordert wird Beispiel: Ein Rechnersystem hat 200 GB Hauptspeicher. Zwei Prozesse belegen den Speicher schrittweise. Die Belegung erfolgt blockierend MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 16,
      "chunk_id": "p16c1",
      "title": "Wiederverwendbare Betriebsmittel Es kommt zu einer Verklemmung, wenn zwei Prozesse ein wiederwendba",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Konsumierbare Betriebsmittel Es kommt zu einer Verklemmung, wenn zwei Prozesse auf ein konsumierbares Betriebsmittel warten, das vom jeweils anderen produziert wird Beispiel: Synchronisationssignale werden mit Hilfe der Semaphoroperation wait und signal zwischen zwei Prozessen „verschickt“ MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 17,
      "chunk_id": "p17c1",
      "title": "Konsumierbare Betriebsmittel Es kommt zu einer Verklemmung, wenn zwei Prozesse auf ein konsumierbar",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Betriebsmittelbelegungsgraphen (engl. resource allocation graphs) ...werden benutzt, um Verklemmungssituationen zu visualisieren und auch automatisch zu erkennen Beschreiben einen aktuellen Systemzustand Die Knoten sind Prozesse und Betriebsmittel Die Kanten zeigen eine Belegung oder eine Anforderung an MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 18,
      "chunk_id": "p18c1",
      "title": "Betriebsmittelbelegungsgraphen (engl. resource allocation graphs) ...werden benutzt, um Verklemmung",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Betriebsmittelbelegungsgraphen Frage: Liegt zirkuläres Warten vor? Wer ist beteiligt? Es gibt 7 Prozesse A bis G und 6 Betriebsmittel R bis W Aktueller Zustand: A belegt R und verlangt S. B belegt nichts, verlangt aber T. C belegt nichts, verlangt aber S. D belegt U und S und verlangt T. E belegt T und verlangt V. F belegt W und verlangt S. G belegt V und verlangt U. MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 19,
      "chunk_id": "p19c1",
      "title": "Betriebsmittelbelegungsgraphen Frage: Liegt zirkuläres Warten vor? Wer ist beteiligt? Es gibt 7 Pr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Betriebsmittelbelegungsgraphen MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 20,
      "chunk_id": "p20c1",
      "title": "Betriebsmittelbelegungsgraphen MOBS: 05Deadlocks",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Wiederholung Ursachenforschung Verklemmungen von Prozessen Ein klassisches Verklemmungsproblem „Die fünf Philosophen“ Gegenmaßnahmen, Verklemmungsbekämpfung MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 21,
      "chunk_id": "p21c1",
      "title": "Inhalt Wiederholung Ursachenforschung Verklemmungen von Prozessen Ein klassisches Verklemmungspr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Die fünf speisenden Philosophen MOBS: 05Deadlocks Prozess → Philosoph Betriebsmittel → Gabel (unteilbar)",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 22,
      "chunk_id": "p22c1",
      "title": "Die fünf speisenden Philosophen MOBS: 05Deadlocks Prozess → Philosoph Betriebsmittel → Gabel (unteil",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verklemmte Philosophen? Die drei ersten notwendigen Bedingungen sind erfüllt: „mutual exclusion“ Aus hygienischen Gründen dürfen sich die Philosophen keine Gabeln teilen „hold and wait“ Die Philosophen hängen vor dem Essen noch so sehr ihren Gedanken nach, dass sie weder echt gleichzeitig die Gabeln greifen können, noch auf die Idee kommen, eine Gabel wieder wegzulegen „no preemption“ Einem",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 23,
      "chunk_id": "p23c1",
      "title": "Verklemmte Philosophen? Die drei ersten notwendigen Bedingungen sind erfüllt: „mutual exclusion“ A",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "greifen können, noch auf die Idee kommen, eine Gabel wieder wegzulegen „no preemption“ Einem anderen Philosophen die Gabel zu entreißen, kommt selbstverständlich nicht in Frage Aber kommt es wirklich zu einer Verklemmung? MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 23,
      "chunk_id": "p23c2",
      "title": "Verklemmte Philosophen? Die drei ersten notwendigen Bedingungen sind erfüllt: „mutual exclusion“ A",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Speisende Philosophen: Version 1 MOBS: 05Deadlocks Mit Hilfe eines Semaphors wird gegenseitiger Ausschluss beim Zugriff auf die Gabeln garantiert. Jeder Philosoph nimmt erst sein rechte und dann seine linke Gabel.",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 24,
      "chunk_id": "p24c1",
      "title": "Speisende Philosophen: Version 1 MOBS: 05Deadlocks Mit Hilfe eines Semaphors wird gegenseitiger Auss",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "…leider verklemmungsgefährdet MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 25,
      "chunk_id": "p25c1",
      "title": "…leider verklemmungsgefährdet MOBS: 05Deadlocks",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "…leider verklemmungsgefährdet MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 26,
      "chunk_id": "p26c1",
      "title": "…leider verklemmungsgefährdet MOBS: 05Deadlocks",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Speisende Philosophen: Version 2 Verklemmungsfreiheit? – Ja,… Max. 1 Prozess kann auf eine Gabel warten (Zyklus braucht 2!) Ein Prozess, der auf mutex wartet, hat keine Gabel Eine „gute Lösung“? – Nein,… MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 27,
      "chunk_id": "p27c1",
      "title": "Speisende Philosophen: Version 2 Verklemmungsfreiheit? – Ja,… Max. 1 Prozess kann auf eine Gabel wa",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Speisende Philosophen: Version 2 Verklemmungsfreiheit? – Ja,… Max. 1 Prozess kann auf eine Gabel warten (Zyklus braucht 2!) Ein Prozess, der auf mutex wartet, hat keine Gabel Eine „gute Lösung“? – Nein,… Wenn philowho isst, blockiert philowho+1 im kritischen Abschnitt. Alle weiteren blockieren dann auch. Viele Spagetti werden kalt",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 28,
      "chunk_id": "p28c1",
      "title": "Speisende Philosophen: Version 2 Verklemmungsfreiheit? – Ja,… Max. 1 Prozess kann auf eine Gabel w",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Alle weiteren blockieren dann auch. Viele Spagetti werden kalt. Geringe Nebenläufigkeit und schlechte Ressourcennutzung MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 28,
      "chunk_id": "p28c2",
      "title": "Speisende Philosophen: Version 2 Verklemmungsfreiheit? – Ja,… Max. 1 Prozess kann auf eine Gabel w",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Speisende Philosophen: Version 3 MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 29,
      "chunk_id": "p29c1",
      "title": "Speisende Philosophen: Version 3 MOBS: 05Deadlocks",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion: Speisende Philosophen Im Speziellen: Es gibt meist viele Möglichkeiten für Verklemmungsfreiheit zu sorgen Lösungen unterscheiden sich im Grad der möglichen Nebenläufigkeit Bei einer zu restriktiven Lösung liegen Betriebsmittel zeitweilig unnötig brach Im Allgemeinen: Repräsentatives Beispiel für Verklemmungsprobleme bei der Verwaltung unteilbarer Betriebsmittel Geht auf E",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 30,
      "chunk_id": "p30c1",
      "title": "Diskussion: Speisende Philosophen Im Speziellen: Es gibt meist viele Möglichkeiten für Verklemmungs",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". Dijkstra zurück (1965) Etabliertes Standardszenario für die Bewertung und Illustration von Betriebssystemund Sprachmechanismen zur nebenläufigen Programmierung MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 30,
      "chunk_id": "p30c2",
      "title": "Diskussion: Speisende Philosophen Im Speziellen: Es gibt meist viele Möglichkeiten für Verklemmungs",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Inhalt Wiederholung Ursachenforschung Verklemmungen von Prozessen Ein klassisches Verklemmungsproblem Gegenmaßnahmen, Verklemmungsbekämpfung Vorbeugung Vermeidung Erkennung und Auflösung MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 31,
      "chunk_id": "p31c1",
      "title": "Inhalt Wiederholung Ursachenforschung Verklemmungen von Prozessen Ein klassisches Verklemmungspr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verklemmungsvorbeugung (engl. deadlock prevention) indirekte Methoden entkräften eine der Bedingungen 13 1. nichtblockierende Verfahren verwenden 2. Betriebsmittelanforderungen unteilbar (atomar) auslegen 3. Betriebsmittelentzug durch Virtualisierung ermöglichen virtueller Speicher, virtuelle Geräte, virtuelle Prozessoren direkte Methoden entkräften Bedingung 4 4",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 32,
      "chunk_id": "p32c1",
      "title": "Verklemmungsvorbeugung (engl. deadlock prevention) indirekte Methoden entkräften eine der Bedingung",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". lineare/totale Ordnung von Betriebsmittelklassen einführen: Betriebsmittel Bi ist nur dann erfolgreich vor Bj belegbar, wenn i linear vor j angeordnet ist (d.h. i < j) Regeln, die das Eintreten von Verklemmungen verhindern Methoden, die zur Entwurfsbzw. Implementierungszeit greifen MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 32,
      "chunk_id": "p32c2",
      "title": "Verklemmungsvorbeugung (engl. deadlock prevention) indirekte Methoden entkräften eine der Bedingung",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verklemmungsvermeidung (engl",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 33,
      "chunk_id": "p33c1",
      "title": "Verklemmungsvermeidung (engl. deadlock avoidance) Verhinderung von zirkulärem Warten (im laufenden ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". deadlock avoidance) Verhinderung von zirkulärem Warten (im laufenden System) durch strategische Maßnahmen: keine der ersten drei notwendigen Bedingungen wird entkräftet fortlaufende Bedarfsanalyse schließt zirkuläres Warten aus Betriebsmittelanforderungen der Prozesse sind zu steuern: „sicherer Zustand“ muss immer beibehalten werden: es existiert eine Prozessabfolge, bei der jeder Prozess",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 33,
      "chunk_id": "p33c2",
      "title": "Verklemmungsvermeidung (engl. deadlock avoidance) Verhinderung von zirkulärem Warten (im laufenden ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Zustand“ muss immer beibehalten werden: es existiert eine Prozessabfolge, bei der jeder Prozess seinen maximalen Betriebsmittelbedarf decken kann „unsichere Zustände“ werden umgangen: Zuteilungsablehnung im Falle nicht abgedeckten Betriebsmittelbedarfs anfordernde Prozesse nicht bedienen bzw",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 33,
      "chunk_id": "p33c3",
      "title": "Verklemmungsvermeidung (engl. deadlock avoidance) Verhinderung von zirkulärem Warten (im laufenden ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". frühzeitig suspendieren Problem: À priori Wissen über den maximalen Betriebsmittelbedarf ist erforderlich MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 33,
      "chunk_id": "p33c4",
      "title": "Verklemmungsvermeidung (engl. deadlock avoidance) Verhinderung von zirkulärem Warten (im laufenden ",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Sicherer/unsicherer Zustand (am Beispiel der speisenden Philosophen) Ausgangspunkt: fünf Gabeln sind insgesamt vorhanden jeder der fünf Philosophen braucht zwei Gabeln zum Essen Situation: P0, P1 und P2 haben je eine Gabel und zwei Gabeln sind frei P3 fordert eine Gabel an → eine Gabel wäre dann noch frei sicherer Zustand: einer von drei Philosophen könnte essen die Anforderung von P3 wird",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 34,
      "chunk_id": "p34c1",
      "title": "Sicherer/unsicherer Zustand (am Beispiel der speisenden Philosophen) Ausgangspunkt: fünf Gabeln sin",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "noch frei sicherer Zustand: einer von drei Philosophen könnte essen die Anforderung von P3 wird akzeptiert P4 fordert eine Gabel an → keine Gabel wäre dann mehr frei unsicherer Zustand: keiner der Philosophen könnte essen die Anforderung von P4 muss warten haben vier Philosophen je eine Gabel, wird der fünfte gestoppt bevor er die erste Gabel nimmt MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 34,
      "chunk_id": "p34c2",
      "title": "Sicherer/unsicherer Zustand (am Beispiel der speisenden Philosophen) Ausgangspunkt: fünf Gabeln sin",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Sicherer/unsicherer Zustand (am Beispiel der speisenden Philosophen) Ausgangspunkt: fünf Gabeln sind insgesamt vorhanden jeder der fünf Philosophen braucht zwei Gabeln zum Essen Situation: P0, P1 und P2 haben je eine Gabel und zwei Gabeln sind frei P3 fordert eine Gabel an → eine Gabel wäre dann noch frei sicherer Zustand: einer von drei Philosophen könnte essen die Anforderung von P3 wird",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 35,
      "chunk_id": "p35c1",
      "title": "Sicherer/unsicherer Zustand (am Beispiel der speisenden Philosophen) Ausgangspunkt: fünf Gabeln sin",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "noch frei sicherer Zustand: einer von drei Philosophen könnte essen die Anforderung von P3 wird akzeptiert P4 fordert eine Gabel an → keine Gabel wäre dann mehr frei unsicherer Zustand: keiner der Philosophen könnte essen die Anforderung von P4 muss warten haben vier Philosophen je eine Gabel, wird der fünfte gestoppt bevor er die erste Gabel nimmt MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 35,
      "chunk_id": "p35c2",
      "title": "Sicherer/unsicherer Zustand (am Beispiel der speisenden Philosophen) Ausgangspunkt: fünf Gabeln sin",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Sicherer/unsicherer Zustand (am Beispiel mehrfach vorhandener Betriebsmittel) Ausgangspunkt: ein primitives UNIX System mit max. 12 SharedMemory Segmenten Prozess P0 benötigt max",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 36,
      "chunk_id": "p36c1",
      "title": "Sicherer/unsicherer Zustand (am Beispiel mehrfach vorhandener Betriebsmittel) Ausgangspunkt: ein pr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". 12 SharedMemory Segmenten Prozess P0 benötigt max. 10 Segmente, P1 vier und P2 neun Situation: P0 belegt 6 Segmente, P1 und P2 je zwei; zwei Segmente sind frei P2 fordert ein Segment an, eins bliebe frei → unsicherer Zustand die Anforderung von P2 wird abgelehnt, P2 muss warten P0 fordert zwei Segm",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 36,
      "chunk_id": "p36c2",
      "title": "Sicherer/unsicherer Zustand (am Beispiel mehrfach vorhandener Betriebsmittel) Ausgangspunkt: ein pr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". an, keines bliebe frei → unsicherer Zustand die Anforderung von P0 wird abgelehnt, P0 muss warten sichere Prozessfolge: P1 → P0 → P2 MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 36,
      "chunk_id": "p36c3",
      "title": "Sicherer/unsicherer Zustand (am Beispiel mehrfach vorhandener Betriebsmittel) Ausgangspunkt: ein pr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Sicherer/unsicherer Zustand (am Beispiel mehrfach vorhandener Betriebsmittel) Ausgangspunkt: ein primitives UNIX System mit max. 12 SharedMemory Segmenten Prozess P0 benötigt max",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 37,
      "chunk_id": "p37c1",
      "title": "Sicherer/unsicherer Zustand (am Beispiel mehrfach vorhandener Betriebsmittel) Ausgangspunkt: ein pr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". 12 SharedMemory Segmenten Prozess P0 benötigt max. 10 Segmente, P1 vier und P2 neun Situation: P0 belegt 6 Segmente, P1 und P2 je zwei; zwei Segmente sind frei P2 fordert ein Segment an, eins bliebe frei → unsicherer Zustand die Anforderung von P2 wird abgelehnt, P2 muss warten P0 fordert zwei Segm",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 37,
      "chunk_id": "p37c2",
      "title": "Sicherer/unsicherer Zustand (am Beispiel mehrfach vorhandener Betriebsmittel) Ausgangspunkt: ein pr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". an, keines bliebe frei → unsicherer Zustand die Anforderung von P0 wird abgelehnt, P0 muss warten sichere Prozessfolge: P1 → P0 → P2 MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 37,
      "chunk_id": "p37c3",
      "title": "Sicherer/unsicherer Zustand (am Beispiel mehrfach vorhandener Betriebsmittel) Ausgangspunkt: ein pr",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verklemmungserkennung (engl",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 38,
      "chunk_id": "p38c1",
      "title": "Verklemmungserkennung (engl. deadlock detection) Verklemmungen werden (stillschweigend) in Kauf gen",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". deadlock detection) Verklemmungen werden (stillschweigend) in Kauf genommen („ostrich algorithm“ )… Nichts im System verhindert das Auftreten von Wartezyklen Keine der vier Bedingungen wird entkräftet Ansatz: Wartegraph erstellen und Zyklen suchen → O(n) Zu häuﬁge Überprüfung verschwendet Betriebsmittel/Rechenleistung Zu seltene Überprüfung lässt Betriebsmittel brach liegen Zyklensuche",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 38,
      "chunk_id": "p38c2",
      "title": "Verklemmungserkennung (engl. deadlock detection) Verklemmungen werden (stillschweigend) in Kauf gen",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Zu seltene Überprüfung lässt Betriebsmittel brach liegen Zyklensuche geschieht zumeist in großen Zeitabständen, wenn… Betriebsmittelanforderungen zu lange andauern die Auslastung der CPU trotz Prozesszunahme sinkt die CPU bereits über einen sehr langen Zeitraum untätig ist MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 38,
      "chunk_id": "p38c3",
      "title": "Verklemmungserkennung (engl. deadlock detection) Verklemmungen werden (stillschweigend) in Kauf gen",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Verklemmungsauflösung Erholungsphase nach der Erkennungsphase Prozesse abbrechen und so Betriebsmittel frei bekommen Verklemmte Prozesse schrittweise abbrechen (großer Aufwand) Mit dem „effektivsten Opfer“ (?) beginnen Alle verklemmten Prozesse terminieren (großer Schaden) Betriebsmittel entziehen und mit dem „effektivsten Opfer“ (?) beginnen Betreffenden Prozess zurückfahren bzw",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 39,
      "chunk_id": "p39c1",
      "title": "Verklemmungsauflösung Erholungsphase nach der Erkennungsphase Prozesse abbrechen und so Betriebsmit",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": ". wieder aufsetzen Transaktionen, checkpointing/recovery (großer Aufwand) Ein Aushungern der zurückgefahrenen Prozesse ist zu vermeiden Außerdem Vorsicht vor Livelocks! Gratwanderung zwischen Schaden und Aufwand: Schäden sind unvermeidbar und die Frage ist, wie sie sich auswirken MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 39,
      "chunk_id": "p39c2",
      "title": "Verklemmungsauflösung Erholungsphase nach der Erkennungsphase Prozesse abbrechen und so Betriebsmit",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Diskussion der Gegenmaßnahmen Verfahren zum Vermeiden/Erkennen sind im Betriebssystemkontext weniger praxisrelevant Sie sind kaum umzusetzen, zu aufwändig und damit nicht einsetzbar Zudem macht die Vorherrschaft sequentieller Programmierung diese Verfahren wenig notwendig Verklemmungsgefahr ist lösbar durch Virtualisierung von Betriebsmitteln Prozesse beanspruchen/belegen ausschließlich",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 40,
      "chunk_id": "p40c1",
      "title": "Diskussion der Gegenmaßnahmen Verfahren zum Vermeiden/Erkennen sind im Betriebssystemkontext wenige",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "ist lösbar durch Virtualisierung von Betriebsmitteln Prozesse beanspruchen/belegen ausschließlich logische Betriebsmittel Der Trick besteht darin, in kritischen Momenten den Prozessen (ohne ihr Wissen) physische Betriebsmittel entziehen zu können Dadurch wird die Bedingung der Nichtentziehbarkeit entkräftet  Eher praxisrelevant/verbreitet sind die Vorbeugungsmaßnahmen MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 40,
      "chunk_id": "p40c2",
      "title": "Diskussion der Gegenmaßnahmen Verfahren zum Vermeiden/Erkennen sind im Betriebssystemkontext wenige",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Zusammenfassung Verklemmung bedeutet „deadlock“ oder „livelock“ „[...] einen Zustand, in dem die beteiligten Prozesse wechselseitig auf den Eintritt von Bedingungen warten, die nur durch andere Prozesse in dieser Gruppe selbst hergestellt werden können“ Dabei ist der livelock das größere Problem beider Verklemmungsarten Für eine Verklemmung müssen vier Bedingungen gleichzeitig gelten:",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 41,
      "chunk_id": "p41c1",
      "title": "Zusammenfassung Verklemmung bedeutet „deadlock“ oder „livelock“ „[...] einen Zustand, in dem die b",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  },
  {
    "page_content": "Problem beider Verklemmungsarten Für eine Verklemmung müssen vier Bedingungen gleichzeitig gelten: Exklusive Belegung, Nachforderung, kein Entzug von Betriebsmitteln Zirkuläres Warten der die Betriebsmittel beanspruchenden Prozesse Verklemmungsbekämpfung meint: Vorbeugen, Vermeiden, Erkennen/Auflösen die Verfahren können im Mix zum Einsatz kommen MOBS: 05Deadlocks",
    "metadata": {
      "source": "MOBS_05_Deadlocks.pdf",
      "page": 41,
      "chunk_id": "p41c2",
      "title": "Zusammenfassung Verklemmung bedeutet „deadlock“ oder „livelock“ „[...] einen Zustand, in dem die b",
      "ocr_used": false,
      "course": "moderne_betriebssysteme"
    }
  }
]